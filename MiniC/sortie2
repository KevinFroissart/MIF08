java -jar /opt/antlr-4.9.2-complete.jar MiniC.g4 -Dlanguage=Python3 -visitor -no-listener
pyright .
No configuration file found.
pyproject.toml file found at /home/compil/MiniC.
Loading pyproject.toml file at /home/compil/MiniC/pyproject.toml
Assuming Python version 3.8
Assuming Python platform Linux
Auto-excluding **/node_modules
Auto-excluding **/__pycache__
Auto-excluding .git
Searching for source files
Found 23 source files
0 errors, 0 warnings, 0 infos 
Completed in 9.691sec
python3 -m pytest -vv -rs --failed-first --cov="/home/compil/MiniC" --cov-report=term --cov-report=html  test_interpreter.py
============================= test session starts ==============================
platform linux -- Python 3.8.10, pytest-6.2.5, py-1.10.0, pluggy-1.0.0 -- /usr/bin/python3
cachedir: .pytest_cache
rootdir: /home/compil/MiniC
plugins: cov-2.12.1
collecting ... collected 44 items
run-last-failure: rerun previous 1 failure first

test_interpreter.py::TestInterpret::test_eval[./TP03/tests/students/type_errors/test_assign_wrong_type.c] PASSED [  2%]
test_interpreter.py::TestInterpret::test_eval[./TP03/tests/provided/examples-types/bad_def01.c] PASSED [  4%]
test_interpreter.py::TestInterpret::test_eval[./TP03/tests/provided/examples-types/bad_type00.c] PASSED [  6%]
test_interpreter.py::TestInterpret::test_eval[./TP03/tests/provided/examples-types/bad_type01.c] PASSED [  9%]
test_interpreter.py::TestInterpret::test_eval[./TP03/tests/provided/examples-types/bad_type02.c] PASSED [ 11%]
test_interpreter.py::TestInterpret::test_eval[./TP03/tests/provided/examples-types/bad_type03.c] PASSED [ 13%]
test_interpreter.py::TestInterpret::test_eval[./TP03/tests/provided/examples-types/bad_type04.c] PASSED [ 15%]
test_interpreter.py::TestInterpret::test_eval[./TP03/tests/provided/examples-types/bad_type_bool_bool.c] PASSED [ 18%]
test_interpreter.py::TestInterpret::test_eval[./TP03/tests/provided/examples-types/double_decl00.c] PASSED [ 20%]
test_interpreter.py::TestInterpret::test_eval[./TP03/tests/provided/examples/bad_main.c] PASSED [ 22%]
test_interpreter.py::TestInterpret::test_eval[./TP03/tests/provided/examples/test_assign.c] PASSED [ 25%]
test_interpreter.py::TestInterpret::test_eval[./TP03/tests/provided/examples/test_compare.c] PASSED [ 27%]
test_interpreter.py::TestInterpret::test_eval[./TP03/tests/provided/examples/test_expr.c] PASSED [ 29%]
test_interpreter.py::TestInterpret::test_eval[./TP03/tests/provided/examples/test_print.c] PASSED [ 31%]
test_interpreter.py::TestInterpret::test_eval[./TP03/tests/provided/examples/test_print_int.c] PASSED [ 34%]
test_interpreter.py::TestInterpret::test_eval[./TP03/tests/provided/examples/test_str_assign.c] PASSED [ 36%]
test_interpreter.py::TestInterpret::test_eval[./TP03/tests/provided/examples/while_motion1.c] PASSED [ 38%]
test_interpreter.py::TestInterpret::test_eval[./TP03/tests/provided/strcat/test_string01.c] PASSED [ 40%]
test_interpreter.py::TestInterpret::test_eval[./TP03/tests/provided/strcat/test_string02.c] PASSED [ 43%]
test_interpreter.py::TestInterpret::test_eval[./TP03/tests/provided/strcat/unititialized_str.c] PASSED [ 45%]
test_interpreter.py::TestInterpret::test_eval[./TP03/tests/provided/uninitialised/bool.c] PASSED [ 47%]
test_interpreter.py::TestInterpret::test_eval[./TP03/tests/provided/uninitialised/float.c] PASSED [ 50%]
test_interpreter.py::TestInterpret::test_eval[./TP03/tests/provided/uninitialised/int.c] PASSED [ 52%]
test_interpreter.py::TestInterpret::test_eval[./TP03/tests/students/assignements/test_default_assign.c] PASSED [ 54%]
test_interpreter.py::TestInterpret::test_eval[./TP03/tests/students/operators/test_division_by_0.c] PASSED [ 56%]
test_interpreter.py::TestInterpret::test_eval[./TP03/tests/students/operators/test_float_division.c] PASSED [ 59%]
test_interpreter.py::TestInterpret::test_eval[./TP03/tests/students/operators/test_minus_expr.c] PASSED [ 61%]
test_interpreter.py::TestInterpret::test_eval[./TP03/tests/students/operators/test_minus_operator.c] PASSED [ 63%]
test_interpreter.py::TestInterpret::test_eval[./TP03/tests/students/operators/test_modulo.c] PASSED [ 65%]
test_interpreter.py::TestInterpret::test_eval[./TP03/tests/students/operators/test_modulo_by_0.c] PASSED [ 68%]
test_interpreter.py::TestInterpret::test_eval[./TP03/tests/students/statements/test_if_else.c] PASSED [ 70%]
test_interpreter.py::TestInterpret::test_eval[./TP03/tests/students/statements/test_while.c] PASSED [ 72%]
test_interpreter.py::TestInterpret::test_eval[./TP03/tests/students/type_errors/test_addition_string_wrong_type.c] PASSED [ 75%]
test_interpreter.py::TestInterpret::test_eval[./TP03/tests/students/type_errors/test_addition_wrong_type.c] PASSED [ 77%]
test_interpreter.py::TestInterpret::test_eval[./TP03/tests/students/type_errors/test_if_statement_wrong_type.c] PASSED [ 79%]
test_interpreter.py::TestInterpret::test_eval[./TP03/tests/students/type_errors/test_multiplication_wrong_type.c] PASSED [ 81%]
test_interpreter.py::TestInterpret::test_eval[./TP03/tests/students/type_errors/test_not_wrong_type.c] PASSED [ 84%]
test_interpreter.py::TestInterpret::test_eval[./TP03/tests/students/type_errors/test_or_not_bool.c] PASSED [ 86%]
test_interpreter.py::TestInterpret::test_eval[./TP03/tests/students/type_errors/test_println_float_wrong_type.c] PASSED [ 88%]
test_interpreter.py::TestInterpret::test_eval[./TP03/tests/students/type_errors/test_println_string_wrong_type.c] PASSED [ 90%]
test_interpreter.py::TestInterpret::test_eval[./TP03/tests/students/type_errors/test_relational_unhandled_type.c] PASSED [ 93%]
test_interpreter.py::TestInterpret::test_eval[./TP03/tests/students/type_errors/test_relational_wrong_type.c] PASSED [ 95%]
test_interpreter.py::TestInterpret::test_eval[./TP03/tests/students/type_errors/test_unary_minus_wrong_type.c] PASSED [ 97%]
test_interpreter.py::TestInterpret::test_eval[./TP03/tests/students/type_errors/test_while_statement_wrong_type.c] PASSED [100%]

---------- coverage: platform linux, python 3.8.10-final-0 -----------
Name                            Stmts   Miss  Cover
---------------------------------------------------
Errors.py                           8      0   100%
MiniCC.py                         157    157     0%
MiniCInterpreter.py                48      5    90%
MiniCLexer.py                     184      1    99%
MiniCParser.py                   1407    295    79%
MiniCVisitor.py                    74     29    61%
TP03/MiniCInterpretVisitor.py     128      0   100%
TP03/MiniCTypingVisitor.py        138      0   100%
test_codegen.py                   155    155     0%
test_expect_pragma.py             100     38    62%
test_interpreter.py                33      2    94%
---------------------------------------------------
TOTAL                            2432    682    72%
Coverage HTML written to dir htmlcov


============================= 44 passed in 25.15s ==============================
python3 -m pytest -vv -rs --failed-first --cov="/home/compil/MiniC" --cov-report=term --cov-report=html  ./test_codegen.py
============================= test session starts ==============================
platform linux -- Python 3.8.10, pytest-6.2.5, py-1.10.0, pluggy-1.0.0 -- /usr/bin/python3
cachedir: .pytest_cache
rootdir: /home/compil/MiniC
plugins: cov-2.12.1
collecting ... collected 476 items
run-last-failure: no previously failed tests, not deselecting items.

test_codegen.py::TestCodeGen::test_expect[./TP04/tests/provided/step1/test00.c] PASSED [  0%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/provided/step1/test00b.c] PASSED [  0%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/provided/step1/test00d.c] PASSED [  0%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/provided/step1/test01.c] PASSED [  0%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/provided/step1/test_print.c] PASSED [  1%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/provided/step1/test_var.c] PASSED [  1%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/provided/step1/test_var_plus.c] PASSED [  1%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/provided/step1/test_vars.c] PASSED [  1%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/provided/step2/test02.c] PASSED [  1%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/provided/step2/test04.c] PASSED [  2%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/provided/step2/test05.c] PASSED [  2%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/provided/step2/test06.c] PASSED [  2%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/provided/step2/test07.c] PASSED [  2%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/provided/step2/test_bool.c] PASSED [  2%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/provided/step2/test_compare_1_1.c] PASSED [  3%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/provided/step2/test_if2.c] PASSED [  3%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/provided/step2/test_while1.c] PASSED [  3%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/provided/test_while2b.c] PASSED [  3%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/provided/unsupported/float.c] SKIPPED [  3%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/provided/unsupported/print_float.c] SKIPPED [  4%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/provided/unsupported/print_string.c] SKIPPED [  4%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/provided/unsupported/string.c] SKIPPED [  4%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/additive/test_additive_1.c] PASSED [  4%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/additive/test_additive_2.c] PASSED [  5%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/additive/test_additive_3.c] PASSED [  5%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/additive/test_additive_4.c] PASSED [  5%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/additive/test_additive_5.c] PASSED [  5%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/additive/test_additive_6.c] SKIPPED [  5%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/additive/test_additive_7.c] PASSED [  6%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/and/test_and_1.c] PASSED [  6%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/and/test_and_2.c] PASSED [  6%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/and/test_and_3.c] PASSED [  6%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/and/test_and_4.c] SKIPPED [  6%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/declaration/test_declaration_1.c] PASSED [  7%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/declaration/test_declaration_already_declared_1.c] SKIPPED [  7%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/declaration/test_declaration_already_declared_2.c] SKIPPED [  7%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/declaration/test_declaration_typing_error_1.c] SKIPPED [  7%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/declaration/test_declaration_typing_error_10.c] SKIPPED [  7%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/declaration/test_declaration_typing_error_11.c] SKIPPED [  8%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/declaration/test_declaration_typing_error_12.c] SKIPPED [  8%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/declaration/test_declaration_typing_error_13.c] SKIPPED [  8%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/declaration/test_declaration_typing_error_14.c] SKIPPED [  8%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/declaration/test_declaration_typing_error_15.c] SKIPPED [  9%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/declaration/test_declaration_typing_error_2.c] SKIPPED [  9%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/declaration/test_declaration_typing_error_3.c] SKIPPED [  9%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/declaration/test_declaration_typing_error_4.c] SKIPPED [  9%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/declaration/test_declaration_typing_error_5.c] SKIPPED [  9%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/declaration/test_declaration_typing_error_6.c] SKIPPED [ 10%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/declaration/test_declaration_typing_error_7.c] SKIPPED [ 10%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/declaration/test_declaration_typing_error_8.c] SKIPPED [ 10%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/declaration/test_declaration_typing_error_9.c] SKIPPED [ 10%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/declaration/test_declaration_undefined_1.c] SKIPPED [ 10%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/declaration/test_declaration_undefined_2.c] SKIPPED [ 11%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/function/test_function_1.c] PASSED [ 11%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/function/test_function_10.c] SKIPPED [ 11%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/function/test_function_11.c] SKIPPED [ 11%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/function/test_function_12.c] SKIPPED [ 11%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/function/test_function_13.c] SKIPPED [ 12%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/function/test_function_2.c] SKIPPED [ 12%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/function/test_function_3.c] SKIPPED [ 12%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/function/test_function_4.c] SKIPPED [ 12%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/function/test_function_5.c] SKIPPED [ 13%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/function/test_function_6.c] SKIPPED [ 13%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/function/test_function_7.c] SKIPPED [ 13%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/function/test_function_8.c] SKIPPED [ 13%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/function/test_function_9.c] SKIPPED [ 13%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/if/test_if_1.c] PASSED [ 14%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/if/test_if_10.c] PASSED [ 14%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/if/test_if_2.c] PASSED [ 14%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/if/test_if_3.c] PASSED [ 14%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/if/test_if_4.c] PASSED [ 14%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/if/test_if_5.c] SKIPPED [ 15%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/if/test_if_6.c] SKIPPED [ 15%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/if/test_if_7.c] SKIPPED [ 15%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/if/test_if_8.c] SKIPPED [ 15%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/if/test_if_9.c] PASSED [ 15%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/multiplicative/test_multiplicative_div_1.c] PASSED [ 16%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/multiplicative/test_multiplicative_div_2.c] PASSED [ 16%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/multiplicative/test_multiplicative_div_3.c] PASSED [ 16%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/multiplicative/test_multiplicative_div_zero.c] SKIPPED [ 16%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/multiplicative/test_multiplicative_mod_1.c] PASSED [ 17%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/multiplicative/test_multiplicative_mod_2.c] PASSED [ 17%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/multiplicative/test_multiplicative_mod_3.c] PASSED [ 17%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/multiplicative/test_multiplicative_mod_zero.c] SKIPPED [ 17%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/multiplicative/test_multiplicative_mult_1.c] PASSED [ 17%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/multiplicative/test_multiplicative_mult_2.c] PASSED [ 18%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/multiplicative/test_multiplicative_mult_3.c] PASSED [ 18%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/not/test_not_1.c] PASSED [ 18%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/not/test_not_2.c] PASSED [ 18%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/not/test_not_3.c] PASSED [ 18%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/not/test_not_4.c] PASSED [ 19%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/or/test_or_1.c] PASSED [ 19%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/or/test_or_2.c] PASSED [ 19%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/or/test_or_3.c] PASSED [ 19%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/or/test_or_4.c] SKIPPED [ 19%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/relational/equal/test_equality_float_unsupported_construct.c] SKIPPED [ 20%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/relational/equal/test_equality_int_false.c] PASSED [ 20%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/relational/equal/test_equality_int_true.c] PASSED [ 20%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/relational/equal/test_equality_string_unsupported_construct.c] SKIPPED [ 20%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/relational/equal/test_equality_typing_error_1.c] SKIPPED [ 21%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/relational/equal/test_equality_typing_error_2.c] SKIPPED [ 21%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/relational/equal/test_equality_typing_error_3.c] SKIPPED [ 21%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/relational/greater/test_greater_float_unsupported_construct.c] SKIPPED [ 21%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/relational/greater/test_greater_int_false.c] PASSED [ 21%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/relational/greater/test_greater_int_true.c] PASSED [ 22%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/relational/greater/test_greater_string_unsupported_construct.c] SKIPPED [ 22%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/relational/greater/test_greater_typing_error_1.c] SKIPPED [ 22%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/relational/greater/test_greater_typing_error_2.c] SKIPPED [ 22%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/relational/greater/test_greater_typing_error_3.c] SKIPPED [ 22%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/relational/greater_or_equal/test_greater_or_equal_float_unsupported_construct.c] SKIPPED [ 23%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/relational/greater_or_equal/test_greater_or_equal_int_false.c] PASSED [ 23%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/relational/greater_or_equal/test_greater_or_equal_int_true.c] PASSED [ 23%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/relational/greater_or_equal/test_greater_or_equal_int_true_2.c] PASSED [ 23%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/relational/greater_or_equal/test_greater_or_equal_string_unsupported_construct.c] SKIPPED [ 23%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/relational/greater_or_equal/test_greater_or_equal_typing_error_1.c] SKIPPED [ 24%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/relational/greater_or_equal/test_greater_or_equal_typing_error_2.c] SKIPPED [ 24%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/relational/greater_or_equal/test_greater_or_equal_typing_error_3.c] SKIPPED [ 24%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/relational/lesser/test_lesser_float_unsupported_construct.c] SKIPPED [ 24%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/relational/lesser/test_lesser_int_false.c] PASSED [ 25%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/relational/lesser/test_lesser_int_true.c] PASSED [ 25%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/relational/lesser/test_lesser_string_unsupported_construct.c] SKIPPED [ 25%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/relational/lesser/test_lesser_typing_error_1.c] SKIPPED [ 25%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/relational/lesser/test_lesser_typing_error_2.c] SKIPPED [ 25%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/relational/lesser/test_lesser_typing_error_3.c] SKIPPED [ 26%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/relational/lesser_or_equal/lesser_or_equal_float_unsupported_construct.c] SKIPPED [ 26%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/relational/lesser_or_equal/lesser_or_equal_int_false.c] PASSED [ 26%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/relational/lesser_or_equal/lesser_or_equal_int_true.c] PASSED [ 26%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/relational/lesser_or_equal/lesser_or_equal_int_true_2.c] PASSED [ 26%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/relational/lesser_or_equal/lesser_or_equal_string_unsupported_construct.c] SKIPPED [ 27%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/relational/lesser_or_equal/lesser_or_equal_typing_error_1.c] SKIPPED [ 27%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/relational/lesser_or_equal/lesser_or_equal_typing_error_2.c] SKIPPED [ 27%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/relational/lesser_or_equal/lesser_or_equal_typing_error_3.c] SKIPPED [ 27%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/relational/not_equal/test_inequality_float_unsupported_construct.c] SKIPPED [ 27%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/relational/not_equal/test_inequality_int_false.c] PASSED [ 28%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/relational/not_equal/test_inequality_int_true.c] PASSED [ 28%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/relational/not_equal/test_inequality_string_unsupported_construct.c] SKIPPED [ 28%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/relational/not_equal/test_inequality_typing_error_1.c] SKIPPED [ 28%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/relational/not_equal/test_inequality_typing_error_2.c] SKIPPED [ 28%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/relational/not_equal/test_inequality_typing_error_3.c] SKIPPED [ 29%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/test_too_many_registers.c] PASSED [ 29%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/unary_minus/test_unary_minus_1.c] PASSED [ 29%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/unary_minus/test_unary_minus_2.c] PASSED [ 29%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/unary_minus/test_unary_minus_3.c] PASSED [ 30%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/unary_minus/test_unary_minus_4.c] PASSED [ 30%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/while/test_while_1.c] PASSED [ 30%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/while/test_while_2.c] PASSED [ 30%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/while/test_while_3.c] PASSED [ 30%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/while/test_while_4.c] SKIPPED [ 31%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/while/test_while_5.c] SKIPPED [ 31%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/while/test_while_6.c] SKIPPED [ 31%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/while/test_while_7.c] PASSED [ 31%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/while/test_while_8.c] PASSED [ 31%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/provided/step1/test00.c] PASSED [ 32%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/provided/step1/test00b.c] PASSED [ 32%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/provided/step1/test00d.c] PASSED [ 32%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/provided/step1/test01.c] PASSED [ 32%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/provided/step1/test_print.c] PASSED [ 32%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/provided/step1/test_var.c] PASSED [ 33%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/provided/step1/test_var_plus.c] PASSED [ 33%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/provided/step1/test_vars.c] PASSED [ 33%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/provided/step2/test02.c] PASSED [ 33%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/provided/step2/test04.c] PASSED [ 34%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/provided/step2/test05.c] PASSED [ 34%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/provided/step2/test06.c] PASSED [ 34%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/provided/step2/test07.c] PASSED [ 34%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/provided/step2/test_bool.c] PASSED [ 34%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/provided/step2/test_compare_1_1.c] PASSED [ 35%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/provided/step2/test_if2.c] PASSED [ 35%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/provided/step2/test_while1.c] PASSED [ 35%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/provided/test_while2b.c] PASSED [ 35%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/provided/unsupported/float.c] PASSED [ 35%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/provided/unsupported/print_float.c] PASSED [ 36%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/provided/unsupported/print_string.c] PASSED [ 36%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/provided/unsupported/string.c] PASSED [ 36%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/additive/test_additive_1.c] PASSED [ 36%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/additive/test_additive_2.c] PASSED [ 36%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/additive/test_additive_3.c] PASSED [ 37%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/additive/test_additive_4.c] PASSED [ 37%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/additive/test_additive_5.c] PASSED [ 37%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/additive/test_additive_6.c] PASSED [ 37%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/additive/test_additive_7.c] PASSED [ 38%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/and/test_and_1.c] PASSED [ 38%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/and/test_and_2.c] PASSED [ 38%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/and/test_and_3.c] PASSED [ 38%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/and/test_and_4.c] PASSED [ 38%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/declaration/test_declaration_1.c] PASSED [ 39%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/declaration/test_declaration_already_declared_1.c] PASSED [ 39%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/declaration/test_declaration_already_declared_2.c] PASSED [ 39%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/declaration/test_declaration_typing_error_1.c] PASSED [ 39%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/declaration/test_declaration_typing_error_10.c] PASSED [ 39%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/declaration/test_declaration_typing_error_11.c] PASSED [ 40%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/declaration/test_declaration_typing_error_12.c] PASSED [ 40%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/declaration/test_declaration_typing_error_13.c] PASSED [ 40%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/declaration/test_declaration_typing_error_14.c] PASSED [ 40%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/declaration/test_declaration_typing_error_15.c] PASSED [ 40%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/declaration/test_declaration_typing_error_2.c] PASSED [ 41%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/declaration/test_declaration_typing_error_3.c] PASSED [ 41%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/declaration/test_declaration_typing_error_4.c] PASSED [ 41%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/declaration/test_declaration_typing_error_5.c] PASSED [ 41%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/declaration/test_declaration_typing_error_6.c] PASSED [ 42%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/declaration/test_declaration_typing_error_7.c] PASSED [ 42%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/declaration/test_declaration_typing_error_8.c] PASSED [ 42%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/declaration/test_declaration_typing_error_9.c] PASSED [ 42%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/declaration/test_declaration_undefined_1.c] PASSED [ 42%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/declaration/test_declaration_undefined_2.c] PASSED [ 43%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/function/test_function_1.c] PASSED [ 43%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/function/test_function_10.c] PASSED [ 43%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/function/test_function_11.c] PASSED [ 43%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/function/test_function_12.c] PASSED [ 43%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/function/test_function_13.c] PASSED [ 44%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/function/test_function_2.c] PASSED [ 44%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/function/test_function_3.c] PASSED [ 44%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/function/test_function_4.c] PASSED [ 44%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/function/test_function_5.c] PASSED [ 44%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/function/test_function_6.c] PASSED [ 45%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/function/test_function_7.c] PASSED [ 45%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/function/test_function_8.c] PASSED [ 45%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/function/test_function_9.c] PASSED [ 45%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/if/test_if_1.c] PASSED [ 46%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/if/test_if_10.c] PASSED [ 46%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/if/test_if_2.c] PASSED [ 46%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/if/test_if_3.c] PASSED [ 46%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/if/test_if_4.c] PASSED [ 46%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/if/test_if_5.c] PASSED [ 47%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/if/test_if_6.c] PASSED [ 47%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/if/test_if_7.c] PASSED [ 47%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/if/test_if_8.c] PASSED [ 47%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/if/test_if_9.c] PASSED [ 47%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/multiplicative/test_multiplicative_div_1.c] PASSED [ 48%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/multiplicative/test_multiplicative_div_2.c] PASSED [ 48%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/multiplicative/test_multiplicative_div_3.c] PASSED [ 48%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/multiplicative/test_multiplicative_div_zero.c] PASSED [ 48%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/multiplicative/test_multiplicative_mod_1.c] PASSED [ 48%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/multiplicative/test_multiplicative_mod_2.c] PASSED [ 49%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/multiplicative/test_multiplicative_mod_3.c] PASSED [ 49%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/multiplicative/test_multiplicative_mod_zero.c] PASSED [ 49%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/multiplicative/test_multiplicative_mult_1.c] PASSED [ 49%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/multiplicative/test_multiplicative_mult_2.c] PASSED [ 50%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/multiplicative/test_multiplicative_mult_3.c] PASSED [ 50%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/not/test_not_1.c] PASSED [ 50%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/not/test_not_2.c] PASSED [ 50%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/not/test_not_3.c] PASSED [ 50%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/not/test_not_4.c] PASSED [ 51%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/or/test_or_1.c] PASSED [ 51%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/or/test_or_2.c] PASSED [ 51%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/or/test_or_3.c] PASSED [ 51%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/or/test_or_4.c] PASSED [ 51%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/relational/equal/test_equality_float_unsupported_construct.c] PASSED [ 52%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/relational/equal/test_equality_int_false.c] PASSED [ 52%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/relational/equal/test_equality_int_true.c] PASSED [ 52%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/relational/equal/test_equality_string_unsupported_construct.c] PASSED [ 52%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/relational/equal/test_equality_typing_error_1.c] PASSED [ 52%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/relational/equal/test_equality_typing_error_2.c] PASSED [ 53%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/relational/equal/test_equality_typing_error_3.c] PASSED [ 53%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/relational/greater/test_greater_float_unsupported_construct.c] PASSED [ 53%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/relational/greater/test_greater_int_false.c] PASSED [ 53%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/relational/greater/test_greater_int_true.c] PASSED [ 53%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/relational/greater/test_greater_string_unsupported_construct.c] PASSED [ 54%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/relational/greater/test_greater_typing_error_1.c] PASSED [ 54%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/relational/greater/test_greater_typing_error_2.c] PASSED [ 54%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/relational/greater/test_greater_typing_error_3.c] PASSED [ 54%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/relational/greater_or_equal/test_greater_or_equal_float_unsupported_construct.c] PASSED [ 55%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/relational/greater_or_equal/test_greater_or_equal_int_false.c] PASSED [ 55%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/relational/greater_or_equal/test_greater_or_equal_int_true.c] PASSED [ 55%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/relational/greater_or_equal/test_greater_or_equal_int_true_2.c] PASSED [ 55%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/relational/greater_or_equal/test_greater_or_equal_string_unsupported_construct.c] PASSED [ 55%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/relational/greater_or_equal/test_greater_or_equal_typing_error_1.c] PASSED [ 56%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/relational/greater_or_equal/test_greater_or_equal_typing_error_2.c] PASSED [ 56%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/relational/greater_or_equal/test_greater_or_equal_typing_error_3.c] PASSED [ 56%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/relational/lesser/test_lesser_float_unsupported_construct.c] PASSED [ 56%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/relational/lesser/test_lesser_int_false.c] PASSED [ 56%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/relational/lesser/test_lesser_int_true.c] PASSED [ 57%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/relational/lesser/test_lesser_string_unsupported_construct.c] PASSED [ 57%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/relational/lesser/test_lesser_typing_error_1.c] PASSED [ 57%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/relational/lesser/test_lesser_typing_error_2.c] PASSED [ 57%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/relational/lesser/test_lesser_typing_error_3.c] PASSED [ 57%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/relational/lesser_or_equal/lesser_or_equal_float_unsupported_construct.c] PASSED [ 58%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/relational/lesser_or_equal/lesser_or_equal_int_false.c] PASSED [ 58%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/relational/lesser_or_equal/lesser_or_equal_int_true.c] PASSED [ 58%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/relational/lesser_or_equal/lesser_or_equal_int_true_2.c] PASSED [ 58%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/relational/lesser_or_equal/lesser_or_equal_string_unsupported_construct.c] PASSED [ 59%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/relational/lesser_or_equal/lesser_or_equal_typing_error_1.c] PASSED [ 59%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/relational/lesser_or_equal/lesser_or_equal_typing_error_2.c] PASSED [ 59%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/relational/lesser_or_equal/lesser_or_equal_typing_error_3.c] PASSED [ 59%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/relational/not_equal/test_inequality_float_unsupported_construct.c] PASSED [ 59%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/relational/not_equal/test_inequality_int_false.c] PASSED [ 60%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/relational/not_equal/test_inequality_int_true.c] PASSED [ 60%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/relational/not_equal/test_inequality_string_unsupported_construct.c] PASSED [ 60%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/relational/not_equal/test_inequality_typing_error_1.c] PASSED [ 60%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/relational/not_equal/test_inequality_typing_error_2.c] PASSED [ 60%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/relational/not_equal/test_inequality_typing_error_3.c] PASSED [ 61%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/test_too_many_registers.c] SKIPPED [ 61%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/unary_minus/test_unary_minus_1.c] PASSED [ 61%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/unary_minus/test_unary_minus_2.c] PASSED [ 61%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/unary_minus/test_unary_minus_3.c] PASSED [ 61%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/unary_minus/test_unary_minus_4.c] PASSED [ 62%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/while/test_while_1.c] PASSED [ 62%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/while/test_while_2.c] PASSED [ 62%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/while/test_while_3.c] PASSED [ 62%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/while/test_while_4.c] PASSED [ 63%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/while/test_while_5.c] PASSED [ 63%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/while/test_while_6.c] PASSED [ 63%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/while/test_while_7.c] PASSED [ 63%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/while/test_while_8.c] PASSED [ 63%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/provided/step1/test00.c] PASSED [ 64%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/provided/step1/test00b.c] PASSED [ 64%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/provided/step1/test00d.c] PASSED [ 64%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/provided/step1/test01.c] PASSED [ 64%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/provided/step1/test_print.c] PASSED [ 64%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/provided/step1/test_var.c] PASSED [ 65%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/provided/step1/test_var_plus.c] PASSED [ 65%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/provided/step1/test_vars.c] PASSED [ 65%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/provided/step2/test02.c] FAILED [ 65%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/provided/step2/test04.c] FAILED [ 65%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/provided/step2/test05.c] FAILED [ 66%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/provided/step2/test06.c] FAILED [ 66%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/provided/step2/test07.c] FAILED [ 66%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/provided/step2/test_bool.c] PASSED [ 66%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/provided/step2/test_compare_1_1.c] FAILED [ 67%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/provided/step2/test_if2.c] FAILED [ 67%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/provided/step2/test_while1.c] FAILED [ 67%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/provided/test_while2b.c] FAILED [ 67%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/provided/unsupported/float.c] PASSED [ 67%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/provided/unsupported/print_float.c] PASSED [ 68%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/provided/unsupported/print_string.c] PASSED [ 68%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/provided/unsupported/string.c] PASSED [ 68%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/additive/test_additive_1.c] PASSED [ 68%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/additive/test_additive_2.c] PASSED [ 68%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/additive/test_additive_3.c] PASSED [ 69%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/additive/test_additive_4.c] PASSED [ 69%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/additive/test_additive_5.c] PASSED [ 69%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/additive/test_additive_6.c] PASSED [ 69%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/additive/test_additive_7.c] PASSED [ 69%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/and/test_and_1.c] FAILED [ 70%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/and/test_and_2.c] FAILED [ 70%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/and/test_and_3.c] FAILED [ 70%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/and/test_and_4.c] PASSED [ 70%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/declaration/test_declaration_1.c] PASSED [ 71%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/declaration/test_declaration_already_declared_1.c] PASSED [ 71%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/declaration/test_declaration_already_declared_2.c] PASSED [ 71%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/declaration/test_declaration_typing_error_1.c] PASSED [ 71%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/declaration/test_declaration_typing_error_10.c] PASSED [ 71%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/declaration/test_declaration_typing_error_11.c] PASSED [ 72%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/declaration/test_declaration_typing_error_12.c] PASSED [ 72%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/declaration/test_declaration_typing_error_13.c] PASSED [ 72%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/declaration/test_declaration_typing_error_14.c] PASSED [ 72%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/declaration/test_declaration_typing_error_15.c] PASSED [ 72%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/declaration/test_declaration_typing_error_2.c] PASSED [ 73%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/declaration/test_declaration_typing_error_3.c] PASSED [ 73%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/declaration/test_declaration_typing_error_4.c] PASSED [ 73%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/declaration/test_declaration_typing_error_5.c] PASSED [ 73%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/declaration/test_declaration_typing_error_6.c] PASSED [ 73%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/declaration/test_declaration_typing_error_7.c] PASSED [ 74%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/declaration/test_declaration_typing_error_8.c] PASSED [ 74%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/declaration/test_declaration_typing_error_9.c] PASSED [ 74%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/declaration/test_declaration_undefined_1.c] PASSED [ 74%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/declaration/test_declaration_undefined_2.c] PASSED [ 75%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/function/test_function_1.c] PASSED [ 75%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/function/test_function_10.c] PASSED [ 75%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/function/test_function_11.c] PASSED [ 75%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/function/test_function_12.c] PASSED [ 75%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/function/test_function_13.c] PASSED [ 76%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/function/test_function_2.c] PASSED [ 76%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/function/test_function_3.c] PASSED [ 76%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/function/test_function_4.c] PASSED [ 76%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/function/test_function_5.c] PASSED [ 76%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/function/test_function_6.c] PASSED [ 77%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/function/test_function_7.c] PASSED [ 77%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/function/test_function_8.c] PASSED [ 77%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/function/test_function_9.c] PASSED [ 77%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/if/test_if_1.c] FAILED [ 77%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/if/test_if_10.c] FAILED [ 78%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/if/test_if_2.c] FAILED [ 78%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/if/test_if_3.c] FAILED [ 78%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/if/test_if_4.c] FAILED [ 78%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/if/test_if_5.c] PASSED [ 78%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/if/test_if_6.c] PASSED [ 79%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/if/test_if_7.c] PASSED [ 79%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/if/test_if_8.c] PASSED [ 79%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/if/test_if_9.c] FAILED [ 79%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/multiplicative/test_multiplicative_div_1.c] FAILED [ 80%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/multiplicative/test_multiplicative_div_2.c] FAILED [ 80%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/multiplicative/test_multiplicative_div_3.c] FAILED [ 80%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/multiplicative/test_multiplicative_div_zero.c] FAILED [ 80%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/multiplicative/test_multiplicative_mod_1.c] FAILED [ 80%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/multiplicative/test_multiplicative_mod_2.c] FAILED [ 81%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/multiplicative/test_multiplicative_mod_3.c] FAILED [ 81%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/multiplicative/test_multiplicative_mod_zero.c] FAILED [ 81%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/multiplicative/test_multiplicative_mult_1.c] PASSED [ 81%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/multiplicative/test_multiplicative_mult_2.c] PASSED [ 81%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/multiplicative/test_multiplicative_mult_3.c] PASSED [ 82%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/not/test_not_1.c] FAILED [ 82%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/not/test_not_2.c] FAILED [ 82%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/not/test_not_3.c] FAILED [ 82%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/not/test_not_4.c] FAILED [ 82%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/or/test_or_1.c] FAILED [ 83%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/or/test_or_2.c] FAILED [ 83%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/or/test_or_3.c] FAILED [ 83%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/or/test_or_4.c] PASSED [ 83%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/relational/equal/test_equality_float_unsupported_construct.c] PASSED [ 84%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/relational/equal/test_equality_int_false.c] FAILED [ 84%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/relational/equal/test_equality_int_true.c] FAILED [ 84%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/relational/equal/test_equality_string_unsupported_construct.c] PASSED [ 84%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/relational/equal/test_equality_typing_error_1.c] PASSED [ 84%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/relational/equal/test_equality_typing_error_2.c] PASSED [ 85%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/relational/equal/test_equality_typing_error_3.c] PASSED [ 85%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/relational/greater/test_greater_float_unsupported_construct.c] PASSED [ 85%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/relational/greater/test_greater_int_false.c] FAILED [ 85%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/relational/greater/test_greater_int_true.c] FAILED [ 85%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/relational/greater/test_greater_string_unsupported_construct.c] PASSED [ 86%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/relational/greater/test_greater_typing_error_1.c] PASSED [ 86%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/relational/greater/test_greater_typing_error_2.c] PASSED [ 86%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/relational/greater/test_greater_typing_error_3.c] PASSED [ 86%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/relational/greater_or_equal/test_greater_or_equal_float_unsupported_construct.c] PASSED [ 86%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/relational/greater_or_equal/test_greater_or_equal_int_false.c] FAILED [ 87%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/relational/greater_or_equal/test_greater_or_equal_int_true.c] FAILED [ 87%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/relational/greater_or_equal/test_greater_or_equal_int_true_2.c] FAILED [ 87%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/relational/greater_or_equal/test_greater_or_equal_string_unsupported_construct.c] PASSED [ 87%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/relational/greater_or_equal/test_greater_or_equal_typing_error_1.c] PASSED [ 88%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/relational/greater_or_equal/test_greater_or_equal_typing_error_2.c] PASSED [ 88%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/relational/greater_or_equal/test_greater_or_equal_typing_error_3.c] PASSED [ 88%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/relational/lesser/test_lesser_float_unsupported_construct.c] PASSED [ 88%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/relational/lesser/test_lesser_int_false.c] FAILED [ 88%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/relational/lesser/test_lesser_int_true.c] FAILED [ 89%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/relational/lesser/test_lesser_string_unsupported_construct.c] PASSED [ 89%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/relational/lesser/test_lesser_typing_error_1.c] PASSED [ 89%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/relational/lesser/test_lesser_typing_error_2.c] PASSED [ 89%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/relational/lesser/test_lesser_typing_error_3.c] PASSED [ 89%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/relational/lesser_or_equal/lesser_or_equal_float_unsupported_construct.c] PASSED [ 90%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/relational/lesser_or_equal/lesser_or_equal_int_false.c] FAILED [ 90%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/relational/lesser_or_equal/lesser_or_equal_int_true.c] FAILED [ 90%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/relational/lesser_or_equal/lesser_or_equal_int_true_2.c] FAILED [ 90%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/relational/lesser_or_equal/lesser_or_equal_string_unsupported_construct.c] PASSED [ 90%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/relational/lesser_or_equal/lesser_or_equal_typing_error_1.c] PASSED [ 91%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/relational/lesser_or_equal/lesser_or_equal_typing_error_2.c] PASSED [ 91%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/relational/lesser_or_equal/lesser_or_equal_typing_error_3.c] PASSED [ 91%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/relational/not_equal/test_inequality_float_unsupported_construct.c] PASSED [ 91%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/relational/not_equal/test_inequality_int_false.c] FAILED [ 92%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/relational/not_equal/test_inequality_int_true.c] FAILED [ 92%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/relational/not_equal/test_inequality_string_unsupported_construct.c] PASSED [ 92%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/relational/not_equal/test_inequality_typing_error_1.c] PASSED [ 92%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/relational/not_equal/test_inequality_typing_error_2.c] PASSED [ 92%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/relational/not_equal/test_inequality_typing_error_3.c] PASSED [ 93%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/test_too_many_registers.c] SKIPPED [ 93%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/unary_minus/test_unary_minus_1.c] PASSED [ 93%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/unary_minus/test_unary_minus_2.c] PASSED [ 93%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/unary_minus/test_unary_minus_3.c] PASSED [ 93%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/unary_minus/test_unary_minus_4.c] PASSED [ 94%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/while/test_while_1.c] FAILED [ 94%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/while/test_while_2.c] FAILED [ 94%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/while/test_while_3.c] FAILED [ 94%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/while/test_while_4.c] PASSED [ 94%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/while/test_while_5.c] PASSED [ 95%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/while/test_while_6.c] PASSED [ 95%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/while/test_while_7.c] FAILED [ 95%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/while/test_while_8.c] FAILED [ 95%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP05/tests/provided/dataflow/df00.c] PASSED [ 96%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP05/tests/provided/dataflow/df01.c] PASSED [ 96%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP05/tests/provided/dataflow/df02.c] FAILED [ 96%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP05/tests/provided/dataflow/df03.c] FAILED [ 96%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP05/tests/provided/dataflow/df04.c] FAILED [ 96%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP05/tests/provided/dataflow/df05.c] FAILED [ 97%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP05/tests/students/dataflow/df01.c] FAILED [ 97%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP05/tests/students/dataflow/df02.c] FAILED [ 97%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP05/tests/students/dataflow/df03.c] FAILED [ 97%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP05/tests/students/dataflow/df04.c] FAILED [ 97%]
test_codegen.py::TestCodeGen::test_smart_alloc[./TP05/tests/provided/dataflow/df00.c] PASSED [ 98%]
test_codegen.py::TestCodeGen::test_smart_alloc[./TP05/tests/provided/dataflow/df01.c] PASSED [ 98%]
test_codegen.py::TestCodeGen::test_smart_alloc[./TP05/tests/provided/dataflow/df02.c] PASSED [ 98%]
test_codegen.py::TestCodeGen::test_smart_alloc[./TP05/tests/provided/dataflow/df03.c] PASSED [ 98%]
test_codegen.py::TestCodeGen::test_smart_alloc[./TP05/tests/provided/dataflow/df04.c] PASSED [ 98%]
test_codegen.py::TestCodeGen::test_smart_alloc[./TP05/tests/provided/dataflow/df05.c] PASSED [ 99%]
test_codegen.py::TestCodeGen::test_smart_alloc[./TP05/tests/students/dataflow/df01.c] FAILED [ 99%]
test_codegen.py::TestCodeGen::test_smart_alloc[./TP05/tests/students/dataflow/df02.c] FAILED [ 99%]
test_codegen.py::TestCodeGen::test_smart_alloc[./TP05/tests/students/dataflow/df03.c] FAILED [ 99%]
test_codegen.py::TestCodeGen::test_smart_alloc[./TP05/tests/students/dataflow/df04.c] FAILED [100%]

=================================== FAILURES ===================================
_______ TestCodeGen.test_alloc_mem[./TP04/tests/provided/step2/test02.c] _______

self = <test_codegen.TestCodeGen object at 0x7f142b24f850>
filename = './TP04/tests/provided/step2/test02.c'

    @pytest.mark.parametrize('filename', ALL_IN_MEM_FILES)
    def test_alloc_mem(self, filename):
        expect = self.get_expect(filename)
        actual = self.all_in_mem(filename, expect)
>       self.assert_equal(actual, expect)

test_codegen.py:247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_codegen.TestCodeGen object at 0x7f142b24f850>
actual = testinfo(exitcode=1, execcode=0, output='Traceback (most recent call last):\n  File "./MiniCC.py", line 218, in <modul...y", line 327, in linearize\n    assert(len(block._out) == 1)\nAssertionError\n', linkargs=[], skip_test_expected=False)
expected = testinfo(exitcode=0, execcode=0, output='', linkargs=[], skip_test_expected=False)

    def assert_equal(self, actual, expected):
        if TYPECHECK_ONLY and expected.exitcode == 0:
            # Compiler does not fail => no output expected
            assert actual.output == "", \
                "Compiler unexpectedly generated some output with --disable-codegen"
            assert actual.exitcode == 0, \
                "Compiler unexpectedly failed with --disable-codegen"
            return
        if DISABLE_TYPECHECK and expected.exitcode != 0:
            # Test should fail at typecheck, and we don't do
            # typechecking => nothing to check.
            pytest.skip("Test that doesn't typecheck with --disable-typecheck")
        if expected.output is not None and actual.output is not None:
>           assert actual.output == expected.output, \
                "Output of the program is incorrect."
E           AssertionError: Output of the program is incorrect.
E           assert ('Traceback (most recent call last):\n'\n '  File "./MiniCC.py", line 218, in <module>\n'\n '    main(args.filename, args.reg_alloc, args.ssa,\n'\n '  File "./MiniCC.py", line 168, in main\n'\n '    cfg.print_code(output, comment=comment)\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code\n'\n '    for i in self.linearize():\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize\n'\n '    assert(len(block._out) == 1)\n'\n 'AssertionError\n') == ''
E             + Traceback (most recent call last):
E             +   File "./MiniCC.py", line 218, in <module>
E             +     main(args.filename, args.reg_alloc, args.ssa,
E             +   File "./MiniCC.py", line 168, in main
E             +     cfg.print_code(output, comment=comment)
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
E             +     for i in self.linearize():
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
E             +     assert(len(block._out) == 1)
E             + AssertionError

test_codegen.py:91: AssertionError
----------------------------- Captured stdout call -----------------------------
Compiling ...
/usr/bin/python3 ./MiniCC.py --reg-alloc=all_in_mem --output=./TP04/tests/provided/step2/test02-all_in_mem.s ./TP04/tests/provided/step2/test02.c
Exited with status: 1
Traceback (most recent call last):
  File "./MiniCC.py", line 218, in <module>
    main(args.filename, args.reg_alloc, args.ssa,
  File "./MiniCC.py", line 168, in main
    cfg.print_code(output, comment=comment)
  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
    for i in self.linearize():
  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
    assert(len(block._out) == 1)
AssertionError

_______ TestCodeGen.test_alloc_mem[./TP04/tests/provided/step2/test04.c] _______

self = <test_codegen.TestCodeGen object at 0x7f142b1eb460>
filename = './TP04/tests/provided/step2/test04.c'

    @pytest.mark.parametrize('filename', ALL_IN_MEM_FILES)
    def test_alloc_mem(self, filename):
        expect = self.get_expect(filename)
        actual = self.all_in_mem(filename, expect)
>       self.assert_equal(actual, expect)

test_codegen.py:247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_codegen.TestCodeGen object at 0x7f142b1eb460>
actual = testinfo(exitcode=1, execcode=0, output='Traceback (most recent call last):\n  File "./MiniCC.py", line 218, in <modul...y", line 327, in linearize\n    assert(len(block._out) == 1)\nAssertionError\n', linkargs=[], skip_test_expected=False)
expected = testinfo(exitcode=0, execcode=0, output='', linkargs=[], skip_test_expected=False)

    def assert_equal(self, actual, expected):
        if TYPECHECK_ONLY and expected.exitcode == 0:
            # Compiler does not fail => no output expected
            assert actual.output == "", \
                "Compiler unexpectedly generated some output with --disable-codegen"
            assert actual.exitcode == 0, \
                "Compiler unexpectedly failed with --disable-codegen"
            return
        if DISABLE_TYPECHECK and expected.exitcode != 0:
            # Test should fail at typecheck, and we don't do
            # typechecking => nothing to check.
            pytest.skip("Test that doesn't typecheck with --disable-typecheck")
        if expected.output is not None and actual.output is not None:
>           assert actual.output == expected.output, \
                "Output of the program is incorrect."
E           AssertionError: Output of the program is incorrect.
E           assert ('Traceback (most recent call last):\n'\n '  File "./MiniCC.py", line 218, in <module>\n'\n '    main(args.filename, args.reg_alloc, args.ssa,\n'\n '  File "./MiniCC.py", line 168, in main\n'\n '    cfg.print_code(output, comment=comment)\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code\n'\n '    for i in self.linearize():\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize\n'\n '    assert(len(block._out) == 1)\n'\n 'AssertionError\n') == ''
E             + Traceback (most recent call last):
E             +   File "./MiniCC.py", line 218, in <module>
E             +     main(args.filename, args.reg_alloc, args.ssa,
E             +   File "./MiniCC.py", line 168, in main
E             +     cfg.print_code(output, comment=comment)
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
E             +     for i in self.linearize():
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
E             +     assert(len(block._out) == 1)
E             + AssertionError

test_codegen.py:91: AssertionError
----------------------------- Captured stdout call -----------------------------
Compiling ...
/usr/bin/python3 ./MiniCC.py --reg-alloc=all_in_mem --output=./TP04/tests/provided/step2/test04-all_in_mem.s ./TP04/tests/provided/step2/test04.c
Exited with status: 1
Traceback (most recent call last):
  File "./MiniCC.py", line 218, in <module>
    main(args.filename, args.reg_alloc, args.ssa,
  File "./MiniCC.py", line 168, in main
    cfg.print_code(output, comment=comment)
  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
    for i in self.linearize():
  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
    assert(len(block._out) == 1)
AssertionError

_______ TestCodeGen.test_alloc_mem[./TP04/tests/provided/step2/test05.c] _______

self = <test_codegen.TestCodeGen object at 0x7f142b1662e0>
filename = './TP04/tests/provided/step2/test05.c'

    @pytest.mark.parametrize('filename', ALL_IN_MEM_FILES)
    def test_alloc_mem(self, filename):
        expect = self.get_expect(filename)
        actual = self.all_in_mem(filename, expect)
>       self.assert_equal(actual, expect)

test_codegen.py:247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_codegen.TestCodeGen object at 0x7f142b1662e0>
actual = testinfo(exitcode=1, execcode=0, output='Traceback (most recent call last):\n  File "./MiniCC.py", line 218, in <modul...y", line 327, in linearize\n    assert(len(block._out) == 1)\nAssertionError\n', linkargs=[], skip_test_expected=False)
expected = testinfo(exitcode=0, execcode=0, output='', linkargs=[], skip_test_expected=False)

    def assert_equal(self, actual, expected):
        if TYPECHECK_ONLY and expected.exitcode == 0:
            # Compiler does not fail => no output expected
            assert actual.output == "", \
                "Compiler unexpectedly generated some output with --disable-codegen"
            assert actual.exitcode == 0, \
                "Compiler unexpectedly failed with --disable-codegen"
            return
        if DISABLE_TYPECHECK and expected.exitcode != 0:
            # Test should fail at typecheck, and we don't do
            # typechecking => nothing to check.
            pytest.skip("Test that doesn't typecheck with --disable-typecheck")
        if expected.output is not None and actual.output is not None:
>           assert actual.output == expected.output, \
                "Output of the program is incorrect."
E           AssertionError: Output of the program is incorrect.
E           assert ('Traceback (most recent call last):\n'\n '  File "./MiniCC.py", line 218, in <module>\n'\n '    main(args.filename, args.reg_alloc, args.ssa,\n'\n '  File "./MiniCC.py", line 168, in main\n'\n '    cfg.print_code(output, comment=comment)\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code\n'\n '    for i in self.linearize():\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize\n'\n '    assert(len(block._out) == 1)\n'\n 'AssertionError\n') == ''
E             + Traceback (most recent call last):
E             +   File "./MiniCC.py", line 218, in <module>
E             +     main(args.filename, args.reg_alloc, args.ssa,
E             +   File "./MiniCC.py", line 168, in main
E             +     cfg.print_code(output, comment=comment)
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
E             +     for i in self.linearize():
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
E             +     assert(len(block._out) == 1)
E             + AssertionError

test_codegen.py:91: AssertionError
----------------------------- Captured stdout call -----------------------------
Compiling ...
/usr/bin/python3 ./MiniCC.py --reg-alloc=all_in_mem --output=./TP04/tests/provided/step2/test05-all_in_mem.s ./TP04/tests/provided/step2/test05.c
Exited with status: 1
Traceback (most recent call last):
  File "./MiniCC.py", line 218, in <module>
    main(args.filename, args.reg_alloc, args.ssa,
  File "./MiniCC.py", line 168, in main
    cfg.print_code(output, comment=comment)
  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
    for i in self.linearize():
  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
    assert(len(block._out) == 1)
AssertionError

_______ TestCodeGen.test_alloc_mem[./TP04/tests/provided/step2/test06.c] _______

self = <test_codegen.TestCodeGen object at 0x7f142b1ffaf0>
filename = './TP04/tests/provided/step2/test06.c'

    @pytest.mark.parametrize('filename', ALL_IN_MEM_FILES)
    def test_alloc_mem(self, filename):
        expect = self.get_expect(filename)
        actual = self.all_in_mem(filename, expect)
>       self.assert_equal(actual, expect)

test_codegen.py:247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_codegen.TestCodeGen object at 0x7f142b1ffaf0>
actual = testinfo(exitcode=1, execcode=0, output='Traceback (most recent call last):\n  File "./MiniCC.py", line 218, in <modul...y", line 327, in linearize\n    assert(len(block._out) == 1)\nAssertionError\n', linkargs=[], skip_test_expected=False)
expected = testinfo(exitcode=0, execcode=0, output='', linkargs=[], skip_test_expected=False)

    def assert_equal(self, actual, expected):
        if TYPECHECK_ONLY and expected.exitcode == 0:
            # Compiler does not fail => no output expected
            assert actual.output == "", \
                "Compiler unexpectedly generated some output with --disable-codegen"
            assert actual.exitcode == 0, \
                "Compiler unexpectedly failed with --disable-codegen"
            return
        if DISABLE_TYPECHECK and expected.exitcode != 0:
            # Test should fail at typecheck, and we don't do
            # typechecking => nothing to check.
            pytest.skip("Test that doesn't typecheck with --disable-typecheck")
        if expected.output is not None and actual.output is not None:
>           assert actual.output == expected.output, \
                "Output of the program is incorrect."
E           AssertionError: Output of the program is incorrect.
E           assert ('Traceback (most recent call last):\n'\n '  File "./MiniCC.py", line 218, in <module>\n'\n '    main(args.filename, args.reg_alloc, args.ssa,\n'\n '  File "./MiniCC.py", line 168, in main\n'\n '    cfg.print_code(output, comment=comment)\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code\n'\n '    for i in self.linearize():\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize\n'\n '    assert(len(block._out) == 1)\n'\n 'AssertionError\n') == ''
E             + Traceback (most recent call last):
E             +   File "./MiniCC.py", line 218, in <module>
E             +     main(args.filename, args.reg_alloc, args.ssa,
E             +   File "./MiniCC.py", line 168, in main
E             +     cfg.print_code(output, comment=comment)
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
E             +     for i in self.linearize():
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
E             +     assert(len(block._out) == 1)
E             + AssertionError

test_codegen.py:91: AssertionError
----------------------------- Captured stdout call -----------------------------
Compiling ...
/usr/bin/python3 ./MiniCC.py --reg-alloc=all_in_mem --output=./TP04/tests/provided/step2/test06-all_in_mem.s ./TP04/tests/provided/step2/test06.c
Exited with status: 1
Traceback (most recent call last):
  File "./MiniCC.py", line 218, in <module>
    main(args.filename, args.reg_alloc, args.ssa,
  File "./MiniCC.py", line 168, in main
    cfg.print_code(output, comment=comment)
  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
    for i in self.linearize():
  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
    assert(len(block._out) == 1)
AssertionError

_______ TestCodeGen.test_alloc_mem[./TP04/tests/provided/step2/test07.c] _______

self = <test_codegen.TestCodeGen object at 0x7f142b1eb880>
filename = './TP04/tests/provided/step2/test07.c'

    @pytest.mark.parametrize('filename', ALL_IN_MEM_FILES)
    def test_alloc_mem(self, filename):
        expect = self.get_expect(filename)
        actual = self.all_in_mem(filename, expect)
>       self.assert_equal(actual, expect)

test_codegen.py:247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_codegen.TestCodeGen object at 0x7f142b1eb880>
actual = testinfo(exitcode=1, execcode=0, output='Traceback (most recent call last):\n  File "./MiniCC.py", line 218, in <modul...y", line 327, in linearize\n    assert(len(block._out) == 1)\nAssertionError\n', linkargs=[], skip_test_expected=False)
expected = testinfo(exitcode=0, execcode=0, output='', linkargs=[], skip_test_expected=False)

    def assert_equal(self, actual, expected):
        if TYPECHECK_ONLY and expected.exitcode == 0:
            # Compiler does not fail => no output expected
            assert actual.output == "", \
                "Compiler unexpectedly generated some output with --disable-codegen"
            assert actual.exitcode == 0, \
                "Compiler unexpectedly failed with --disable-codegen"
            return
        if DISABLE_TYPECHECK and expected.exitcode != 0:
            # Test should fail at typecheck, and we don't do
            # typechecking => nothing to check.
            pytest.skip("Test that doesn't typecheck with --disable-typecheck")
        if expected.output is not None and actual.output is not None:
>           assert actual.output == expected.output, \
                "Output of the program is incorrect."
E           AssertionError: Output of the program is incorrect.
E           assert ('Traceback (most recent call last):\n'\n '  File "./MiniCC.py", line 218, in <module>\n'\n '    main(args.filename, args.reg_alloc, args.ssa,\n'\n '  File "./MiniCC.py", line 168, in main\n'\n '    cfg.print_code(output, comment=comment)\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code\n'\n '    for i in self.linearize():\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize\n'\n '    assert(len(block._out) == 1)\n'\n 'AssertionError\n') == ''
E             + Traceback (most recent call last):
E             +   File "./MiniCC.py", line 218, in <module>
E             +     main(args.filename, args.reg_alloc, args.ssa,
E             +   File "./MiniCC.py", line 168, in main
E             +     cfg.print_code(output, comment=comment)
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
E             +     for i in self.linearize():
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
E             +     assert(len(block._out) == 1)
E             + AssertionError

test_codegen.py:91: AssertionError
----------------------------- Captured stdout call -----------------------------
Compiling ...
/usr/bin/python3 ./MiniCC.py --reg-alloc=all_in_mem --output=./TP04/tests/provided/step2/test07-all_in_mem.s ./TP04/tests/provided/step2/test07.c
Exited with status: 1
Traceback (most recent call last):
  File "./MiniCC.py", line 218, in <module>
    main(args.filename, args.reg_alloc, args.ssa,
  File "./MiniCC.py", line 168, in main
    cfg.print_code(output, comment=comment)
  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
    for i in self.linearize():
  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
    assert(len(block._out) == 1)
AssertionError

__ TestCodeGen.test_alloc_mem[./TP04/tests/provided/step2/test_compare_1_1.c] __

self = <test_codegen.TestCodeGen object at 0x7f142b166610>
filename = './TP04/tests/provided/step2/test_compare_1_1.c'

    @pytest.mark.parametrize('filename', ALL_IN_MEM_FILES)
    def test_alloc_mem(self, filename):
        expect = self.get_expect(filename)
        actual = self.all_in_mem(filename, expect)
>       self.assert_equal(actual, expect)

test_codegen.py:247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_codegen.TestCodeGen object at 0x7f142b166610>
actual = testinfo(exitcode=1, execcode=0, output='Traceback (most recent call last):\n  File "./MiniCC.py", line 218, in <modul...y", line 327, in linearize\n    assert(len(block._out) == 1)\nAssertionError\n', linkargs=[], skip_test_expected=False)
expected = testinfo(exitcode=0, execcode=0, output='1\n', linkargs=[], skip_test_expected=False)

    def assert_equal(self, actual, expected):
        if TYPECHECK_ONLY and expected.exitcode == 0:
            # Compiler does not fail => no output expected
            assert actual.output == "", \
                "Compiler unexpectedly generated some output with --disable-codegen"
            assert actual.exitcode == 0, \
                "Compiler unexpectedly failed with --disable-codegen"
            return
        if DISABLE_TYPECHECK and expected.exitcode != 0:
            # Test should fail at typecheck, and we don't do
            # typechecking => nothing to check.
            pytest.skip("Test that doesn't typecheck with --disable-typecheck")
        if expected.output is not None and actual.output is not None:
>           assert actual.output == expected.output, \
                "Output of the program is incorrect."
E           AssertionError: Output of the program is incorrect.
E           assert ('Traceback (most recent call last):\n'\n '  File "./MiniCC.py", line 218, in <module>\n'\n '    main(args.filename, args.reg_alloc, args.ssa,\n'\n '  File "./MiniCC.py", line 168, in main\n'\n '    cfg.print_code(output, comment=comment)\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code\n'\n '    for i in self.linearize():\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize\n'\n '    assert(len(block._out) == 1)\n'\n 'AssertionError\n') == '1\n'
E             - 1
E             + Traceback (most recent call last):
E             +   File "./MiniCC.py", line 218, in <module>
E             +     main(args.filename, args.reg_alloc, args.ssa,
E             +   File "./MiniCC.py", line 168, in main
E             +     cfg.print_code(output, comment=comment)
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
E             +     for i in self.linearize():
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
E             +     assert(len(block._out) == 1)
E             + AssertionError

test_codegen.py:91: AssertionError
----------------------------- Captured stdout call -----------------------------
Compiling ...
/usr/bin/python3 ./MiniCC.py --reg-alloc=all_in_mem --output=./TP04/tests/provided/step2/test_compare_1_1-all_in_mem.s ./TP04/tests/provided/step2/test_compare_1_1.c
Exited with status: 1
Traceback (most recent call last):
  File "./MiniCC.py", line 218, in <module>
    main(args.filename, args.reg_alloc, args.ssa,
  File "./MiniCC.py", line 168, in main
    cfg.print_code(output, comment=comment)
  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
    for i in self.linearize():
  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
    assert(len(block._out) == 1)
AssertionError

______ TestCodeGen.test_alloc_mem[./TP04/tests/provided/step2/test_if2.c] ______

self = <test_codegen.TestCodeGen object at 0x7f142b17d730>
filename = './TP04/tests/provided/step2/test_if2.c'

    @pytest.mark.parametrize('filename', ALL_IN_MEM_FILES)
    def test_alloc_mem(self, filename):
        expect = self.get_expect(filename)
        actual = self.all_in_mem(filename, expect)
>       self.assert_equal(actual, expect)

test_codegen.py:247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_codegen.TestCodeGen object at 0x7f142b17d730>
actual = testinfo(exitcode=1, execcode=0, output='Traceback (most recent call last):\n  File "./MiniCC.py", line 218, in <modul...y", line 327, in linearize\n    assert(len(block._out) == 1)\nAssertionError\n', linkargs=[], skip_test_expected=False)
expected = testinfo(exitcode=0, execcode=0, output='12\n14\n', linkargs=[], skip_test_expected=False)

    def assert_equal(self, actual, expected):
        if TYPECHECK_ONLY and expected.exitcode == 0:
            # Compiler does not fail => no output expected
            assert actual.output == "", \
                "Compiler unexpectedly generated some output with --disable-codegen"
            assert actual.exitcode == 0, \
                "Compiler unexpectedly failed with --disable-codegen"
            return
        if DISABLE_TYPECHECK and expected.exitcode != 0:
            # Test should fail at typecheck, and we don't do
            # typechecking => nothing to check.
            pytest.skip("Test that doesn't typecheck with --disable-typecheck")
        if expected.output is not None and actual.output is not None:
>           assert actual.output == expected.output, \
                "Output of the program is incorrect."
E           AssertionError: Output of the program is incorrect.
E           assert ('Traceback (most recent call last):\n'\n '  File "./MiniCC.py", line 218, in <module>\n'\n '    main(args.filename, args.reg_alloc, args.ssa,\n'\n '  File "./MiniCC.py", line 168, in main\n'\n '    cfg.print_code(output, comment=comment)\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code\n'\n '    for i in self.linearize():\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize\n'\n '    assert(len(block._out) == 1)\n'\n 'AssertionError\n') == '12\n14\n'
E             - 12
E             - 14
E             + Traceback (most recent call last):
E             +   File "./MiniCC.py", line 218, in <module>
E             +     main(args.filename, args.reg_alloc, args.ssa,
E             +   File "./MiniCC.py", line 168, in main
E             +     cfg.print_code(output, comment=comment)
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
E             +     for i in self.linearize():
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
E             +     assert(len(block._out) == 1)
E             + AssertionError

test_codegen.py:91: AssertionError
----------------------------- Captured stdout call -----------------------------
Compiling ...
/usr/bin/python3 ./MiniCC.py --reg-alloc=all_in_mem --output=./TP04/tests/provided/step2/test_if2-all_in_mem.s ./TP04/tests/provided/step2/test_if2.c
Exited with status: 1
Traceback (most recent call last):
  File "./MiniCC.py", line 218, in <module>
    main(args.filename, args.reg_alloc, args.ssa,
  File "./MiniCC.py", line 168, in main
    cfg.print_code(output, comment=comment)
  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
    for i in self.linearize():
  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
    assert(len(block._out) == 1)
AssertionError

____ TestCodeGen.test_alloc_mem[./TP04/tests/provided/step2/test_while1.c] _____

self = <test_codegen.TestCodeGen object at 0x7f142b1602b0>
filename = './TP04/tests/provided/step2/test_while1.c'

    @pytest.mark.parametrize('filename', ALL_IN_MEM_FILES)
    def test_alloc_mem(self, filename):
        expect = self.get_expect(filename)
        actual = self.all_in_mem(filename, expect)
>       self.assert_equal(actual, expect)

test_codegen.py:247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_codegen.TestCodeGen object at 0x7f142b1602b0>
actual = testinfo(exitcode=1, execcode=0, output='Traceback (most recent call last):\n  File "./MiniCC.py", line 218, in <modul...y", line 327, in linearize\n    assert(len(block._out) == 1)\nAssertionError\n', linkargs=[], skip_test_expected=False)
expected = testinfo(exitcode=0, execcode=0, output='8\n7\n6\n5\n4\n3\n2\n1\n0\n', linkargs=[], skip_test_expected=False)

    def assert_equal(self, actual, expected):
        if TYPECHECK_ONLY and expected.exitcode == 0:
            # Compiler does not fail => no output expected
            assert actual.output == "", \
                "Compiler unexpectedly generated some output with --disable-codegen"
            assert actual.exitcode == 0, \
                "Compiler unexpectedly failed with --disable-codegen"
            return
        if DISABLE_TYPECHECK and expected.exitcode != 0:
            # Test should fail at typecheck, and we don't do
            # typechecking => nothing to check.
            pytest.skip("Test that doesn't typecheck with --disable-typecheck")
        if expected.output is not None and actual.output is not None:
>           assert actual.output == expected.output, \
                "Output of the program is incorrect."
E           AssertionError: Output of the program is incorrect.
E           assert ('Traceback (most recent call last):\n'\n '  File "./MiniCC.py", line 218, in <module>\n'\n '    main(args.filename, args.reg_alloc, args.ssa,\n'\n '  File "./MiniCC.py", line 168, in main\n'\n '    cfg.print_code(output, comment=comment)\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code\n'\n '    for i in self.linearize():\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize\n'\n '    assert(len(block._out) == 1)\n'\n 'AssertionError\n') == '8\n7\n6\n5\n4\n3\n2\n1\n0\n'
E             - 8
E             - 7
E             - 6
E             - 5
E             - 4
E             - 3
E             - 2
E             - 1
E             - 0
E             + Traceback (most recent call last):
E             +   File "./MiniCC.py", line 218, in <module>
E             +     main(args.filename, args.reg_alloc, args.ssa,
E             +   File "./MiniCC.py", line 168, in main
E             +     cfg.print_code(output, comment=comment)
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
E             +     for i in self.linearize():
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
E             +     assert(len(block._out) == 1)
E             + AssertionError

test_codegen.py:91: AssertionError
----------------------------- Captured stdout call -----------------------------
Compiling ...
/usr/bin/python3 ./MiniCC.py --reg-alloc=all_in_mem --output=./TP04/tests/provided/step2/test_while1-all_in_mem.s ./TP04/tests/provided/step2/test_while1.c
Exited with status: 1
Traceback (most recent call last):
  File "./MiniCC.py", line 218, in <module>
    main(args.filename, args.reg_alloc, args.ssa,
  File "./MiniCC.py", line 168, in main
    cfg.print_code(output, comment=comment)
  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
    for i in self.linearize():
  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
    assert(len(block._out) == 1)
AssertionError

_______ TestCodeGen.test_alloc_mem[./TP04/tests/provided/test_while2b.c] _______

self = <test_codegen.TestCodeGen object at 0x7f142b208340>
filename = './TP04/tests/provided/test_while2b.c'

    @pytest.mark.parametrize('filename', ALL_IN_MEM_FILES)
    def test_alloc_mem(self, filename):
        expect = self.get_expect(filename)
        actual = self.all_in_mem(filename, expect)
>       self.assert_equal(actual, expect)

test_codegen.py:247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_codegen.TestCodeGen object at 0x7f142b208340>
actual = testinfo(exitcode=1, execcode=0, output='Traceback (most recent call last):\n  File "./MiniCC.py", line 218, in <modul...y", line 327, in linearize\n    assert(len(block._out) == 1)\nAssertionError\n', linkargs=[], skip_test_expected=False)
expected = testinfo(exitcode=0, execcode=0, output='7\n', linkargs=[], skip_test_expected=False)

    def assert_equal(self, actual, expected):
        if TYPECHECK_ONLY and expected.exitcode == 0:
            # Compiler does not fail => no output expected
            assert actual.output == "", \
                "Compiler unexpectedly generated some output with --disable-codegen"
            assert actual.exitcode == 0, \
                "Compiler unexpectedly failed with --disable-codegen"
            return
        if DISABLE_TYPECHECK and expected.exitcode != 0:
            # Test should fail at typecheck, and we don't do
            # typechecking => nothing to check.
            pytest.skip("Test that doesn't typecheck with --disable-typecheck")
        if expected.output is not None and actual.output is not None:
>           assert actual.output == expected.output, \
                "Output of the program is incorrect."
E           AssertionError: Output of the program is incorrect.
E           assert ('Traceback (most recent call last):\n'\n '  File "./MiniCC.py", line 218, in <module>\n'\n '    main(args.filename, args.reg_alloc, args.ssa,\n'\n '  File "./MiniCC.py", line 168, in main\n'\n '    cfg.print_code(output, comment=comment)\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code\n'\n '    for i in self.linearize():\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize\n'\n '    assert(len(block._out) == 1)\n'\n 'AssertionError\n') == '7\n'
E             - 7
E             + Traceback (most recent call last):
E             +   File "./MiniCC.py", line 218, in <module>
E             +     main(args.filename, args.reg_alloc, args.ssa,
E             +   File "./MiniCC.py", line 168, in main
E             +     cfg.print_code(output, comment=comment)
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
E             +     for i in self.linearize():
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
E             +     assert(len(block._out) == 1)
E             + AssertionError

test_codegen.py:91: AssertionError
----------------------------- Captured stdout call -----------------------------
Compiling ...
/usr/bin/python3 ./MiniCC.py --reg-alloc=all_in_mem --output=./TP04/tests/provided/test_while2b-all_in_mem.s ./TP04/tests/provided/test_while2b.c
Exited with status: 1
Traceback (most recent call last):
  File "./MiniCC.py", line 218, in <module>
    main(args.filename, args.reg_alloc, args.ssa,
  File "./MiniCC.py", line 168, in main
    cfg.print_code(output, comment=comment)
  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
    for i in self.linearize():
  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
    assert(len(block._out) == 1)
AssertionError

______ TestCodeGen.test_alloc_mem[./TP04/tests/students/and/test_and_1.c] ______

self = <test_codegen.TestCodeGen object at 0x7f142b20c460>
filename = './TP04/tests/students/and/test_and_1.c'

    @pytest.mark.parametrize('filename', ALL_IN_MEM_FILES)
    def test_alloc_mem(self, filename):
        expect = self.get_expect(filename)
        actual = self.all_in_mem(filename, expect)
>       self.assert_equal(actual, expect)

test_codegen.py:247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_codegen.TestCodeGen object at 0x7f142b20c460>
actual = testinfo(exitcode=1, execcode=0, output='Traceback (most recent call last):\n  File "./MiniCC.py", line 218, in <modul...y", line 327, in linearize\n    assert(len(block._out) == 1)\nAssertionError\n', linkargs=[], skip_test_expected=False)
expected = testinfo(exitcode=0, execcode=0, output='0\n', linkargs=[], skip_test_expected=False)

    def assert_equal(self, actual, expected):
        if TYPECHECK_ONLY and expected.exitcode == 0:
            # Compiler does not fail => no output expected
            assert actual.output == "", \
                "Compiler unexpectedly generated some output with --disable-codegen"
            assert actual.exitcode == 0, \
                "Compiler unexpectedly failed with --disable-codegen"
            return
        if DISABLE_TYPECHECK and expected.exitcode != 0:
            # Test should fail at typecheck, and we don't do
            # typechecking => nothing to check.
            pytest.skip("Test that doesn't typecheck with --disable-typecheck")
        if expected.output is not None and actual.output is not None:
>           assert actual.output == expected.output, \
                "Output of the program is incorrect."
E           AssertionError: Output of the program is incorrect.
E           assert ('Traceback (most recent call last):\n'\n '  File "./MiniCC.py", line 218, in <module>\n'\n '    main(args.filename, args.reg_alloc, args.ssa,\n'\n '  File "./MiniCC.py", line 168, in main\n'\n '    cfg.print_code(output, comment=comment)\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code\n'\n '    for i in self.linearize():\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize\n'\n '    assert(len(block._out) == 1)\n'\n 'AssertionError\n') == '0\n'
E             - 0
E             + Traceback (most recent call last):
E             +   File "./MiniCC.py", line 218, in <module>
E             +     main(args.filename, args.reg_alloc, args.ssa,
E             +   File "./MiniCC.py", line 168, in main
E             +     cfg.print_code(output, comment=comment)
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
E             +     for i in self.linearize():
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
E             +     assert(len(block._out) == 1)
E             + AssertionError

test_codegen.py:91: AssertionError
----------------------------- Captured stdout call -----------------------------
Compiling ...
/usr/bin/python3 ./MiniCC.py --reg-alloc=all_in_mem --output=./TP04/tests/students/and/test_and_1-all_in_mem.s ./TP04/tests/students/and/test_and_1.c
Exited with status: 1
Traceback (most recent call last):
  File "./MiniCC.py", line 218, in <module>
    main(args.filename, args.reg_alloc, args.ssa,
  File "./MiniCC.py", line 168, in main
    cfg.print_code(output, comment=comment)
  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
    for i in self.linearize():
  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
    assert(len(block._out) == 1)
AssertionError

______ TestCodeGen.test_alloc_mem[./TP04/tests/students/and/test_and_2.c] ______

self = <test_codegen.TestCodeGen object at 0x7f142b166790>
filename = './TP04/tests/students/and/test_and_2.c'

    @pytest.mark.parametrize('filename', ALL_IN_MEM_FILES)
    def test_alloc_mem(self, filename):
        expect = self.get_expect(filename)
        actual = self.all_in_mem(filename, expect)
>       self.assert_equal(actual, expect)

test_codegen.py:247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_codegen.TestCodeGen object at 0x7f142b166790>
actual = testinfo(exitcode=1, execcode=0, output='Traceback (most recent call last):\n  File "./MiniCC.py", line 218, in <modul...y", line 327, in linearize\n    assert(len(block._out) == 1)\nAssertionError\n', linkargs=[], skip_test_expected=False)
expected = testinfo(exitcode=0, execcode=0, output='1\n', linkargs=[], skip_test_expected=False)

    def assert_equal(self, actual, expected):
        if TYPECHECK_ONLY and expected.exitcode == 0:
            # Compiler does not fail => no output expected
            assert actual.output == "", \
                "Compiler unexpectedly generated some output with --disable-codegen"
            assert actual.exitcode == 0, \
                "Compiler unexpectedly failed with --disable-codegen"
            return
        if DISABLE_TYPECHECK and expected.exitcode != 0:
            # Test should fail at typecheck, and we don't do
            # typechecking => nothing to check.
            pytest.skip("Test that doesn't typecheck with --disable-typecheck")
        if expected.output is not None and actual.output is not None:
>           assert actual.output == expected.output, \
                "Output of the program is incorrect."
E           AssertionError: Output of the program is incorrect.
E           assert ('Traceback (most recent call last):\n'\n '  File "./MiniCC.py", line 218, in <module>\n'\n '    main(args.filename, args.reg_alloc, args.ssa,\n'\n '  File "./MiniCC.py", line 168, in main\n'\n '    cfg.print_code(output, comment=comment)\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code\n'\n '    for i in self.linearize():\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize\n'\n '    assert(len(block._out) == 1)\n'\n 'AssertionError\n') == '1\n'
E             - 1
E             + Traceback (most recent call last):
E             +   File "./MiniCC.py", line 218, in <module>
E             +     main(args.filename, args.reg_alloc, args.ssa,
E             +   File "./MiniCC.py", line 168, in main
E             +     cfg.print_code(output, comment=comment)
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
E             +     for i in self.linearize():
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
E             +     assert(len(block._out) == 1)
E             + AssertionError

test_codegen.py:91: AssertionError
----------------------------- Captured stdout call -----------------------------
Compiling ...
/usr/bin/python3 ./MiniCC.py --reg-alloc=all_in_mem --output=./TP04/tests/students/and/test_and_2-all_in_mem.s ./TP04/tests/students/and/test_and_2.c
Exited with status: 1
Traceback (most recent call last):
  File "./MiniCC.py", line 218, in <module>
    main(args.filename, args.reg_alloc, args.ssa,
  File "./MiniCC.py", line 168, in main
    cfg.print_code(output, comment=comment)
  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
    for i in self.linearize():
  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
    assert(len(block._out) == 1)
AssertionError

______ TestCodeGen.test_alloc_mem[./TP04/tests/students/and/test_and_3.c] ______

self = <test_codegen.TestCodeGen object at 0x7f142b1fffd0>
filename = './TP04/tests/students/and/test_and_3.c'

    @pytest.mark.parametrize('filename', ALL_IN_MEM_FILES)
    def test_alloc_mem(self, filename):
        expect = self.get_expect(filename)
        actual = self.all_in_mem(filename, expect)
>       self.assert_equal(actual, expect)

test_codegen.py:247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_codegen.TestCodeGen object at 0x7f142b1fffd0>
actual = testinfo(exitcode=1, execcode=0, output='Traceback (most recent call last):\n  File "./MiniCC.py", line 218, in <modul...y", line 327, in linearize\n    assert(len(block._out) == 1)\nAssertionError\n', linkargs=[], skip_test_expected=False)
expected = testinfo(exitcode=0, execcode=0, output='0\n', linkargs=[], skip_test_expected=False)

    def assert_equal(self, actual, expected):
        if TYPECHECK_ONLY and expected.exitcode == 0:
            # Compiler does not fail => no output expected
            assert actual.output == "", \
                "Compiler unexpectedly generated some output with --disable-codegen"
            assert actual.exitcode == 0, \
                "Compiler unexpectedly failed with --disable-codegen"
            return
        if DISABLE_TYPECHECK and expected.exitcode != 0:
            # Test should fail at typecheck, and we don't do
            # typechecking => nothing to check.
            pytest.skip("Test that doesn't typecheck with --disable-typecheck")
        if expected.output is not None and actual.output is not None:
>           assert actual.output == expected.output, \
                "Output of the program is incorrect."
E           AssertionError: Output of the program is incorrect.
E           assert ('Traceback (most recent call last):\n'\n '  File "./MiniCC.py", line 218, in <module>\n'\n '    main(args.filename, args.reg_alloc, args.ssa,\n'\n '  File "./MiniCC.py", line 168, in main\n'\n '    cfg.print_code(output, comment=comment)\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code\n'\n '    for i in self.linearize():\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize\n'\n '    assert(len(block._out) == 1)\n'\n 'AssertionError\n') == '0\n'
E             - 0
E             + Traceback (most recent call last):
E             +   File "./MiniCC.py", line 218, in <module>
E             +     main(args.filename, args.reg_alloc, args.ssa,
E             +   File "./MiniCC.py", line 168, in main
E             +     cfg.print_code(output, comment=comment)
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
E             +     for i in self.linearize():
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
E             +     assert(len(block._out) == 1)
E             + AssertionError

test_codegen.py:91: AssertionError
----------------------------- Captured stdout call -----------------------------
Compiling ...
/usr/bin/python3 ./MiniCC.py --reg-alloc=all_in_mem --output=./TP04/tests/students/and/test_and_3-all_in_mem.s ./TP04/tests/students/and/test_and_3.c
Exited with status: 1
Traceback (most recent call last):
  File "./MiniCC.py", line 218, in <module>
    main(args.filename, args.reg_alloc, args.ssa,
  File "./MiniCC.py", line 168, in main
    cfg.print_code(output, comment=comment)
  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
    for i in self.linearize():
  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
    assert(len(block._out) == 1)
AssertionError

_______ TestCodeGen.test_alloc_mem[./TP04/tests/students/if/test_if_1.c] _______

self = <test_codegen.TestCodeGen object at 0x7f142b215130>
filename = './TP04/tests/students/if/test_if_1.c'

    @pytest.mark.parametrize('filename', ALL_IN_MEM_FILES)
    def test_alloc_mem(self, filename):
        expect = self.get_expect(filename)
        actual = self.all_in_mem(filename, expect)
>       self.assert_equal(actual, expect)

test_codegen.py:247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_codegen.TestCodeGen object at 0x7f142b215130>
actual = testinfo(exitcode=1, execcode=0, output='Traceback (most recent call last):\n  File "./MiniCC.py", line 218, in <modul...y", line 327, in linearize\n    assert(len(block._out) == 1)\nAssertionError\n', linkargs=[], skip_test_expected=False)
expected = testinfo(exitcode=0, execcode=0, output='1\n', linkargs=[], skip_test_expected=False)

    def assert_equal(self, actual, expected):
        if TYPECHECK_ONLY and expected.exitcode == 0:
            # Compiler does not fail => no output expected
            assert actual.output == "", \
                "Compiler unexpectedly generated some output with --disable-codegen"
            assert actual.exitcode == 0, \
                "Compiler unexpectedly failed with --disable-codegen"
            return
        if DISABLE_TYPECHECK and expected.exitcode != 0:
            # Test should fail at typecheck, and we don't do
            # typechecking => nothing to check.
            pytest.skip("Test that doesn't typecheck with --disable-typecheck")
        if expected.output is not None and actual.output is not None:
>           assert actual.output == expected.output, \
                "Output of the program is incorrect."
E           AssertionError: Output of the program is incorrect.
E           assert ('Traceback (most recent call last):\n'\n '  File "./MiniCC.py", line 218, in <module>\n'\n '    main(args.filename, args.reg_alloc, args.ssa,\n'\n '  File "./MiniCC.py", line 168, in main\n'\n '    cfg.print_code(output, comment=comment)\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code\n'\n '    for i in self.linearize():\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize\n'\n '    assert(len(block._out) == 1)\n'\n 'AssertionError\n') == '1\n'
E             - 1
E             + Traceback (most recent call last):
E             +   File "./MiniCC.py", line 218, in <module>
E             +     main(args.filename, args.reg_alloc, args.ssa,
E             +   File "./MiniCC.py", line 168, in main
E             +     cfg.print_code(output, comment=comment)
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
E             +     for i in self.linearize():
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
E             +     assert(len(block._out) == 1)
E             + AssertionError

test_codegen.py:91: AssertionError
----------------------------- Captured stdout call -----------------------------
Compiling ...
/usr/bin/python3 ./MiniCC.py --reg-alloc=all_in_mem --output=./TP04/tests/students/if/test_if_1-all_in_mem.s ./TP04/tests/students/if/test_if_1.c
Exited with status: 1
Traceback (most recent call last):
  File "./MiniCC.py", line 218, in <module>
    main(args.filename, args.reg_alloc, args.ssa,
  File "./MiniCC.py", line 168, in main
    cfg.print_code(output, comment=comment)
  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
    for i in self.linearize():
  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
    assert(len(block._out) == 1)
AssertionError

______ TestCodeGen.test_alloc_mem[./TP04/tests/students/if/test_if_10.c] _______

self = <test_codegen.TestCodeGen object at 0x7f142b190550>
filename = './TP04/tests/students/if/test_if_10.c'

    @pytest.mark.parametrize('filename', ALL_IN_MEM_FILES)
    def test_alloc_mem(self, filename):
        expect = self.get_expect(filename)
        actual = self.all_in_mem(filename, expect)
>       self.assert_equal(actual, expect)

test_codegen.py:247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_codegen.TestCodeGen object at 0x7f142b190550>
actual = testinfo(exitcode=1, execcode=0, output='Traceback (most recent call last):\n  File "./MiniCC.py", line 218, in <modul...y", line 327, in linearize\n    assert(len(block._out) == 1)\nAssertionError\n', linkargs=[], skip_test_expected=False)
expected = testinfo(exitcode=0, execcode=0, output='2\n2\n2\n1\n', linkargs=[], skip_test_expected=False)

    def assert_equal(self, actual, expected):
        if TYPECHECK_ONLY and expected.exitcode == 0:
            # Compiler does not fail => no output expected
            assert actual.output == "", \
                "Compiler unexpectedly generated some output with --disable-codegen"
            assert actual.exitcode == 0, \
                "Compiler unexpectedly failed with --disable-codegen"
            return
        if DISABLE_TYPECHECK and expected.exitcode != 0:
            # Test should fail at typecheck, and we don't do
            # typechecking => nothing to check.
            pytest.skip("Test that doesn't typecheck with --disable-typecheck")
        if expected.output is not None and actual.output is not None:
>           assert actual.output == expected.output, \
                "Output of the program is incorrect."
E           AssertionError: Output of the program is incorrect.
E           assert ('Traceback (most recent call last):\n'\n '  File "./MiniCC.py", line 218, in <module>\n'\n '    main(args.filename, args.reg_alloc, args.ssa,\n'\n '  File "./MiniCC.py", line 168, in main\n'\n '    cfg.print_code(output, comment=comment)\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code\n'\n '    for i in self.linearize():\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize\n'\n '    assert(len(block._out) == 1)\n'\n 'AssertionError\n') == '2\n2\n2\n1\n'
E             - 2
E             - 2
E             - 2
E             - 1
E             + Traceback (most recent call last):
E             +   File "./MiniCC.py", line 218, in <module>
E             +     main(args.filename, args.reg_alloc, args.ssa,
E             +   File "./MiniCC.py", line 168, in main
E             +     cfg.print_code(output, comment=comment)
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
E             +     for i in self.linearize():
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
E             +     assert(len(block._out) == 1)
E             + AssertionError

test_codegen.py:91: AssertionError
----------------------------- Captured stdout call -----------------------------
Compiling ...
/usr/bin/python3 ./MiniCC.py --reg-alloc=all_in_mem --output=./TP04/tests/students/if/test_if_10-all_in_mem.s ./TP04/tests/students/if/test_if_10.c
Exited with status: 1
Traceback (most recent call last):
  File "./MiniCC.py", line 218, in <module>
    main(args.filename, args.reg_alloc, args.ssa,
  File "./MiniCC.py", line 168, in main
    cfg.print_code(output, comment=comment)
  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
    for i in self.linearize():
  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
    assert(len(block._out) == 1)
AssertionError

_______ TestCodeGen.test_alloc_mem[./TP04/tests/students/if/test_if_2.c] _______

self = <test_codegen.TestCodeGen object at 0x7f142b208520>
filename = './TP04/tests/students/if/test_if_2.c'

    @pytest.mark.parametrize('filename', ALL_IN_MEM_FILES)
    def test_alloc_mem(self, filename):
        expect = self.get_expect(filename)
        actual = self.all_in_mem(filename, expect)
>       self.assert_equal(actual, expect)

test_codegen.py:247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_codegen.TestCodeGen object at 0x7f142b208520>
actual = testinfo(exitcode=1, execcode=0, output='Traceback (most recent call last):\n  File "./MiniCC.py", line 218, in <modul...y", line 327, in linearize\n    assert(len(block._out) == 1)\nAssertionError\n', linkargs=[], skip_test_expected=False)
expected = testinfo(exitcode=0, execcode=0, output='1\n', linkargs=[], skip_test_expected=False)

    def assert_equal(self, actual, expected):
        if TYPECHECK_ONLY and expected.exitcode == 0:
            # Compiler does not fail => no output expected
            assert actual.output == "", \
                "Compiler unexpectedly generated some output with --disable-codegen"
            assert actual.exitcode == 0, \
                "Compiler unexpectedly failed with --disable-codegen"
            return
        if DISABLE_TYPECHECK and expected.exitcode != 0:
            # Test should fail at typecheck, and we don't do
            # typechecking => nothing to check.
            pytest.skip("Test that doesn't typecheck with --disable-typecheck")
        if expected.output is not None and actual.output is not None:
>           assert actual.output == expected.output, \
                "Output of the program is incorrect."
E           AssertionError: Output of the program is incorrect.
E           assert ('Traceback (most recent call last):\n'\n '  File "./MiniCC.py", line 218, in <module>\n'\n '    main(args.filename, args.reg_alloc, args.ssa,\n'\n '  File "./MiniCC.py", line 168, in main\n'\n '    cfg.print_code(output, comment=comment)\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code\n'\n '    for i in self.linearize():\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize\n'\n '    assert(len(block._out) == 1)\n'\n 'AssertionError\n') == '1\n'
E             - 1
E             + Traceback (most recent call last):
E             +   File "./MiniCC.py", line 218, in <module>
E             +     main(args.filename, args.reg_alloc, args.ssa,
E             +   File "./MiniCC.py", line 168, in main
E             +     cfg.print_code(output, comment=comment)
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
E             +     for i in self.linearize():
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
E             +     assert(len(block._out) == 1)
E             + AssertionError

test_codegen.py:91: AssertionError
----------------------------- Captured stdout call -----------------------------
Compiling ...
/usr/bin/python3 ./MiniCC.py --reg-alloc=all_in_mem --output=./TP04/tests/students/if/test_if_2-all_in_mem.s ./TP04/tests/students/if/test_if_2.c
Exited with status: 1
Traceback (most recent call last):
  File "./MiniCC.py", line 218, in <module>
    main(args.filename, args.reg_alloc, args.ssa,
  File "./MiniCC.py", line 168, in main
    cfg.print_code(output, comment=comment)
  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
    for i in self.linearize():
  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
    assert(len(block._out) == 1)
AssertionError

_______ TestCodeGen.test_alloc_mem[./TP04/tests/students/if/test_if_3.c] _______

self = <test_codegen.TestCodeGen object at 0x7f142b120b20>
filename = './TP04/tests/students/if/test_if_3.c'

    @pytest.mark.parametrize('filename', ALL_IN_MEM_FILES)
    def test_alloc_mem(self, filename):
        expect = self.get_expect(filename)
        actual = self.all_in_mem(filename, expect)
>       self.assert_equal(actual, expect)

test_codegen.py:247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_codegen.TestCodeGen object at 0x7f142b120b20>
actual = testinfo(exitcode=1, execcode=0, output='Traceback (most recent call last):\n  File "./MiniCC.py", line 218, in <modul...y", line 327, in linearize\n    assert(len(block._out) == 1)\nAssertionError\n', linkargs=[], skip_test_expected=False)
expected = testinfo(exitcode=0, execcode=0, output='', linkargs=[], skip_test_expected=False)

    def assert_equal(self, actual, expected):
        if TYPECHECK_ONLY and expected.exitcode == 0:
            # Compiler does not fail => no output expected
            assert actual.output == "", \
                "Compiler unexpectedly generated some output with --disable-codegen"
            assert actual.exitcode == 0, \
                "Compiler unexpectedly failed with --disable-codegen"
            return
        if DISABLE_TYPECHECK and expected.exitcode != 0:
            # Test should fail at typecheck, and we don't do
            # typechecking => nothing to check.
            pytest.skip("Test that doesn't typecheck with --disable-typecheck")
        if expected.output is not None and actual.output is not None:
>           assert actual.output == expected.output, \
                "Output of the program is incorrect."
E           AssertionError: Output of the program is incorrect.
E           assert ('Traceback (most recent call last):\n'\n '  File "./MiniCC.py", line 218, in <module>\n'\n '    main(args.filename, args.reg_alloc, args.ssa,\n'\n '  File "./MiniCC.py", line 168, in main\n'\n '    cfg.print_code(output, comment=comment)\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code\n'\n '    for i in self.linearize():\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize\n'\n '    assert(len(block._out) == 1)\n'\n 'AssertionError\n') == ''
E             + Traceback (most recent call last):
E             +   File "./MiniCC.py", line 218, in <module>
E             +     main(args.filename, args.reg_alloc, args.ssa,
E             +   File "./MiniCC.py", line 168, in main
E             +     cfg.print_code(output, comment=comment)
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
E             +     for i in self.linearize():
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
E             +     assert(len(block._out) == 1)
E             + AssertionError

test_codegen.py:91: AssertionError
----------------------------- Captured stdout call -----------------------------
Compiling ...
/usr/bin/python3 ./MiniCC.py --reg-alloc=all_in_mem --output=./TP04/tests/students/if/test_if_3-all_in_mem.s ./TP04/tests/students/if/test_if_3.c
Exited with status: 1
Traceback (most recent call last):
  File "./MiniCC.py", line 218, in <module>
    main(args.filename, args.reg_alloc, args.ssa,
  File "./MiniCC.py", line 168, in main
    cfg.print_code(output, comment=comment)
  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
    for i in self.linearize():
  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
    assert(len(block._out) == 1)
AssertionError

_______ TestCodeGen.test_alloc_mem[./TP04/tests/students/if/test_if_4.c] _______

self = <test_codegen.TestCodeGen object at 0x7f142b2106d0>
filename = './TP04/tests/students/if/test_if_4.c'

    @pytest.mark.parametrize('filename', ALL_IN_MEM_FILES)
    def test_alloc_mem(self, filename):
        expect = self.get_expect(filename)
        actual = self.all_in_mem(filename, expect)
>       self.assert_equal(actual, expect)

test_codegen.py:247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_codegen.TestCodeGen object at 0x7f142b2106d0>
actual = testinfo(exitcode=1, execcode=0, output='Traceback (most recent call last):\n  File "./MiniCC.py", line 218, in <modul...y", line 327, in linearize\n    assert(len(block._out) == 1)\nAssertionError\n', linkargs=[], skip_test_expected=False)
expected = testinfo(exitcode=0, execcode=0, output='0\n', linkargs=[], skip_test_expected=False)

    def assert_equal(self, actual, expected):
        if TYPECHECK_ONLY and expected.exitcode == 0:
            # Compiler does not fail => no output expected
            assert actual.output == "", \
                "Compiler unexpectedly generated some output with --disable-codegen"
            assert actual.exitcode == 0, \
                "Compiler unexpectedly failed with --disable-codegen"
            return
        if DISABLE_TYPECHECK and expected.exitcode != 0:
            # Test should fail at typecheck, and we don't do
            # typechecking => nothing to check.
            pytest.skip("Test that doesn't typecheck with --disable-typecheck")
        if expected.output is not None and actual.output is not None:
>           assert actual.output == expected.output, \
                "Output of the program is incorrect."
E           AssertionError: Output of the program is incorrect.
E           assert ('Traceback (most recent call last):\n'\n '  File "./MiniCC.py", line 218, in <module>\n'\n '    main(args.filename, args.reg_alloc, args.ssa,\n'\n '  File "./MiniCC.py", line 168, in main\n'\n '    cfg.print_code(output, comment=comment)\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code\n'\n '    for i in self.linearize():\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize\n'\n '    assert(len(block._out) == 1)\n'\n 'AssertionError\n') == '0\n'
E             - 0
E             + Traceback (most recent call last):
E             +   File "./MiniCC.py", line 218, in <module>
E             +     main(args.filename, args.reg_alloc, args.ssa,
E             +   File "./MiniCC.py", line 168, in main
E             +     cfg.print_code(output, comment=comment)
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
E             +     for i in self.linearize():
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
E             +     assert(len(block._out) == 1)
E             + AssertionError

test_codegen.py:91: AssertionError
----------------------------- Captured stdout call -----------------------------
Compiling ...
/usr/bin/python3 ./MiniCC.py --reg-alloc=all_in_mem --output=./TP04/tests/students/if/test_if_4-all_in_mem.s ./TP04/tests/students/if/test_if_4.c
Exited with status: 1
Traceback (most recent call last):
  File "./MiniCC.py", line 218, in <module>
    main(args.filename, args.reg_alloc, args.ssa,
  File "./MiniCC.py", line 168, in main
    cfg.print_code(output, comment=comment)
  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
    for i in self.linearize():
  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
    assert(len(block._out) == 1)
AssertionError

_______ TestCodeGen.test_alloc_mem[./TP04/tests/students/if/test_if_9.c] _______

self = <test_codegen.TestCodeGen object at 0x7f142b128b80>
filename = './TP04/tests/students/if/test_if_9.c'

    @pytest.mark.parametrize('filename', ALL_IN_MEM_FILES)
    def test_alloc_mem(self, filename):
        expect = self.get_expect(filename)
        actual = self.all_in_mem(filename, expect)
>       self.assert_equal(actual, expect)

test_codegen.py:247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_codegen.TestCodeGen object at 0x7f142b128b80>
actual = testinfo(exitcode=1, execcode=0, output='Traceback (most recent call last):\n  File "./MiniCC.py", line 218, in <modul...y", line 327, in linearize\n    assert(len(block._out) == 1)\nAssertionError\n', linkargs=[], skip_test_expected=False)
expected = testinfo(exitcode=0, execcode=0, output='4\n1\n', linkargs=[], skip_test_expected=False)

    def assert_equal(self, actual, expected):
        if TYPECHECK_ONLY and expected.exitcode == 0:
            # Compiler does not fail => no output expected
            assert actual.output == "", \
                "Compiler unexpectedly generated some output with --disable-codegen"
            assert actual.exitcode == 0, \
                "Compiler unexpectedly failed with --disable-codegen"
            return
        if DISABLE_TYPECHECK and expected.exitcode != 0:
            # Test should fail at typecheck, and we don't do
            # typechecking => nothing to check.
            pytest.skip("Test that doesn't typecheck with --disable-typecheck")
        if expected.output is not None and actual.output is not None:
>           assert actual.output == expected.output, \
                "Output of the program is incorrect."
E           AssertionError: Output of the program is incorrect.
E           assert ('Traceback (most recent call last):\n'\n '  File "./MiniCC.py", line 218, in <module>\n'\n '    main(args.filename, args.reg_alloc, args.ssa,\n'\n '  File "./MiniCC.py", line 168, in main\n'\n '    cfg.print_code(output, comment=comment)\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code\n'\n '    for i in self.linearize():\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize\n'\n '    assert(len(block._out) == 1)\n'\n 'AssertionError\n') == '4\n1\n'
E             - 4
E             - 1
E             + Traceback (most recent call last):
E             +   File "./MiniCC.py", line 218, in <module>
E             +     main(args.filename, args.reg_alloc, args.ssa,
E             +   File "./MiniCC.py", line 168, in main
E             +     cfg.print_code(output, comment=comment)
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
E             +     for i in self.linearize():
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
E             +     assert(len(block._out) == 1)
E             + AssertionError

test_codegen.py:91: AssertionError
----------------------------- Captured stdout call -----------------------------
Compiling ...
/usr/bin/python3 ./MiniCC.py --reg-alloc=all_in_mem --output=./TP04/tests/students/if/test_if_9-all_in_mem.s ./TP04/tests/students/if/test_if_9.c
Exited with status: 1
Traceback (most recent call last):
  File "./MiniCC.py", line 218, in <module>
    main(args.filename, args.reg_alloc, args.ssa,
  File "./MiniCC.py", line 168, in main
    cfg.print_code(output, comment=comment)
  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
    for i in self.linearize():
  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
    assert(len(block._out) == 1)
AssertionError

_ TestCodeGen.test_alloc_mem[./TP04/tests/students/multiplicative/test_multiplicative_div_1.c] _

self = <test_codegen.TestCodeGen object at 0x7f142b1226d0>
filename = './TP04/tests/students/multiplicative/test_multiplicative_div_1.c'

    @pytest.mark.parametrize('filename', ALL_IN_MEM_FILES)
    def test_alloc_mem(self, filename):
        expect = self.get_expect(filename)
        actual = self.all_in_mem(filename, expect)
>       self.assert_equal(actual, expect)

test_codegen.py:247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_codegen.TestCodeGen object at 0x7f142b1226d0>
actual = testinfo(exitcode=1, execcode=0, output='Traceback (most recent call last):\n  File "./MiniCC.py", line 218, in <modul...y", line 327, in linearize\n    assert(len(block._out) == 1)\nAssertionError\n', linkargs=[], skip_test_expected=False)
expected = testinfo(exitcode=0, execcode=0, output='5\n', linkargs=[], skip_test_expected=False)

    def assert_equal(self, actual, expected):
        if TYPECHECK_ONLY and expected.exitcode == 0:
            # Compiler does not fail => no output expected
            assert actual.output == "", \
                "Compiler unexpectedly generated some output with --disable-codegen"
            assert actual.exitcode == 0, \
                "Compiler unexpectedly failed with --disable-codegen"
            return
        if DISABLE_TYPECHECK and expected.exitcode != 0:
            # Test should fail at typecheck, and we don't do
            # typechecking => nothing to check.
            pytest.skip("Test that doesn't typecheck with --disable-typecheck")
        if expected.output is not None and actual.output is not None:
>           assert actual.output == expected.output, \
                "Output of the program is incorrect."
E           AssertionError: Output of the program is incorrect.
E           assert ('Traceback (most recent call last):\n'\n '  File "./MiniCC.py", line 218, in <module>\n'\n '    main(args.filename, args.reg_alloc, args.ssa,\n'\n '  File "./MiniCC.py", line 168, in main\n'\n '    cfg.print_code(output, comment=comment)\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code\n'\n '    for i in self.linearize():\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize\n'\n '    assert(len(block._out) == 1)\n'\n 'AssertionError\n') == '5\n'
E             - 5
E             + Traceback (most recent call last):
E             +   File "./MiniCC.py", line 218, in <module>
E             +     main(args.filename, args.reg_alloc, args.ssa,
E             +   File "./MiniCC.py", line 168, in main
E             +     cfg.print_code(output, comment=comment)
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
E             +     for i in self.linearize():
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
E             +     assert(len(block._out) == 1)
E             + AssertionError

test_codegen.py:91: AssertionError
----------------------------- Captured stdout call -----------------------------
Compiling ...
/usr/bin/python3 ./MiniCC.py --reg-alloc=all_in_mem --output=./TP04/tests/students/multiplicative/test_multiplicative_div_1-all_in_mem.s ./TP04/tests/students/multiplicative/test_multiplicative_div_1.c
Exited with status: 1
Traceback (most recent call last):
  File "./MiniCC.py", line 218, in <module>
    main(args.filename, args.reg_alloc, args.ssa,
  File "./MiniCC.py", line 168, in main
    cfg.print_code(output, comment=comment)
  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
    for i in self.linearize():
  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
    assert(len(block._out) == 1)
AssertionError

_ TestCodeGen.test_alloc_mem[./TP04/tests/students/multiplicative/test_multiplicative_div_2.c] _

self = <test_codegen.TestCodeGen object at 0x7f142b215820>
filename = './TP04/tests/students/multiplicative/test_multiplicative_div_2.c'

    @pytest.mark.parametrize('filename', ALL_IN_MEM_FILES)
    def test_alloc_mem(self, filename):
        expect = self.get_expect(filename)
        actual = self.all_in_mem(filename, expect)
>       self.assert_equal(actual, expect)

test_codegen.py:247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_codegen.TestCodeGen object at 0x7f142b215820>
actual = testinfo(exitcode=1, execcode=0, output='Traceback (most recent call last):\n  File "./MiniCC.py", line 218, in <modul...y", line 327, in linearize\n    assert(len(block._out) == 1)\nAssertionError\n', linkargs=[], skip_test_expected=False)
expected = testinfo(exitcode=0, execcode=0, output='5\n', linkargs=[], skip_test_expected=False)

    def assert_equal(self, actual, expected):
        if TYPECHECK_ONLY and expected.exitcode == 0:
            # Compiler does not fail => no output expected
            assert actual.output == "", \
                "Compiler unexpectedly generated some output with --disable-codegen"
            assert actual.exitcode == 0, \
                "Compiler unexpectedly failed with --disable-codegen"
            return
        if DISABLE_TYPECHECK and expected.exitcode != 0:
            # Test should fail at typecheck, and we don't do
            # typechecking => nothing to check.
            pytest.skip("Test that doesn't typecheck with --disable-typecheck")
        if expected.output is not None and actual.output is not None:
>           assert actual.output == expected.output, \
                "Output of the program is incorrect."
E           AssertionError: Output of the program is incorrect.
E           assert ('Traceback (most recent call last):\n'\n '  File "./MiniCC.py", line 218, in <module>\n'\n '    main(args.filename, args.reg_alloc, args.ssa,\n'\n '  File "./MiniCC.py", line 168, in main\n'\n '    cfg.print_code(output, comment=comment)\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code\n'\n '    for i in self.linearize():\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize\n'\n '    assert(len(block._out) == 1)\n'\n 'AssertionError\n') == '5\n'
E             - 5
E             + Traceback (most recent call last):
E             +   File "./MiniCC.py", line 218, in <module>
E             +     main(args.filename, args.reg_alloc, args.ssa,
E             +   File "./MiniCC.py", line 168, in main
E             +     cfg.print_code(output, comment=comment)
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
E             +     for i in self.linearize():
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
E             +     assert(len(block._out) == 1)
E             + AssertionError

test_codegen.py:91: AssertionError
----------------------------- Captured stdout call -----------------------------
Compiling ...
/usr/bin/python3 ./MiniCC.py --reg-alloc=all_in_mem --output=./TP04/tests/students/multiplicative/test_multiplicative_div_2-all_in_mem.s ./TP04/tests/students/multiplicative/test_multiplicative_div_2.c
Exited with status: 1
Traceback (most recent call last):
  File "./MiniCC.py", line 218, in <module>
    main(args.filename, args.reg_alloc, args.ssa,
  File "./MiniCC.py", line 168, in main
    cfg.print_code(output, comment=comment)
  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
    for i in self.linearize():
  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
    assert(len(block._out) == 1)
AssertionError

_ TestCodeGen.test_alloc_mem[./TP04/tests/students/multiplicative/test_multiplicative_div_3.c] _

self = <test_codegen.TestCodeGen object at 0x7f142b1ff040>
filename = './TP04/tests/students/multiplicative/test_multiplicative_div_3.c'

    @pytest.mark.parametrize('filename', ALL_IN_MEM_FILES)
    def test_alloc_mem(self, filename):
        expect = self.get_expect(filename)
        actual = self.all_in_mem(filename, expect)
>       self.assert_equal(actual, expect)

test_codegen.py:247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_codegen.TestCodeGen object at 0x7f142b1ff040>
actual = testinfo(exitcode=1, execcode=0, output='Traceback (most recent call last):\n  File "./MiniCC.py", line 218, in <modul...y", line 327, in linearize\n    assert(len(block._out) == 1)\nAssertionError\n', linkargs=[], skip_test_expected=False)
expected = testinfo(exitcode=0, execcode=0, output='-21\n', linkargs=[], skip_test_expected=False)

    def assert_equal(self, actual, expected):
        if TYPECHECK_ONLY and expected.exitcode == 0:
            # Compiler does not fail => no output expected
            assert actual.output == "", \
                "Compiler unexpectedly generated some output with --disable-codegen"
            assert actual.exitcode == 0, \
                "Compiler unexpectedly failed with --disable-codegen"
            return
        if DISABLE_TYPECHECK and expected.exitcode != 0:
            # Test should fail at typecheck, and we don't do
            # typechecking => nothing to check.
            pytest.skip("Test that doesn't typecheck with --disable-typecheck")
        if expected.output is not None and actual.output is not None:
>           assert actual.output == expected.output, \
                "Output of the program is incorrect."
E           AssertionError: Output of the program is incorrect.
E           assert ('Traceback (most recent call last):\n'\n '  File "./MiniCC.py", line 218, in <module>\n'\n '    main(args.filename, args.reg_alloc, args.ssa,\n'\n '  File "./MiniCC.py", line 168, in main\n'\n '    cfg.print_code(output, comment=comment)\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code\n'\n '    for i in self.linearize():\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize\n'\n '    assert(len(block._out) == 1)\n'\n 'AssertionError\n') == '-21\n'
E             - -21
E             + Traceback (most recent call last):
E             +   File "./MiniCC.py", line 218, in <module>
E             +     main(args.filename, args.reg_alloc, args.ssa,
E             +   File "./MiniCC.py", line 168, in main
E             +     cfg.print_code(output, comment=comment)
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
E             +     for i in self.linearize():
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
E             +     assert(len(block._out) == 1)
E             + AssertionError

test_codegen.py:91: AssertionError
----------------------------- Captured stdout call -----------------------------
Compiling ...
/usr/bin/python3 ./MiniCC.py --reg-alloc=all_in_mem --output=./TP04/tests/students/multiplicative/test_multiplicative_div_3-all_in_mem.s ./TP04/tests/students/multiplicative/test_multiplicative_div_3.c
Exited with status: 1
Traceback (most recent call last):
  File "./MiniCC.py", line 218, in <module>
    main(args.filename, args.reg_alloc, args.ssa,
  File "./MiniCC.py", line 168, in main
    cfg.print_code(output, comment=comment)
  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
    for i in self.linearize():
  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
    assert(len(block._out) == 1)
AssertionError

_ TestCodeGen.test_alloc_mem[./TP04/tests/students/multiplicative/test_multiplicative_div_zero.c] _

self = <test_codegen.TestCodeGen object at 0x7f142b146cd0>
filename = './TP04/tests/students/multiplicative/test_multiplicative_div_zero.c'

    @pytest.mark.parametrize('filename', ALL_IN_MEM_FILES)
    def test_alloc_mem(self, filename):
        expect = self.get_expect(filename)
        actual = self.all_in_mem(filename, expect)
>       self.assert_equal(actual, expect)

test_codegen.py:247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_codegen.TestCodeGen object at 0x7f142b146cd0>
actual = testinfo(exitcode=1, execcode=0, output='Traceback (most recent call last):\n  File "./MiniCC.py", line 218, in <modul...y", line 327, in linearize\n    assert(len(block._out) == 1)\nAssertionError\n', linkargs=[], skip_test_expected=False)
expected = testinfo(exitcode=0, execcode=1, output='Division by 0\n', linkargs=[], skip_test_expected=True)

    def assert_equal(self, actual, expected):
        if TYPECHECK_ONLY and expected.exitcode == 0:
            # Compiler does not fail => no output expected
            assert actual.output == "", \
                "Compiler unexpectedly generated some output with --disable-codegen"
            assert actual.exitcode == 0, \
                "Compiler unexpectedly failed with --disable-codegen"
            return
        if DISABLE_TYPECHECK and expected.exitcode != 0:
            # Test should fail at typecheck, and we don't do
            # typechecking => nothing to check.
            pytest.skip("Test that doesn't typecheck with --disable-typecheck")
        if expected.output is not None and actual.output is not None:
>           assert actual.output == expected.output, \
                "Output of the program is incorrect."
E           AssertionError: Output of the program is incorrect.
E           assert ('Traceback (most recent call last):\n'\n '  File "./MiniCC.py", line 218, in <module>\n'\n '    main(args.filename, args.reg_alloc, args.ssa,\n'\n '  File "./MiniCC.py", line 168, in main\n'\n '    cfg.print_code(output, comment=comment)\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code\n'\n '    for i in self.linearize():\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize\n'\n '    assert(len(block._out) == 1)\n'\n 'AssertionError\n') == 'Division by 0\n'
E             - Division by 0
E             + Traceback (most recent call last):
E             +   File "./MiniCC.py", line 218, in <module>
E             +     main(args.filename, args.reg_alloc, args.ssa,
E             +   File "./MiniCC.py", line 168, in main
E             +     cfg.print_code(output, comment=comment)
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
E             +     for i in self.linearize():
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
E             +     assert(len(block._out) == 1)
E             + AssertionError

test_codegen.py:91: AssertionError
----------------------------- Captured stdout call -----------------------------
Compiling ...
/usr/bin/python3 ./MiniCC.py --reg-alloc=all_in_mem --output=./TP04/tests/students/multiplicative/test_multiplicative_div_zero-all_in_mem.s ./TP04/tests/students/multiplicative/test_multiplicative_div_zero.c
Exited with status: 1
Traceback (most recent call last):
  File "./MiniCC.py", line 218, in <module>
    main(args.filename, args.reg_alloc, args.ssa,
  File "./MiniCC.py", line 168, in main
    cfg.print_code(output, comment=comment)
  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
    for i in self.linearize():
  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
    assert(len(block._out) == 1)
AssertionError

_ TestCodeGen.test_alloc_mem[./TP04/tests/students/multiplicative/test_multiplicative_mod_1.c] _

self = <test_codegen.TestCodeGen object at 0x7f142b2080a0>
filename = './TP04/tests/students/multiplicative/test_multiplicative_mod_1.c'

    @pytest.mark.parametrize('filename', ALL_IN_MEM_FILES)
    def test_alloc_mem(self, filename):
        expect = self.get_expect(filename)
        actual = self.all_in_mem(filename, expect)
>       self.assert_equal(actual, expect)

test_codegen.py:247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_codegen.TestCodeGen object at 0x7f142b2080a0>
actual = testinfo(exitcode=1, execcode=0, output='Traceback (most recent call last):\n  File "./MiniCC.py", line 218, in <modul...y", line 327, in linearize\n    assert(len(block._out) == 1)\nAssertionError\n', linkargs=[], skip_test_expected=False)
expected = testinfo(exitcode=0, execcode=0, output='0\n', linkargs=[], skip_test_expected=False)

    def assert_equal(self, actual, expected):
        if TYPECHECK_ONLY and expected.exitcode == 0:
            # Compiler does not fail => no output expected
            assert actual.output == "", \
                "Compiler unexpectedly generated some output with --disable-codegen"
            assert actual.exitcode == 0, \
                "Compiler unexpectedly failed with --disable-codegen"
            return
        if DISABLE_TYPECHECK and expected.exitcode != 0:
            # Test should fail at typecheck, and we don't do
            # typechecking => nothing to check.
            pytest.skip("Test that doesn't typecheck with --disable-typecheck")
        if expected.output is not None and actual.output is not None:
>           assert actual.output == expected.output, \
                "Output of the program is incorrect."
E           AssertionError: Output of the program is incorrect.
E           assert ('Traceback (most recent call last):\n'\n '  File "./MiniCC.py", line 218, in <module>\n'\n '    main(args.filename, args.reg_alloc, args.ssa,\n'\n '  File "./MiniCC.py", line 168, in main\n'\n '    cfg.print_code(output, comment=comment)\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code\n'\n '    for i in self.linearize():\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize\n'\n '    assert(len(block._out) == 1)\n'\n 'AssertionError\n') == '0\n'
E             - 0
E             + Traceback (most recent call last):
E             +   File "./MiniCC.py", line 218, in <module>
E             +     main(args.filename, args.reg_alloc, args.ssa,
E             +   File "./MiniCC.py", line 168, in main
E             +     cfg.print_code(output, comment=comment)
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
E             +     for i in self.linearize():
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
E             +     assert(len(block._out) == 1)
E             + AssertionError

test_codegen.py:91: AssertionError
----------------------------- Captured stdout call -----------------------------
Compiling ...
/usr/bin/python3 ./MiniCC.py --reg-alloc=all_in_mem --output=./TP04/tests/students/multiplicative/test_multiplicative_mod_1-all_in_mem.s ./TP04/tests/students/multiplicative/test_multiplicative_mod_1.c
Exited with status: 1
Traceback (most recent call last):
  File "./MiniCC.py", line 218, in <module>
    main(args.filename, args.reg_alloc, args.ssa,
  File "./MiniCC.py", line 168, in main
    cfg.print_code(output, comment=comment)
  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
    for i in self.linearize():
  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
    assert(len(block._out) == 1)
AssertionError

_ TestCodeGen.test_alloc_mem[./TP04/tests/students/multiplicative/test_multiplicative_mod_2.c] _

self = <test_codegen.TestCodeGen object at 0x7f142b147670>
filename = './TP04/tests/students/multiplicative/test_multiplicative_mod_2.c'

    @pytest.mark.parametrize('filename', ALL_IN_MEM_FILES)
    def test_alloc_mem(self, filename):
        expect = self.get_expect(filename)
        actual = self.all_in_mem(filename, expect)
>       self.assert_equal(actual, expect)

test_codegen.py:247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_codegen.TestCodeGen object at 0x7f142b147670>
actual = testinfo(exitcode=1, execcode=0, output='Traceback (most recent call last):\n  File "./MiniCC.py", line 218, in <modul...y", line 327, in linearize\n    assert(len(block._out) == 1)\nAssertionError\n', linkargs=[], skip_test_expected=False)
expected = testinfo(exitcode=0, execcode=0, output='2\n', linkargs=[], skip_test_expected=False)

    def assert_equal(self, actual, expected):
        if TYPECHECK_ONLY and expected.exitcode == 0:
            # Compiler does not fail => no output expected
            assert actual.output == "", \
                "Compiler unexpectedly generated some output with --disable-codegen"
            assert actual.exitcode == 0, \
                "Compiler unexpectedly failed with --disable-codegen"
            return
        if DISABLE_TYPECHECK and expected.exitcode != 0:
            # Test should fail at typecheck, and we don't do
            # typechecking => nothing to check.
            pytest.skip("Test that doesn't typecheck with --disable-typecheck")
        if expected.output is not None and actual.output is not None:
>           assert actual.output == expected.output, \
                "Output of the program is incorrect."
E           AssertionError: Output of the program is incorrect.
E           assert ('Traceback (most recent call last):\n'\n '  File "./MiniCC.py", line 218, in <module>\n'\n '    main(args.filename, args.reg_alloc, args.ssa,\n'\n '  File "./MiniCC.py", line 168, in main\n'\n '    cfg.print_code(output, comment=comment)\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code\n'\n '    for i in self.linearize():\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize\n'\n '    assert(len(block._out) == 1)\n'\n 'AssertionError\n') == '2\n'
E             - 2
E             + Traceback (most recent call last):
E             +   File "./MiniCC.py", line 218, in <module>
E             +     main(args.filename, args.reg_alloc, args.ssa,
E             +   File "./MiniCC.py", line 168, in main
E             +     cfg.print_code(output, comment=comment)
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
E             +     for i in self.linearize():
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
E             +     assert(len(block._out) == 1)
E             + AssertionError

test_codegen.py:91: AssertionError
----------------------------- Captured stdout call -----------------------------
Compiling ...
/usr/bin/python3 ./MiniCC.py --reg-alloc=all_in_mem --output=./TP04/tests/students/multiplicative/test_multiplicative_mod_2-all_in_mem.s ./TP04/tests/students/multiplicative/test_multiplicative_mod_2.c
Exited with status: 1
Traceback (most recent call last):
  File "./MiniCC.py", line 218, in <module>
    main(args.filename, args.reg_alloc, args.ssa,
  File "./MiniCC.py", line 168, in main
    cfg.print_code(output, comment=comment)
  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
    for i in self.linearize():
  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
    assert(len(block._out) == 1)
AssertionError

_ TestCodeGen.test_alloc_mem[./TP04/tests/students/multiplicative/test_multiplicative_mod_3.c] _

self = <test_codegen.TestCodeGen object at 0x7f142b210940>
filename = './TP04/tests/students/multiplicative/test_multiplicative_mod_3.c'

    @pytest.mark.parametrize('filename', ALL_IN_MEM_FILES)
    def test_alloc_mem(self, filename):
        expect = self.get_expect(filename)
        actual = self.all_in_mem(filename, expect)
>       self.assert_equal(actual, expect)

test_codegen.py:247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_codegen.TestCodeGen object at 0x7f142b210940>
actual = testinfo(exitcode=1, execcode=0, output='Traceback (most recent call last):\n  File "./MiniCC.py", line 218, in <modul...y", line 327, in linearize\n    assert(len(block._out) == 1)\nAssertionError\n', linkargs=[], skip_test_expected=False)
expected = testinfo(exitcode=0, execcode=0, output='0\n', linkargs=[], skip_test_expected=False)

    def assert_equal(self, actual, expected):
        if TYPECHECK_ONLY and expected.exitcode == 0:
            # Compiler does not fail => no output expected
            assert actual.output == "", \
                "Compiler unexpectedly generated some output with --disable-codegen"
            assert actual.exitcode == 0, \
                "Compiler unexpectedly failed with --disable-codegen"
            return
        if DISABLE_TYPECHECK and expected.exitcode != 0:
            # Test should fail at typecheck, and we don't do
            # typechecking => nothing to check.
            pytest.skip("Test that doesn't typecheck with --disable-typecheck")
        if expected.output is not None and actual.output is not None:
>           assert actual.output == expected.output, \
                "Output of the program is incorrect."
E           AssertionError: Output of the program is incorrect.
E           assert ('Traceback (most recent call last):\n'\n '  File "./MiniCC.py", line 218, in <module>\n'\n '    main(args.filename, args.reg_alloc, args.ssa,\n'\n '  File "./MiniCC.py", line 168, in main\n'\n '    cfg.print_code(output, comment=comment)\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code\n'\n '    for i in self.linearize():\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize\n'\n '    assert(len(block._out) == 1)\n'\n 'AssertionError\n') == '0\n'
E             - 0
E             + Traceback (most recent call last):
E             +   File "./MiniCC.py", line 218, in <module>
E             +     main(args.filename, args.reg_alloc, args.ssa,
E             +   File "./MiniCC.py", line 168, in main
E             +     cfg.print_code(output, comment=comment)
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
E             +     for i in self.linearize():
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
E             +     assert(len(block._out) == 1)
E             + AssertionError

test_codegen.py:91: AssertionError
----------------------------- Captured stdout call -----------------------------
Compiling ...
/usr/bin/python3 ./MiniCC.py --reg-alloc=all_in_mem --output=./TP04/tests/students/multiplicative/test_multiplicative_mod_3-all_in_mem.s ./TP04/tests/students/multiplicative/test_multiplicative_mod_3.c
Exited with status: 1
Traceback (most recent call last):
  File "./MiniCC.py", line 218, in <module>
    main(args.filename, args.reg_alloc, args.ssa,
  File "./MiniCC.py", line 168, in main
    cfg.print_code(output, comment=comment)
  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
    for i in self.linearize():
  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
    assert(len(block._out) == 1)
AssertionError

_ TestCodeGen.test_alloc_mem[./TP04/tests/students/multiplicative/test_multiplicative_mod_zero.c] _

self = <test_codegen.TestCodeGen object at 0x7f142b151520>
filename = './TP04/tests/students/multiplicative/test_multiplicative_mod_zero.c'

    @pytest.mark.parametrize('filename', ALL_IN_MEM_FILES)
    def test_alloc_mem(self, filename):
        expect = self.get_expect(filename)
        actual = self.all_in_mem(filename, expect)
>       self.assert_equal(actual, expect)

test_codegen.py:247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_codegen.TestCodeGen object at 0x7f142b151520>
actual = testinfo(exitcode=1, execcode=0, output='Traceback (most recent call last):\n  File "./MiniCC.py", line 218, in <modul...y", line 327, in linearize\n    assert(len(block._out) == 1)\nAssertionError\n', linkargs=[], skip_test_expected=False)
expected = testinfo(exitcode=0, execcode=1, output='Division by 0\n', linkargs=[], skip_test_expected=True)

    def assert_equal(self, actual, expected):
        if TYPECHECK_ONLY and expected.exitcode == 0:
            # Compiler does not fail => no output expected
            assert actual.output == "", \
                "Compiler unexpectedly generated some output with --disable-codegen"
            assert actual.exitcode == 0, \
                "Compiler unexpectedly failed with --disable-codegen"
            return
        if DISABLE_TYPECHECK and expected.exitcode != 0:
            # Test should fail at typecheck, and we don't do
            # typechecking => nothing to check.
            pytest.skip("Test that doesn't typecheck with --disable-typecheck")
        if expected.output is not None and actual.output is not None:
>           assert actual.output == expected.output, \
                "Output of the program is incorrect."
E           AssertionError: Output of the program is incorrect.
E           assert ('Traceback (most recent call last):\n'\n '  File "./MiniCC.py", line 218, in <module>\n'\n '    main(args.filename, args.reg_alloc, args.ssa,\n'\n '  File "./MiniCC.py", line 168, in main\n'\n '    cfg.print_code(output, comment=comment)\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code\n'\n '    for i in self.linearize():\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize\n'\n '    assert(len(block._out) == 1)\n'\n 'AssertionError\n') == 'Division by 0\n'
E             - Division by 0
E             + Traceback (most recent call last):
E             +   File "./MiniCC.py", line 218, in <module>
E             +     main(args.filename, args.reg_alloc, args.ssa,
E             +   File "./MiniCC.py", line 168, in main
E             +     cfg.print_code(output, comment=comment)
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
E             +     for i in self.linearize():
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
E             +     assert(len(block._out) == 1)
E             + AssertionError

test_codegen.py:91: AssertionError
----------------------------- Captured stdout call -----------------------------
Compiling ...
/usr/bin/python3 ./MiniCC.py --reg-alloc=all_in_mem --output=./TP04/tests/students/multiplicative/test_multiplicative_mod_zero-all_in_mem.s ./TP04/tests/students/multiplicative/test_multiplicative_mod_zero.c
Exited with status: 1
Traceback (most recent call last):
  File "./MiniCC.py", line 218, in <module>
    main(args.filename, args.reg_alloc, args.ssa,
  File "./MiniCC.py", line 168, in main
    cfg.print_code(output, comment=comment)
  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
    for i in self.linearize():
  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
    assert(len(block._out) == 1)
AssertionError

______ TestCodeGen.test_alloc_mem[./TP04/tests/students/not/test_not_1.c] ______

self = <test_codegen.TestCodeGen object at 0x7f142b122430>
filename = './TP04/tests/students/not/test_not_1.c'

    @pytest.mark.parametrize('filename', ALL_IN_MEM_FILES)
    def test_alloc_mem(self, filename):
        expect = self.get_expect(filename)
        actual = self.all_in_mem(filename, expect)
>       self.assert_equal(actual, expect)

test_codegen.py:247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_codegen.TestCodeGen object at 0x7f142b122430>
actual = testinfo(exitcode=1, execcode=0, output='Traceback (most recent call last):\n  File "./MiniCC.py", line 218, in <modul...y", line 327, in linearize\n    assert(len(block._out) == 1)\nAssertionError\n', linkargs=[], skip_test_expected=False)
expected = testinfo(exitcode=0, execcode=0, output='0\n', linkargs=[], skip_test_expected=False)

    def assert_equal(self, actual, expected):
        if TYPECHECK_ONLY and expected.exitcode == 0:
            # Compiler does not fail => no output expected
            assert actual.output == "", \
                "Compiler unexpectedly generated some output with --disable-codegen"
            assert actual.exitcode == 0, \
                "Compiler unexpectedly failed with --disable-codegen"
            return
        if DISABLE_TYPECHECK and expected.exitcode != 0:
            # Test should fail at typecheck, and we don't do
            # typechecking => nothing to check.
            pytest.skip("Test that doesn't typecheck with --disable-typecheck")
        if expected.output is not None and actual.output is not None:
>           assert actual.output == expected.output, \
                "Output of the program is incorrect."
E           AssertionError: Output of the program is incorrect.
E           assert ('Traceback (most recent call last):\n'\n '  File "./MiniCC.py", line 218, in <module>\n'\n '    main(args.filename, args.reg_alloc, args.ssa,\n'\n '  File "./MiniCC.py", line 168, in main\n'\n '    cfg.print_code(output, comment=comment)\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code\n'\n '    for i in self.linearize():\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize\n'\n '    assert(len(block._out) == 1)\n'\n 'AssertionError\n') == '0\n'
E             - 0
E             + Traceback (most recent call last):
E             +   File "./MiniCC.py", line 218, in <module>
E             +     main(args.filename, args.reg_alloc, args.ssa,
E             +   File "./MiniCC.py", line 168, in main
E             +     cfg.print_code(output, comment=comment)
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
E             +     for i in self.linearize():
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
E             +     assert(len(block._out) == 1)
E             + AssertionError

test_codegen.py:91: AssertionError
----------------------------- Captured stdout call -----------------------------
Compiling ...
/usr/bin/python3 ./MiniCC.py --reg-alloc=all_in_mem --output=./TP04/tests/students/not/test_not_1-all_in_mem.s ./TP04/tests/students/not/test_not_1.c
Exited with status: 1
Traceback (most recent call last):
  File "./MiniCC.py", line 218, in <module>
    main(args.filename, args.reg_alloc, args.ssa,
  File "./MiniCC.py", line 168, in main
    cfg.print_code(output, comment=comment)
  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
    for i in self.linearize():
  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
    assert(len(block._out) == 1)
AssertionError

______ TestCodeGen.test_alloc_mem[./TP04/tests/students/not/test_not_2.c] ______

self = <test_codegen.TestCodeGen object at 0x7f142b1ffc10>
filename = './TP04/tests/students/not/test_not_2.c'

    @pytest.mark.parametrize('filename', ALL_IN_MEM_FILES)
    def test_alloc_mem(self, filename):
        expect = self.get_expect(filename)
        actual = self.all_in_mem(filename, expect)
>       self.assert_equal(actual, expect)

test_codegen.py:247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_codegen.TestCodeGen object at 0x7f142b1ffc10>
actual = testinfo(exitcode=1, execcode=0, output='Traceback (most recent call last):\n  File "./MiniCC.py", line 218, in <modul...y", line 327, in linearize\n    assert(len(block._out) == 1)\nAssertionError\n', linkargs=[], skip_test_expected=False)
expected = testinfo(exitcode=0, execcode=0, output='1\n', linkargs=[], skip_test_expected=False)

    def assert_equal(self, actual, expected):
        if TYPECHECK_ONLY and expected.exitcode == 0:
            # Compiler does not fail => no output expected
            assert actual.output == "", \
                "Compiler unexpectedly generated some output with --disable-codegen"
            assert actual.exitcode == 0, \
                "Compiler unexpectedly failed with --disable-codegen"
            return
        if DISABLE_TYPECHECK and expected.exitcode != 0:
            # Test should fail at typecheck, and we don't do
            # typechecking => nothing to check.
            pytest.skip("Test that doesn't typecheck with --disable-typecheck")
        if expected.output is not None and actual.output is not None:
>           assert actual.output == expected.output, \
                "Output of the program is incorrect."
E           AssertionError: Output of the program is incorrect.
E           assert ('Traceback (most recent call last):\n'\n '  File "./MiniCC.py", line 218, in <module>\n'\n '    main(args.filename, args.reg_alloc, args.ssa,\n'\n '  File "./MiniCC.py", line 168, in main\n'\n '    cfg.print_code(output, comment=comment)\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code\n'\n '    for i in self.linearize():\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize\n'\n '    assert(len(block._out) == 1)\n'\n 'AssertionError\n') == '1\n'
E             - 1
E             + Traceback (most recent call last):
E             +   File "./MiniCC.py", line 218, in <module>
E             +     main(args.filename, args.reg_alloc, args.ssa,
E             +   File "./MiniCC.py", line 168, in main
E             +     cfg.print_code(output, comment=comment)
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
E             +     for i in self.linearize():
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
E             +     assert(len(block._out) == 1)
E             + AssertionError

test_codegen.py:91: AssertionError
----------------------------- Captured stdout call -----------------------------
Compiling ...
/usr/bin/python3 ./MiniCC.py --reg-alloc=all_in_mem --output=./TP04/tests/students/not/test_not_2-all_in_mem.s ./TP04/tests/students/not/test_not_2.c
Exited with status: 1
Traceback (most recent call last):
  File "./MiniCC.py", line 218, in <module>
    main(args.filename, args.reg_alloc, args.ssa,
  File "./MiniCC.py", line 168, in main
    cfg.print_code(output, comment=comment)
  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
    for i in self.linearize():
  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
    assert(len(block._out) == 1)
AssertionError

______ TestCodeGen.test_alloc_mem[./TP04/tests/students/not/test_not_3.c] ______

self = <test_codegen.TestCodeGen object at 0x7f142b2154c0>
filename = './TP04/tests/students/not/test_not_3.c'

    @pytest.mark.parametrize('filename', ALL_IN_MEM_FILES)
    def test_alloc_mem(self, filename):
        expect = self.get_expect(filename)
        actual = self.all_in_mem(filename, expect)
>       self.assert_equal(actual, expect)

test_codegen.py:247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_codegen.TestCodeGen object at 0x7f142b2154c0>
actual = testinfo(exitcode=1, execcode=0, output='Traceback (most recent call last):\n  File "./MiniCC.py", line 218, in <modul...y", line 327, in linearize\n    assert(len(block._out) == 1)\nAssertionError\n', linkargs=[], skip_test_expected=False)
expected = testinfo(exitcode=0, execcode=0, output='1\n', linkargs=[], skip_test_expected=False)

    def assert_equal(self, actual, expected):
        if TYPECHECK_ONLY and expected.exitcode == 0:
            # Compiler does not fail => no output expected
            assert actual.output == "", \
                "Compiler unexpectedly generated some output with --disable-codegen"
            assert actual.exitcode == 0, \
                "Compiler unexpectedly failed with --disable-codegen"
            return
        if DISABLE_TYPECHECK and expected.exitcode != 0:
            # Test should fail at typecheck, and we don't do
            # typechecking => nothing to check.
            pytest.skip("Test that doesn't typecheck with --disable-typecheck")
        if expected.output is not None and actual.output is not None:
>           assert actual.output == expected.output, \
                "Output of the program is incorrect."
E           AssertionError: Output of the program is incorrect.
E           assert ('Traceback (most recent call last):\n'\n '  File "./MiniCC.py", line 218, in <module>\n'\n '    main(args.filename, args.reg_alloc, args.ssa,\n'\n '  File "./MiniCC.py", line 168, in main\n'\n '    cfg.print_code(output, comment=comment)\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code\n'\n '    for i in self.linearize():\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize\n'\n '    assert(len(block._out) == 1)\n'\n 'AssertionError\n') == '1\n'
E             - 1
E             + Traceback (most recent call last):
E             +   File "./MiniCC.py", line 218, in <module>
E             +     main(args.filename, args.reg_alloc, args.ssa,
E             +   File "./MiniCC.py", line 168, in main
E             +     cfg.print_code(output, comment=comment)
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
E             +     for i in self.linearize():
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
E             +     assert(len(block._out) == 1)
E             + AssertionError

test_codegen.py:91: AssertionError
----------------------------- Captured stdout call -----------------------------
Compiling ...
/usr/bin/python3 ./MiniCC.py --reg-alloc=all_in_mem --output=./TP04/tests/students/not/test_not_3-all_in_mem.s ./TP04/tests/students/not/test_not_3.c
Exited with status: 1
Traceback (most recent call last):
  File "./MiniCC.py", line 218, in <module>
    main(args.filename, args.reg_alloc, args.ssa,
  File "./MiniCC.py", line 168, in main
    cfg.print_code(output, comment=comment)
  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
    for i in self.linearize():
  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
    assert(len(block._out) == 1)
AssertionError

______ TestCodeGen.test_alloc_mem[./TP04/tests/students/not/test_not_4.c] ______

self = <test_codegen.TestCodeGen object at 0x7f142b150d90>
filename = './TP04/tests/students/not/test_not_4.c'

    @pytest.mark.parametrize('filename', ALL_IN_MEM_FILES)
    def test_alloc_mem(self, filename):
        expect = self.get_expect(filename)
        actual = self.all_in_mem(filename, expect)
>       self.assert_equal(actual, expect)

test_codegen.py:247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_codegen.TestCodeGen object at 0x7f142b150d90>
actual = testinfo(exitcode=1, execcode=0, output='Traceback (most recent call last):\n  File "./MiniCC.py", line 218, in <modul...y", line 327, in linearize\n    assert(len(block._out) == 1)\nAssertionError\n', linkargs=[], skip_test_expected=False)
expected = testinfo(exitcode=0, execcode=0, output='0\n', linkargs=[], skip_test_expected=False)

    def assert_equal(self, actual, expected):
        if TYPECHECK_ONLY and expected.exitcode == 0:
            # Compiler does not fail => no output expected
            assert actual.output == "", \
                "Compiler unexpectedly generated some output with --disable-codegen"
            assert actual.exitcode == 0, \
                "Compiler unexpectedly failed with --disable-codegen"
            return
        if DISABLE_TYPECHECK and expected.exitcode != 0:
            # Test should fail at typecheck, and we don't do
            # typechecking => nothing to check.
            pytest.skip("Test that doesn't typecheck with --disable-typecheck")
        if expected.output is not None and actual.output is not None:
>           assert actual.output == expected.output, \
                "Output of the program is incorrect."
E           AssertionError: Output of the program is incorrect.
E           assert ('Traceback (most recent call last):\n'\n '  File "./MiniCC.py", line 218, in <module>\n'\n '    main(args.filename, args.reg_alloc, args.ssa,\n'\n '  File "./MiniCC.py", line 168, in main\n'\n '    cfg.print_code(output, comment=comment)\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code\n'\n '    for i in self.linearize():\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize\n'\n '    assert(len(block._out) == 1)\n'\n 'AssertionError\n') == '0\n'
E             - 0
E             + Traceback (most recent call last):
E             +   File "./MiniCC.py", line 218, in <module>
E             +     main(args.filename, args.reg_alloc, args.ssa,
E             +   File "./MiniCC.py", line 168, in main
E             +     cfg.print_code(output, comment=comment)
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
E             +     for i in self.linearize():
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
E             +     assert(len(block._out) == 1)
E             + AssertionError

test_codegen.py:91: AssertionError
----------------------------- Captured stdout call -----------------------------
Compiling ...
/usr/bin/python3 ./MiniCC.py --reg-alloc=all_in_mem --output=./TP04/tests/students/not/test_not_4-all_in_mem.s ./TP04/tests/students/not/test_not_4.c
Exited with status: 1
Traceback (most recent call last):
  File "./MiniCC.py", line 218, in <module>
    main(args.filename, args.reg_alloc, args.ssa,
  File "./MiniCC.py", line 168, in main
    cfg.print_code(output, comment=comment)
  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
    for i in self.linearize():
  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
    assert(len(block._out) == 1)
AssertionError

_______ TestCodeGen.test_alloc_mem[./TP04/tests/students/or/test_or_1.c] _______

self = <test_codegen.TestCodeGen object at 0x7f142b190700>
filename = './TP04/tests/students/or/test_or_1.c'

    @pytest.mark.parametrize('filename', ALL_IN_MEM_FILES)
    def test_alloc_mem(self, filename):
        expect = self.get_expect(filename)
        actual = self.all_in_mem(filename, expect)
>       self.assert_equal(actual, expect)

test_codegen.py:247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_codegen.TestCodeGen object at 0x7f142b190700>
actual = testinfo(exitcode=1, execcode=0, output='Traceback (most recent call last):\n  File "./MiniCC.py", line 218, in <modul...y", line 327, in linearize\n    assert(len(block._out) == 1)\nAssertionError\n', linkargs=[], skip_test_expected=False)
expected = testinfo(exitcode=0, execcode=0, output='1\n', linkargs=[], skip_test_expected=False)

    def assert_equal(self, actual, expected):
        if TYPECHECK_ONLY and expected.exitcode == 0:
            # Compiler does not fail => no output expected
            assert actual.output == "", \
                "Compiler unexpectedly generated some output with --disable-codegen"
            assert actual.exitcode == 0, \
                "Compiler unexpectedly failed with --disable-codegen"
            return
        if DISABLE_TYPECHECK and expected.exitcode != 0:
            # Test should fail at typecheck, and we don't do
            # typechecking => nothing to check.
            pytest.skip("Test that doesn't typecheck with --disable-typecheck")
        if expected.output is not None and actual.output is not None:
>           assert actual.output == expected.output, \
                "Output of the program is incorrect."
E           AssertionError: Output of the program is incorrect.
E           assert ('Traceback (most recent call last):\n'\n '  File "./MiniCC.py", line 218, in <module>\n'\n '    main(args.filename, args.reg_alloc, args.ssa,\n'\n '  File "./MiniCC.py", line 168, in main\n'\n '    cfg.print_code(output, comment=comment)\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code\n'\n '    for i in self.linearize():\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize\n'\n '    assert(len(block._out) == 1)\n'\n 'AssertionError\n') == '1\n'
E             - 1
E             + Traceback (most recent call last):
E             +   File "./MiniCC.py", line 218, in <module>
E             +     main(args.filename, args.reg_alloc, args.ssa,
E             +   File "./MiniCC.py", line 168, in main
E             +     cfg.print_code(output, comment=comment)
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
E             +     for i in self.linearize():
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
E             +     assert(len(block._out) == 1)
E             + AssertionError

test_codegen.py:91: AssertionError
----------------------------- Captured stdout call -----------------------------
Compiling ...
/usr/bin/python3 ./MiniCC.py --reg-alloc=all_in_mem --output=./TP04/tests/students/or/test_or_1-all_in_mem.s ./TP04/tests/students/or/test_or_1.c
Exited with status: 1
Traceback (most recent call last):
  File "./MiniCC.py", line 218, in <module>
    main(args.filename, args.reg_alloc, args.ssa,
  File "./MiniCC.py", line 168, in main
    cfg.print_code(output, comment=comment)
  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
    for i in self.linearize():
  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
    assert(len(block._out) == 1)
AssertionError

_______ TestCodeGen.test_alloc_mem[./TP04/tests/students/or/test_or_2.c] _______

self = <test_codegen.TestCodeGen object at 0x7f142b208a60>
filename = './TP04/tests/students/or/test_or_2.c'

    @pytest.mark.parametrize('filename', ALL_IN_MEM_FILES)
    def test_alloc_mem(self, filename):
        expect = self.get_expect(filename)
        actual = self.all_in_mem(filename, expect)
>       self.assert_equal(actual, expect)

test_codegen.py:247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_codegen.TestCodeGen object at 0x7f142b208a60>
actual = testinfo(exitcode=1, execcode=0, output='Traceback (most recent call last):\n  File "./MiniCC.py", line 218, in <modul...y", line 327, in linearize\n    assert(len(block._out) == 1)\nAssertionError\n', linkargs=[], skip_test_expected=False)
expected = testinfo(exitcode=0, execcode=0, output='1\n', linkargs=[], skip_test_expected=False)

    def assert_equal(self, actual, expected):
        if TYPECHECK_ONLY and expected.exitcode == 0:
            # Compiler does not fail => no output expected
            assert actual.output == "", \
                "Compiler unexpectedly generated some output with --disable-codegen"
            assert actual.exitcode == 0, \
                "Compiler unexpectedly failed with --disable-codegen"
            return
        if DISABLE_TYPECHECK and expected.exitcode != 0:
            # Test should fail at typecheck, and we don't do
            # typechecking => nothing to check.
            pytest.skip("Test that doesn't typecheck with --disable-typecheck")
        if expected.output is not None and actual.output is not None:
>           assert actual.output == expected.output, \
                "Output of the program is incorrect."
E           AssertionError: Output of the program is incorrect.
E           assert ('Traceback (most recent call last):\n'\n '  File "./MiniCC.py", line 218, in <module>\n'\n '    main(args.filename, args.reg_alloc, args.ssa,\n'\n '  File "./MiniCC.py", line 168, in main\n'\n '    cfg.print_code(output, comment=comment)\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code\n'\n '    for i in self.linearize():\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize\n'\n '    assert(len(block._out) == 1)\n'\n 'AssertionError\n') == '1\n'
E             - 1
E             + Traceback (most recent call last):
E             +   File "./MiniCC.py", line 218, in <module>
E             +     main(args.filename, args.reg_alloc, args.ssa,
E             +   File "./MiniCC.py", line 168, in main
E             +     cfg.print_code(output, comment=comment)
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
E             +     for i in self.linearize():
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
E             +     assert(len(block._out) == 1)
E             + AssertionError

test_codegen.py:91: AssertionError
----------------------------- Captured stdout call -----------------------------
Compiling ...
/usr/bin/python3 ./MiniCC.py --reg-alloc=all_in_mem --output=./TP04/tests/students/or/test_or_2-all_in_mem.s ./TP04/tests/students/or/test_or_2.c
Exited with status: 1
Traceback (most recent call last):
  File "./MiniCC.py", line 218, in <module>
    main(args.filename, args.reg_alloc, args.ssa,
  File "./MiniCC.py", line 168, in main
    cfg.print_code(output, comment=comment)
  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
    for i in self.linearize():
  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
    assert(len(block._out) == 1)
AssertionError

_______ TestCodeGen.test_alloc_mem[./TP04/tests/students/or/test_or_3.c] _______

self = <test_codegen.TestCodeGen object at 0x7f142b1666d0>
filename = './TP04/tests/students/or/test_or_3.c'

    @pytest.mark.parametrize('filename', ALL_IN_MEM_FILES)
    def test_alloc_mem(self, filename):
        expect = self.get_expect(filename)
        actual = self.all_in_mem(filename, expect)
>       self.assert_equal(actual, expect)

test_codegen.py:247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_codegen.TestCodeGen object at 0x7f142b1666d0>
actual = testinfo(exitcode=1, execcode=0, output='Traceback (most recent call last):\n  File "./MiniCC.py", line 218, in <modul...y", line 327, in linearize\n    assert(len(block._out) == 1)\nAssertionError\n', linkargs=[], skip_test_expected=False)
expected = testinfo(exitcode=0, execcode=0, output='0\n', linkargs=[], skip_test_expected=False)

    def assert_equal(self, actual, expected):
        if TYPECHECK_ONLY and expected.exitcode == 0:
            # Compiler does not fail => no output expected
            assert actual.output == "", \
                "Compiler unexpectedly generated some output with --disable-codegen"
            assert actual.exitcode == 0, \
                "Compiler unexpectedly failed with --disable-codegen"
            return
        if DISABLE_TYPECHECK and expected.exitcode != 0:
            # Test should fail at typecheck, and we don't do
            # typechecking => nothing to check.
            pytest.skip("Test that doesn't typecheck with --disable-typecheck")
        if expected.output is not None and actual.output is not None:
>           assert actual.output == expected.output, \
                "Output of the program is incorrect."
E           AssertionError: Output of the program is incorrect.
E           assert ('Traceback (most recent call last):\n'\n '  File "./MiniCC.py", line 218, in <module>\n'\n '    main(args.filename, args.reg_alloc, args.ssa,\n'\n '  File "./MiniCC.py", line 168, in main\n'\n '    cfg.print_code(output, comment=comment)\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code\n'\n '    for i in self.linearize():\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize\n'\n '    assert(len(block._out) == 1)\n'\n 'AssertionError\n') == '0\n'
E             - 0
E             + Traceback (most recent call last):
E             +   File "./MiniCC.py", line 218, in <module>
E             +     main(args.filename, args.reg_alloc, args.ssa,
E             +   File "./MiniCC.py", line 168, in main
E             +     cfg.print_code(output, comment=comment)
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
E             +     for i in self.linearize():
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
E             +     assert(len(block._out) == 1)
E             + AssertionError

test_codegen.py:91: AssertionError
----------------------------- Captured stdout call -----------------------------
Compiling ...
/usr/bin/python3 ./MiniCC.py --reg-alloc=all_in_mem --output=./TP04/tests/students/or/test_or_3-all_in_mem.s ./TP04/tests/students/or/test_or_3.c
Exited with status: 1
Traceback (most recent call last):
  File "./MiniCC.py", line 218, in <module>
    main(args.filename, args.reg_alloc, args.ssa,
  File "./MiniCC.py", line 168, in main
    cfg.print_code(output, comment=comment)
  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
    for i in self.linearize():
  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
    assert(len(block._out) == 1)
AssertionError

_ TestCodeGen.test_alloc_mem[./TP04/tests/students/relational/equal/test_equality_int_false.c] _

self = <test_codegen.TestCodeGen object at 0x7f142b2103a0>
filename = './TP04/tests/students/relational/equal/test_equality_int_false.c'

    @pytest.mark.parametrize('filename', ALL_IN_MEM_FILES)
    def test_alloc_mem(self, filename):
        expect = self.get_expect(filename)
        actual = self.all_in_mem(filename, expect)
>       self.assert_equal(actual, expect)

test_codegen.py:247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_codegen.TestCodeGen object at 0x7f142b2103a0>
actual = testinfo(exitcode=1, execcode=0, output='Traceback (most recent call last):\n  File "./MiniCC.py", line 218, in <modul...y", line 327, in linearize\n    assert(len(block._out) == 1)\nAssertionError\n', linkargs=[], skip_test_expected=False)
expected = testinfo(exitcode=0, execcode=0, output='0\n', linkargs=[], skip_test_expected=False)

    def assert_equal(self, actual, expected):
        if TYPECHECK_ONLY and expected.exitcode == 0:
            # Compiler does not fail => no output expected
            assert actual.output == "", \
                "Compiler unexpectedly generated some output with --disable-codegen"
            assert actual.exitcode == 0, \
                "Compiler unexpectedly failed with --disable-codegen"
            return
        if DISABLE_TYPECHECK and expected.exitcode != 0:
            # Test should fail at typecheck, and we don't do
            # typechecking => nothing to check.
            pytest.skip("Test that doesn't typecheck with --disable-typecheck")
        if expected.output is not None and actual.output is not None:
>           assert actual.output == expected.output, \
                "Output of the program is incorrect."
E           AssertionError: Output of the program is incorrect.
E           assert ('Traceback (most recent call last):\n'\n '  File "./MiniCC.py", line 218, in <module>\n'\n '    main(args.filename, args.reg_alloc, args.ssa,\n'\n '  File "./MiniCC.py", line 168, in main\n'\n '    cfg.print_code(output, comment=comment)\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code\n'\n '    for i in self.linearize():\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize\n'\n '    assert(len(block._out) == 1)\n'\n 'AssertionError\n') == '0\n'
E             - 0
E             + Traceback (most recent call last):
E             +   File "./MiniCC.py", line 218, in <module>
E             +     main(args.filename, args.reg_alloc, args.ssa,
E             +   File "./MiniCC.py", line 168, in main
E             +     cfg.print_code(output, comment=comment)
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
E             +     for i in self.linearize():
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
E             +     assert(len(block._out) == 1)
E             + AssertionError

test_codegen.py:91: AssertionError
----------------------------- Captured stdout call -----------------------------
Compiling ...
/usr/bin/python3 ./MiniCC.py --reg-alloc=all_in_mem --output=./TP04/tests/students/relational/equal/test_equality_int_false-all_in_mem.s ./TP04/tests/students/relational/equal/test_equality_int_false.c
Exited with status: 1
Traceback (most recent call last):
  File "./MiniCC.py", line 218, in <module>
    main(args.filename, args.reg_alloc, args.ssa,
  File "./MiniCC.py", line 168, in main
    cfg.print_code(output, comment=comment)
  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
    for i in self.linearize():
  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
    assert(len(block._out) == 1)
AssertionError

_ TestCodeGen.test_alloc_mem[./TP04/tests/students/relational/equal/test_equality_int_true.c] _

self = <test_codegen.TestCodeGen object at 0x7f142b160d60>
filename = './TP04/tests/students/relational/equal/test_equality_int_true.c'

    @pytest.mark.parametrize('filename', ALL_IN_MEM_FILES)
    def test_alloc_mem(self, filename):
        expect = self.get_expect(filename)
        actual = self.all_in_mem(filename, expect)
>       self.assert_equal(actual, expect)

test_codegen.py:247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_codegen.TestCodeGen object at 0x7f142b160d60>
actual = testinfo(exitcode=1, execcode=0, output='Traceback (most recent call last):\n  File "./MiniCC.py", line 218, in <modul...y", line 327, in linearize\n    assert(len(block._out) == 1)\nAssertionError\n', linkargs=[], skip_test_expected=False)
expected = testinfo(exitcode=0, execcode=0, output='1\n', linkargs=[], skip_test_expected=False)

    def assert_equal(self, actual, expected):
        if TYPECHECK_ONLY and expected.exitcode == 0:
            # Compiler does not fail => no output expected
            assert actual.output == "", \
                "Compiler unexpectedly generated some output with --disable-codegen"
            assert actual.exitcode == 0, \
                "Compiler unexpectedly failed with --disable-codegen"
            return
        if DISABLE_TYPECHECK and expected.exitcode != 0:
            # Test should fail at typecheck, and we don't do
            # typechecking => nothing to check.
            pytest.skip("Test that doesn't typecheck with --disable-typecheck")
        if expected.output is not None and actual.output is not None:
>           assert actual.output == expected.output, \
                "Output of the program is incorrect."
E           AssertionError: Output of the program is incorrect.
E           assert ('Traceback (most recent call last):\n'\n '  File "./MiniCC.py", line 218, in <module>\n'\n '    main(args.filename, args.reg_alloc, args.ssa,\n'\n '  File "./MiniCC.py", line 168, in main\n'\n '    cfg.print_code(output, comment=comment)\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code\n'\n '    for i in self.linearize():\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize\n'\n '    assert(len(block._out) == 1)\n'\n 'AssertionError\n') == '1\n'
E             - 1
E             + Traceback (most recent call last):
E             +   File "./MiniCC.py", line 218, in <module>
E             +     main(args.filename, args.reg_alloc, args.ssa,
E             +   File "./MiniCC.py", line 168, in main
E             +     cfg.print_code(output, comment=comment)
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
E             +     for i in self.linearize():
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
E             +     assert(len(block._out) == 1)
E             + AssertionError

test_codegen.py:91: AssertionError
----------------------------- Captured stdout call -----------------------------
Compiling ...
/usr/bin/python3 ./MiniCC.py --reg-alloc=all_in_mem --output=./TP04/tests/students/relational/equal/test_equality_int_true-all_in_mem.s ./TP04/tests/students/relational/equal/test_equality_int_true.c
Exited with status: 1
Traceback (most recent call last):
  File "./MiniCC.py", line 218, in <module>
    main(args.filename, args.reg_alloc, args.ssa,
  File "./MiniCC.py", line 168, in main
    cfg.print_code(output, comment=comment)
  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
    for i in self.linearize():
  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
    assert(len(block._out) == 1)
AssertionError

_ TestCodeGen.test_alloc_mem[./TP04/tests/students/relational/greater/test_greater_int_false.c] _

self = <test_codegen.TestCodeGen object at 0x7f142b1471f0>
filename = './TP04/tests/students/relational/greater/test_greater_int_false.c'

    @pytest.mark.parametrize('filename', ALL_IN_MEM_FILES)
    def test_alloc_mem(self, filename):
        expect = self.get_expect(filename)
        actual = self.all_in_mem(filename, expect)
>       self.assert_equal(actual, expect)

test_codegen.py:247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_codegen.TestCodeGen object at 0x7f142b1471f0>
actual = testinfo(exitcode=1, execcode=0, output='Traceback (most recent call last):\n  File "./MiniCC.py", line 218, in <modul...y", line 327, in linearize\n    assert(len(block._out) == 1)\nAssertionError\n', linkargs=[], skip_test_expected=False)
expected = testinfo(exitcode=0, execcode=0, output='0\n', linkargs=[], skip_test_expected=False)

    def assert_equal(self, actual, expected):
        if TYPECHECK_ONLY and expected.exitcode == 0:
            # Compiler does not fail => no output expected
            assert actual.output == "", \
                "Compiler unexpectedly generated some output with --disable-codegen"
            assert actual.exitcode == 0, \
                "Compiler unexpectedly failed with --disable-codegen"
            return
        if DISABLE_TYPECHECK and expected.exitcode != 0:
            # Test should fail at typecheck, and we don't do
            # typechecking => nothing to check.
            pytest.skip("Test that doesn't typecheck with --disable-typecheck")
        if expected.output is not None and actual.output is not None:
>           assert actual.output == expected.output, \
                "Output of the program is incorrect."
E           AssertionError: Output of the program is incorrect.
E           assert ('Traceback (most recent call last):\n'\n '  File "./MiniCC.py", line 218, in <module>\n'\n '    main(args.filename, args.reg_alloc, args.ssa,\n'\n '  File "./MiniCC.py", line 168, in main\n'\n '    cfg.print_code(output, comment=comment)\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code\n'\n '    for i in self.linearize():\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize\n'\n '    assert(len(block._out) == 1)\n'\n 'AssertionError\n') == '0\n'
E             - 0
E             + Traceback (most recent call last):
E             +   File "./MiniCC.py", line 218, in <module>
E             +     main(args.filename, args.reg_alloc, args.ssa,
E             +   File "./MiniCC.py", line 168, in main
E             +     cfg.print_code(output, comment=comment)
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
E             +     for i in self.linearize():
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
E             +     assert(len(block._out) == 1)
E             + AssertionError

test_codegen.py:91: AssertionError
----------------------------- Captured stdout call -----------------------------
Compiling ...
/usr/bin/python3 ./MiniCC.py --reg-alloc=all_in_mem --output=./TP04/tests/students/relational/greater/test_greater_int_false-all_in_mem.s ./TP04/tests/students/relational/greater/test_greater_int_false.c
Exited with status: 1
Traceback (most recent call last):
  File "./MiniCC.py", line 218, in <module>
    main(args.filename, args.reg_alloc, args.ssa,
  File "./MiniCC.py", line 168, in main
    cfg.print_code(output, comment=comment)
  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
    for i in self.linearize():
  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
    assert(len(block._out) == 1)
AssertionError

_ TestCodeGen.test_alloc_mem[./TP04/tests/students/relational/greater/test_greater_int_true.c] _

self = <test_codegen.TestCodeGen object at 0x7f142b215670>
filename = './TP04/tests/students/relational/greater/test_greater_int_true.c'

    @pytest.mark.parametrize('filename', ALL_IN_MEM_FILES)
    def test_alloc_mem(self, filename):
        expect = self.get_expect(filename)
        actual = self.all_in_mem(filename, expect)
>       self.assert_equal(actual, expect)

test_codegen.py:247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_codegen.TestCodeGen object at 0x7f142b215670>
actual = testinfo(exitcode=1, execcode=0, output='Traceback (most recent call last):\n  File "./MiniCC.py", line 218, in <modul...y", line 327, in linearize\n    assert(len(block._out) == 1)\nAssertionError\n', linkargs=[], skip_test_expected=False)
expected = testinfo(exitcode=0, execcode=0, output='1\n', linkargs=[], skip_test_expected=False)

    def assert_equal(self, actual, expected):
        if TYPECHECK_ONLY and expected.exitcode == 0:
            # Compiler does not fail => no output expected
            assert actual.output == "", \
                "Compiler unexpectedly generated some output with --disable-codegen"
            assert actual.exitcode == 0, \
                "Compiler unexpectedly failed with --disable-codegen"
            return
        if DISABLE_TYPECHECK and expected.exitcode != 0:
            # Test should fail at typecheck, and we don't do
            # typechecking => nothing to check.
            pytest.skip("Test that doesn't typecheck with --disable-typecheck")
        if expected.output is not None and actual.output is not None:
>           assert actual.output == expected.output, \
                "Output of the program is incorrect."
E           AssertionError: Output of the program is incorrect.
E           assert ('Traceback (most recent call last):\n'\n '  File "./MiniCC.py", line 218, in <module>\n'\n '    main(args.filename, args.reg_alloc, args.ssa,\n'\n '  File "./MiniCC.py", line 168, in main\n'\n '    cfg.print_code(output, comment=comment)\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code\n'\n '    for i in self.linearize():\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize\n'\n '    assert(len(block._out) == 1)\n'\n 'AssertionError\n') == '1\n'
E             - 1
E             + Traceback (most recent call last):
E             +   File "./MiniCC.py", line 218, in <module>
E             +     main(args.filename, args.reg_alloc, args.ssa,
E             +   File "./MiniCC.py", line 168, in main
E             +     cfg.print_code(output, comment=comment)
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
E             +     for i in self.linearize():
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
E             +     assert(len(block._out) == 1)
E             + AssertionError

test_codegen.py:91: AssertionError
----------------------------- Captured stdout call -----------------------------
Compiling ...
/usr/bin/python3 ./MiniCC.py --reg-alloc=all_in_mem --output=./TP04/tests/students/relational/greater/test_greater_int_true-all_in_mem.s ./TP04/tests/students/relational/greater/test_greater_int_true.c
Exited with status: 1
Traceback (most recent call last):
  File "./MiniCC.py", line 218, in <module>
    main(args.filename, args.reg_alloc, args.ssa,
  File "./MiniCC.py", line 168, in main
    cfg.print_code(output, comment=comment)
  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
    for i in self.linearize():
  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
    assert(len(block._out) == 1)
AssertionError

_ TestCodeGen.test_alloc_mem[./TP04/tests/students/relational/greater_or_equal/test_greater_or_equal_int_false.c] _

self = <test_codegen.TestCodeGen object at 0x7f142b1280a0>
filename = './TP04/tests/students/relational/greater_or_equal/test_greater_or_equal_int_false.c'

    @pytest.mark.parametrize('filename', ALL_IN_MEM_FILES)
    def test_alloc_mem(self, filename):
        expect = self.get_expect(filename)
        actual = self.all_in_mem(filename, expect)
>       self.assert_equal(actual, expect)

test_codegen.py:247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_codegen.TestCodeGen object at 0x7f142b1280a0>
actual = testinfo(exitcode=1, execcode=0, output='Traceback (most recent call last):\n  File "./MiniCC.py", line 218, in <modul...y", line 327, in linearize\n    assert(len(block._out) == 1)\nAssertionError\n', linkargs=[], skip_test_expected=False)
expected = testinfo(exitcode=0, execcode=0, output='0\n', linkargs=[], skip_test_expected=False)

    def assert_equal(self, actual, expected):
        if TYPECHECK_ONLY and expected.exitcode == 0:
            # Compiler does not fail => no output expected
            assert actual.output == "", \
                "Compiler unexpectedly generated some output with --disable-codegen"
            assert actual.exitcode == 0, \
                "Compiler unexpectedly failed with --disable-codegen"
            return
        if DISABLE_TYPECHECK and expected.exitcode != 0:
            # Test should fail at typecheck, and we don't do
            # typechecking => nothing to check.
            pytest.skip("Test that doesn't typecheck with --disable-typecheck")
        if expected.output is not None and actual.output is not None:
>           assert actual.output == expected.output, \
                "Output of the program is incorrect."
E           AssertionError: Output of the program is incorrect.
E           assert ('Traceback (most recent call last):\n'\n '  File "./MiniCC.py", line 218, in <module>\n'\n '    main(args.filename, args.reg_alloc, args.ssa,\n'\n '  File "./MiniCC.py", line 168, in main\n'\n '    cfg.print_code(output, comment=comment)\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code\n'\n '    for i in self.linearize():\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize\n'\n '    assert(len(block._out) == 1)\n'\n 'AssertionError\n') == '0\n'
E             - 0
E             + Traceback (most recent call last):
E             +   File "./MiniCC.py", line 218, in <module>
E             +     main(args.filename, args.reg_alloc, args.ssa,
E             +   File "./MiniCC.py", line 168, in main
E             +     cfg.print_code(output, comment=comment)
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
E             +     for i in self.linearize():
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
E             +     assert(len(block._out) == 1)
E             + AssertionError

test_codegen.py:91: AssertionError
----------------------------- Captured stdout call -----------------------------
Compiling ...
/usr/bin/python3 ./MiniCC.py --reg-alloc=all_in_mem --output=./TP04/tests/students/relational/greater_or_equal/test_greater_or_equal_int_false-all_in_mem.s ./TP04/tests/students/relational/greater_or_equal/test_greater_or_equal_int_false.c
Exited with status: 1
Traceback (most recent call last):
  File "./MiniCC.py", line 218, in <module>
    main(args.filename, args.reg_alloc, args.ssa,
  File "./MiniCC.py", line 168, in main
    cfg.print_code(output, comment=comment)
  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
    for i in self.linearize():
  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
    assert(len(block._out) == 1)
AssertionError

_ TestCodeGen.test_alloc_mem[./TP04/tests/students/relational/greater_or_equal/test_greater_or_equal_int_true.c] _

self = <test_codegen.TestCodeGen object at 0x7f142b1ff3d0>
filename = './TP04/tests/students/relational/greater_or_equal/test_greater_or_equal_int_true.c'

    @pytest.mark.parametrize('filename', ALL_IN_MEM_FILES)
    def test_alloc_mem(self, filename):
        expect = self.get_expect(filename)
        actual = self.all_in_mem(filename, expect)
>       self.assert_equal(actual, expect)

test_codegen.py:247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_codegen.TestCodeGen object at 0x7f142b1ff3d0>
actual = testinfo(exitcode=1, execcode=0, output='Traceback (most recent call last):\n  File "./MiniCC.py", line 218, in <modul...y", line 327, in linearize\n    assert(len(block._out) == 1)\nAssertionError\n', linkargs=[], skip_test_expected=False)
expected = testinfo(exitcode=0, execcode=0, output='1\n', linkargs=[], skip_test_expected=False)

    def assert_equal(self, actual, expected):
        if TYPECHECK_ONLY and expected.exitcode == 0:
            # Compiler does not fail => no output expected
            assert actual.output == "", \
                "Compiler unexpectedly generated some output with --disable-codegen"
            assert actual.exitcode == 0, \
                "Compiler unexpectedly failed with --disable-codegen"
            return
        if DISABLE_TYPECHECK and expected.exitcode != 0:
            # Test should fail at typecheck, and we don't do
            # typechecking => nothing to check.
            pytest.skip("Test that doesn't typecheck with --disable-typecheck")
        if expected.output is not None and actual.output is not None:
>           assert actual.output == expected.output, \
                "Output of the program is incorrect."
E           AssertionError: Output of the program is incorrect.
E           assert ('Traceback (most recent call last):\n'\n '  File "./MiniCC.py", line 218, in <module>\n'\n '    main(args.filename, args.reg_alloc, args.ssa,\n'\n '  File "./MiniCC.py", line 168, in main\n'\n '    cfg.print_code(output, comment=comment)\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code\n'\n '    for i in self.linearize():\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize\n'\n '    assert(len(block._out) == 1)\n'\n 'AssertionError\n') == '1\n'
E             - 1
E             + Traceback (most recent call last):
E             +   File "./MiniCC.py", line 218, in <module>
E             +     main(args.filename, args.reg_alloc, args.ssa,
E             +   File "./MiniCC.py", line 168, in main
E             +     cfg.print_code(output, comment=comment)
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
E             +     for i in self.linearize():
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
E             +     assert(len(block._out) == 1)
E             + AssertionError

test_codegen.py:91: AssertionError
----------------------------- Captured stdout call -----------------------------
Compiling ...
/usr/bin/python3 ./MiniCC.py --reg-alloc=all_in_mem --output=./TP04/tests/students/relational/greater_or_equal/test_greater_or_equal_int_true-all_in_mem.s ./TP04/tests/students/relational/greater_or_equal/test_greater_or_equal_int_true.c
Exited with status: 1
Traceback (most recent call last):
  File "./MiniCC.py", line 218, in <module>
    main(args.filename, args.reg_alloc, args.ssa,
  File "./MiniCC.py", line 168, in main
    cfg.print_code(output, comment=comment)
  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
    for i in self.linearize():
  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
    assert(len(block._out) == 1)
AssertionError

_ TestCodeGen.test_alloc_mem[./TP04/tests/students/relational/greater_or_equal/test_greater_or_equal_int_true_2.c] _

self = <test_codegen.TestCodeGen object at 0x7f142b20cd60>
filename = './TP04/tests/students/relational/greater_or_equal/test_greater_or_equal_int_true_2.c'

    @pytest.mark.parametrize('filename', ALL_IN_MEM_FILES)
    def test_alloc_mem(self, filename):
        expect = self.get_expect(filename)
        actual = self.all_in_mem(filename, expect)
>       self.assert_equal(actual, expect)

test_codegen.py:247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_codegen.TestCodeGen object at 0x7f142b20cd60>
actual = testinfo(exitcode=1, execcode=0, output='Traceback (most recent call last):\n  File "./MiniCC.py", line 218, in <modul...y", line 327, in linearize\n    assert(len(block._out) == 1)\nAssertionError\n', linkargs=[], skip_test_expected=False)
expected = testinfo(exitcode=0, execcode=0, output='1\n', linkargs=[], skip_test_expected=False)

    def assert_equal(self, actual, expected):
        if TYPECHECK_ONLY and expected.exitcode == 0:
            # Compiler does not fail => no output expected
            assert actual.output == "", \
                "Compiler unexpectedly generated some output with --disable-codegen"
            assert actual.exitcode == 0, \
                "Compiler unexpectedly failed with --disable-codegen"
            return
        if DISABLE_TYPECHECK and expected.exitcode != 0:
            # Test should fail at typecheck, and we don't do
            # typechecking => nothing to check.
            pytest.skip("Test that doesn't typecheck with --disable-typecheck")
        if expected.output is not None and actual.output is not None:
>           assert actual.output == expected.output, \
                "Output of the program is incorrect."
E           AssertionError: Output of the program is incorrect.
E           assert ('Traceback (most recent call last):\n'\n '  File "./MiniCC.py", line 218, in <module>\n'\n '    main(args.filename, args.reg_alloc, args.ssa,\n'\n '  File "./MiniCC.py", line 168, in main\n'\n '    cfg.print_code(output, comment=comment)\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code\n'\n '    for i in self.linearize():\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize\n'\n '    assert(len(block._out) == 1)\n'\n 'AssertionError\n') == '1\n'
E             - 1
E             + Traceback (most recent call last):
E             +   File "./MiniCC.py", line 218, in <module>
E             +     main(args.filename, args.reg_alloc, args.ssa,
E             +   File "./MiniCC.py", line 168, in main
E             +     cfg.print_code(output, comment=comment)
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
E             +     for i in self.linearize():
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
E             +     assert(len(block._out) == 1)
E             + AssertionError

test_codegen.py:91: AssertionError
----------------------------- Captured stdout call -----------------------------
Compiling ...
/usr/bin/python3 ./MiniCC.py --reg-alloc=all_in_mem --output=./TP04/tests/students/relational/greater_or_equal/test_greater_or_equal_int_true_2-all_in_mem.s ./TP04/tests/students/relational/greater_or_equal/test_greater_or_equal_int_true_2.c
Exited with status: 1
Traceback (most recent call last):
  File "./MiniCC.py", line 218, in <module>
    main(args.filename, args.reg_alloc, args.ssa,
  File "./MiniCC.py", line 168, in main
    cfg.print_code(output, comment=comment)
  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
    for i in self.linearize():
  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
    assert(len(block._out) == 1)
AssertionError

_ TestCodeGen.test_alloc_mem[./TP04/tests/students/relational/lesser/test_lesser_int_false.c] _

self = <test_codegen.TestCodeGen object at 0x7f142b146160>
filename = './TP04/tests/students/relational/lesser/test_lesser_int_false.c'

    @pytest.mark.parametrize('filename', ALL_IN_MEM_FILES)
    def test_alloc_mem(self, filename):
        expect = self.get_expect(filename)
        actual = self.all_in_mem(filename, expect)
>       self.assert_equal(actual, expect)

test_codegen.py:247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_codegen.TestCodeGen object at 0x7f142b146160>
actual = testinfo(exitcode=1, execcode=0, output='Traceback (most recent call last):\n  File "./MiniCC.py", line 218, in <modul...y", line 327, in linearize\n    assert(len(block._out) == 1)\nAssertionError\n', linkargs=[], skip_test_expected=False)
expected = testinfo(exitcode=0, execcode=0, output='0\n', linkargs=[], skip_test_expected=False)

    def assert_equal(self, actual, expected):
        if TYPECHECK_ONLY and expected.exitcode == 0:
            # Compiler does not fail => no output expected
            assert actual.output == "", \
                "Compiler unexpectedly generated some output with --disable-codegen"
            assert actual.exitcode == 0, \
                "Compiler unexpectedly failed with --disable-codegen"
            return
        if DISABLE_TYPECHECK and expected.exitcode != 0:
            # Test should fail at typecheck, and we don't do
            # typechecking => nothing to check.
            pytest.skip("Test that doesn't typecheck with --disable-typecheck")
        if expected.output is not None and actual.output is not None:
>           assert actual.output == expected.output, \
                "Output of the program is incorrect."
E           AssertionError: Output of the program is incorrect.
E           assert ('Traceback (most recent call last):\n'\n '  File "./MiniCC.py", line 218, in <module>\n'\n '    main(args.filename, args.reg_alloc, args.ssa,\n'\n '  File "./MiniCC.py", line 168, in main\n'\n '    cfg.print_code(output, comment=comment)\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code\n'\n '    for i in self.linearize():\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize\n'\n '    assert(len(block._out) == 1)\n'\n 'AssertionError\n') == '0\n'
E             - 0
E             + Traceback (most recent call last):
E             +   File "./MiniCC.py", line 218, in <module>
E             +     main(args.filename, args.reg_alloc, args.ssa,
E             +   File "./MiniCC.py", line 168, in main
E             +     cfg.print_code(output, comment=comment)
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
E             +     for i in self.linearize():
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
E             +     assert(len(block._out) == 1)
E             + AssertionError

test_codegen.py:91: AssertionError
----------------------------- Captured stdout call -----------------------------
Compiling ...
/usr/bin/python3 ./MiniCC.py --reg-alloc=all_in_mem --output=./TP04/tests/students/relational/lesser/test_lesser_int_false-all_in_mem.s ./TP04/tests/students/relational/lesser/test_lesser_int_false.c
Exited with status: 1
Traceback (most recent call last):
  File "./MiniCC.py", line 218, in <module>
    main(args.filename, args.reg_alloc, args.ssa,
  File "./MiniCC.py", line 168, in main
    cfg.print_code(output, comment=comment)
  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
    for i in self.linearize():
  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
    assert(len(block._out) == 1)
AssertionError

_ TestCodeGen.test_alloc_mem[./TP04/tests/students/relational/lesser/test_lesser_int_true.c] _

self = <test_codegen.TestCodeGen object at 0x7f142b151a30>
filename = './TP04/tests/students/relational/lesser/test_lesser_int_true.c'

    @pytest.mark.parametrize('filename', ALL_IN_MEM_FILES)
    def test_alloc_mem(self, filename):
        expect = self.get_expect(filename)
        actual = self.all_in_mem(filename, expect)
>       self.assert_equal(actual, expect)

test_codegen.py:247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_codegen.TestCodeGen object at 0x7f142b151a30>
actual = testinfo(exitcode=1, execcode=0, output='Traceback (most recent call last):\n  File "./MiniCC.py", line 218, in <modul...y", line 327, in linearize\n    assert(len(block._out) == 1)\nAssertionError\n', linkargs=[], skip_test_expected=False)
expected = testinfo(exitcode=0, execcode=0, output='1\n', linkargs=[], skip_test_expected=False)

    def assert_equal(self, actual, expected):
        if TYPECHECK_ONLY and expected.exitcode == 0:
            # Compiler does not fail => no output expected
            assert actual.output == "", \
                "Compiler unexpectedly generated some output with --disable-codegen"
            assert actual.exitcode == 0, \
                "Compiler unexpectedly failed with --disable-codegen"
            return
        if DISABLE_TYPECHECK and expected.exitcode != 0:
            # Test should fail at typecheck, and we don't do
            # typechecking => nothing to check.
            pytest.skip("Test that doesn't typecheck with --disable-typecheck")
        if expected.output is not None and actual.output is not None:
>           assert actual.output == expected.output, \
                "Output of the program is incorrect."
E           AssertionError: Output of the program is incorrect.
E           assert ('Traceback (most recent call last):\n'\n '  File "./MiniCC.py", line 218, in <module>\n'\n '    main(args.filename, args.reg_alloc, args.ssa,\n'\n '  File "./MiniCC.py", line 168, in main\n'\n '    cfg.print_code(output, comment=comment)\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code\n'\n '    for i in self.linearize():\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize\n'\n '    assert(len(block._out) == 1)\n'\n 'AssertionError\n') == '1\n'
E             - 1
E             + Traceback (most recent call last):
E             +   File "./MiniCC.py", line 218, in <module>
E             +     main(args.filename, args.reg_alloc, args.ssa,
E             +   File "./MiniCC.py", line 168, in main
E             +     cfg.print_code(output, comment=comment)
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
E             +     for i in self.linearize():
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
E             +     assert(len(block._out) == 1)
E             + AssertionError

test_codegen.py:91: AssertionError
----------------------------- Captured stdout call -----------------------------
Compiling ...
/usr/bin/python3 ./MiniCC.py --reg-alloc=all_in_mem --output=./TP04/tests/students/relational/lesser/test_lesser_int_true-all_in_mem.s ./TP04/tests/students/relational/lesser/test_lesser_int_true.c
Exited with status: 1
Traceback (most recent call last):
  File "./MiniCC.py", line 218, in <module>
    main(args.filename, args.reg_alloc, args.ssa,
  File "./MiniCC.py", line 168, in main
    cfg.print_code(output, comment=comment)
  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
    for i in self.linearize():
  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
    assert(len(block._out) == 1)
AssertionError

_ TestCodeGen.test_alloc_mem[./TP04/tests/students/relational/lesser_or_equal/lesser_or_equal_int_false.c] _

self = <test_codegen.TestCodeGen object at 0x7f142b1b8af0>
filename = './TP04/tests/students/relational/lesser_or_equal/lesser_or_equal_int_false.c'

    @pytest.mark.parametrize('filename', ALL_IN_MEM_FILES)
    def test_alloc_mem(self, filename):
        expect = self.get_expect(filename)
        actual = self.all_in_mem(filename, expect)
>       self.assert_equal(actual, expect)

test_codegen.py:247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_codegen.TestCodeGen object at 0x7f142b1b8af0>
actual = testinfo(exitcode=1, execcode=0, output='Traceback (most recent call last):\n  File "./MiniCC.py", line 218, in <modul...y", line 327, in linearize\n    assert(len(block._out) == 1)\nAssertionError\n', linkargs=[], skip_test_expected=False)
expected = testinfo(exitcode=0, execcode=0, output='0\n', linkargs=[], skip_test_expected=False)

    def assert_equal(self, actual, expected):
        if TYPECHECK_ONLY and expected.exitcode == 0:
            # Compiler does not fail => no output expected
            assert actual.output == "", \
                "Compiler unexpectedly generated some output with --disable-codegen"
            assert actual.exitcode == 0, \
                "Compiler unexpectedly failed with --disable-codegen"
            return
        if DISABLE_TYPECHECK and expected.exitcode != 0:
            # Test should fail at typecheck, and we don't do
            # typechecking => nothing to check.
            pytest.skip("Test that doesn't typecheck with --disable-typecheck")
        if expected.output is not None and actual.output is not None:
>           assert actual.output == expected.output, \
                "Output of the program is incorrect."
E           AssertionError: Output of the program is incorrect.
E           assert ('Traceback (most recent call last):\n'\n '  File "./MiniCC.py", line 218, in <module>\n'\n '    main(args.filename, args.reg_alloc, args.ssa,\n'\n '  File "./MiniCC.py", line 168, in main\n'\n '    cfg.print_code(output, comment=comment)\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code\n'\n '    for i in self.linearize():\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize\n'\n '    assert(len(block._out) == 1)\n'\n 'AssertionError\n') == '0\n'
E             - 0
E             + Traceback (most recent call last):
E             +   File "./MiniCC.py", line 218, in <module>
E             +     main(args.filename, args.reg_alloc, args.ssa,
E             +   File "./MiniCC.py", line 168, in main
E             +     cfg.print_code(output, comment=comment)
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
E             +     for i in self.linearize():
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
E             +     assert(len(block._out) == 1)
E             + AssertionError

test_codegen.py:91: AssertionError
----------------------------- Captured stdout call -----------------------------
Compiling ...
/usr/bin/python3 ./MiniCC.py --reg-alloc=all_in_mem --output=./TP04/tests/students/relational/lesser_or_equal/lesser_or_equal_int_false-all_in_mem.s ./TP04/tests/students/relational/lesser_or_equal/lesser_or_equal_int_false.c
Exited with status: 1
Traceback (most recent call last):
  File "./MiniCC.py", line 218, in <module>
    main(args.filename, args.reg_alloc, args.ssa,
  File "./MiniCC.py", line 168, in main
    cfg.print_code(output, comment=comment)
  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
    for i in self.linearize():
  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
    assert(len(block._out) == 1)
AssertionError

_ TestCodeGen.test_alloc_mem[./TP04/tests/students/relational/lesser_or_equal/lesser_or_equal_int_true.c] _

self = <test_codegen.TestCodeGen object at 0x7f142b210160>
filename = './TP04/tests/students/relational/lesser_or_equal/lesser_or_equal_int_true.c'

    @pytest.mark.parametrize('filename', ALL_IN_MEM_FILES)
    def test_alloc_mem(self, filename):
        expect = self.get_expect(filename)
        actual = self.all_in_mem(filename, expect)
>       self.assert_equal(actual, expect)

test_codegen.py:247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_codegen.TestCodeGen object at 0x7f142b210160>
actual = testinfo(exitcode=1, execcode=0, output='Traceback (most recent call last):\n  File "./MiniCC.py", line 218, in <modul...y", line 327, in linearize\n    assert(len(block._out) == 1)\nAssertionError\n', linkargs=[], skip_test_expected=False)
expected = testinfo(exitcode=0, execcode=0, output='1\n', linkargs=[], skip_test_expected=False)

    def assert_equal(self, actual, expected):
        if TYPECHECK_ONLY and expected.exitcode == 0:
            # Compiler does not fail => no output expected
            assert actual.output == "", \
                "Compiler unexpectedly generated some output with --disable-codegen"
            assert actual.exitcode == 0, \
                "Compiler unexpectedly failed with --disable-codegen"
            return
        if DISABLE_TYPECHECK and expected.exitcode != 0:
            # Test should fail at typecheck, and we don't do
            # typechecking => nothing to check.
            pytest.skip("Test that doesn't typecheck with --disable-typecheck")
        if expected.output is not None and actual.output is not None:
>           assert actual.output == expected.output, \
                "Output of the program is incorrect."
E           AssertionError: Output of the program is incorrect.
E           assert ('Traceback (most recent call last):\n'\n '  File "./MiniCC.py", line 218, in <module>\n'\n '    main(args.filename, args.reg_alloc, args.ssa,\n'\n '  File "./MiniCC.py", line 168, in main\n'\n '    cfg.print_code(output, comment=comment)\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code\n'\n '    for i in self.linearize():\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize\n'\n '    assert(len(block._out) == 1)\n'\n 'AssertionError\n') == '1\n'
E             - 1
E             + Traceback (most recent call last):
E             +   File "./MiniCC.py", line 218, in <module>
E             +     main(args.filename, args.reg_alloc, args.ssa,
E             +   File "./MiniCC.py", line 168, in main
E             +     cfg.print_code(output, comment=comment)
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
E             +     for i in self.linearize():
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
E             +     assert(len(block._out) == 1)
E             + AssertionError

test_codegen.py:91: AssertionError
----------------------------- Captured stdout call -----------------------------
Compiling ...
/usr/bin/python3 ./MiniCC.py --reg-alloc=all_in_mem --output=./TP04/tests/students/relational/lesser_or_equal/lesser_or_equal_int_true-all_in_mem.s ./TP04/tests/students/relational/lesser_or_equal/lesser_or_equal_int_true.c
Exited with status: 1
Traceback (most recent call last):
  File "./MiniCC.py", line 218, in <module>
    main(args.filename, args.reg_alloc, args.ssa,
  File "./MiniCC.py", line 168, in main
    cfg.print_code(output, comment=comment)
  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
    for i in self.linearize():
  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
    assert(len(block._out) == 1)
AssertionError

_ TestCodeGen.test_alloc_mem[./TP04/tests/students/relational/lesser_or_equal/lesser_or_equal_int_true_2.c] _

self = <test_codegen.TestCodeGen object at 0x7f142b1c5dc0>
filename = './TP04/tests/students/relational/lesser_or_equal/lesser_or_equal_int_true_2.c'

    @pytest.mark.parametrize('filename', ALL_IN_MEM_FILES)
    def test_alloc_mem(self, filename):
        expect = self.get_expect(filename)
        actual = self.all_in_mem(filename, expect)
>       self.assert_equal(actual, expect)

test_codegen.py:247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_codegen.TestCodeGen object at 0x7f142b1c5dc0>
actual = testinfo(exitcode=1, execcode=0, output='Traceback (most recent call last):\n  File "./MiniCC.py", line 218, in <modul...y", line 327, in linearize\n    assert(len(block._out) == 1)\nAssertionError\n', linkargs=[], skip_test_expected=False)
expected = testinfo(exitcode=0, execcode=0, output='1\n', linkargs=[], skip_test_expected=False)

    def assert_equal(self, actual, expected):
        if TYPECHECK_ONLY and expected.exitcode == 0:
            # Compiler does not fail => no output expected
            assert actual.output == "", \
                "Compiler unexpectedly generated some output with --disable-codegen"
            assert actual.exitcode == 0, \
                "Compiler unexpectedly failed with --disable-codegen"
            return
        if DISABLE_TYPECHECK and expected.exitcode != 0:
            # Test should fail at typecheck, and we don't do
            # typechecking => nothing to check.
            pytest.skip("Test that doesn't typecheck with --disable-typecheck")
        if expected.output is not None and actual.output is not None:
>           assert actual.output == expected.output, \
                "Output of the program is incorrect."
E           AssertionError: Output of the program is incorrect.
E           assert ('Traceback (most recent call last):\n'\n '  File "./MiniCC.py", line 218, in <module>\n'\n '    main(args.filename, args.reg_alloc, args.ssa,\n'\n '  File "./MiniCC.py", line 168, in main\n'\n '    cfg.print_code(output, comment=comment)\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code\n'\n '    for i in self.linearize():\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize\n'\n '    assert(len(block._out) == 1)\n'\n 'AssertionError\n') == '1\n'
E             - 1
E             + Traceback (most recent call last):
E             +   File "./MiniCC.py", line 218, in <module>
E             +     main(args.filename, args.reg_alloc, args.ssa,
E             +   File "./MiniCC.py", line 168, in main
E             +     cfg.print_code(output, comment=comment)
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
E             +     for i in self.linearize():
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
E             +     assert(len(block._out) == 1)
E             + AssertionError

test_codegen.py:91: AssertionError
----------------------------- Captured stdout call -----------------------------
Compiling ...
/usr/bin/python3 ./MiniCC.py --reg-alloc=all_in_mem --output=./TP04/tests/students/relational/lesser_or_equal/lesser_or_equal_int_true_2-all_in_mem.s ./TP04/tests/students/relational/lesser_or_equal/lesser_or_equal_int_true_2.c
Exited with status: 1
Traceback (most recent call last):
  File "./MiniCC.py", line 218, in <module>
    main(args.filename, args.reg_alloc, args.ssa,
  File "./MiniCC.py", line 168, in main
    cfg.print_code(output, comment=comment)
  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
    for i in self.linearize():
  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
    assert(len(block._out) == 1)
AssertionError

_ TestCodeGen.test_alloc_mem[./TP04/tests/students/relational/not_equal/test_inequality_int_false.c] _

self = <test_codegen.TestCodeGen object at 0x7f142b120040>
filename = './TP04/tests/students/relational/not_equal/test_inequality_int_false.c'

    @pytest.mark.parametrize('filename', ALL_IN_MEM_FILES)
    def test_alloc_mem(self, filename):
        expect = self.get_expect(filename)
        actual = self.all_in_mem(filename, expect)
>       self.assert_equal(actual, expect)

test_codegen.py:247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_codegen.TestCodeGen object at 0x7f142b120040>
actual = testinfo(exitcode=1, execcode=0, output='Traceback (most recent call last):\n  File "./MiniCC.py", line 218, in <modul...y", line 327, in linearize\n    assert(len(block._out) == 1)\nAssertionError\n', linkargs=[], skip_test_expected=False)
expected = testinfo(exitcode=0, execcode=0, output='0\n', linkargs=[], skip_test_expected=False)

    def assert_equal(self, actual, expected):
        if TYPECHECK_ONLY and expected.exitcode == 0:
            # Compiler does not fail => no output expected
            assert actual.output == "", \
                "Compiler unexpectedly generated some output with --disable-codegen"
            assert actual.exitcode == 0, \
                "Compiler unexpectedly failed with --disable-codegen"
            return
        if DISABLE_TYPECHECK and expected.exitcode != 0:
            # Test should fail at typecheck, and we don't do
            # typechecking => nothing to check.
            pytest.skip("Test that doesn't typecheck with --disable-typecheck")
        if expected.output is not None and actual.output is not None:
>           assert actual.output == expected.output, \
                "Output of the program is incorrect."
E           AssertionError: Output of the program is incorrect.
E           assert ('Traceback (most recent call last):\n'\n '  File "./MiniCC.py", line 218, in <module>\n'\n '    main(args.filename, args.reg_alloc, args.ssa,\n'\n '  File "./MiniCC.py", line 168, in main\n'\n '    cfg.print_code(output, comment=comment)\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code\n'\n '    for i in self.linearize():\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize\n'\n '    assert(len(block._out) == 1)\n'\n 'AssertionError\n') == '0\n'
E             - 0
E             + Traceback (most recent call last):
E             +   File "./MiniCC.py", line 218, in <module>
E             +     main(args.filename, args.reg_alloc, args.ssa,
E             +   File "./MiniCC.py", line 168, in main
E             +     cfg.print_code(output, comment=comment)
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
E             +     for i in self.linearize():
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
E             +     assert(len(block._out) == 1)
E             + AssertionError

test_codegen.py:91: AssertionError
----------------------------- Captured stdout call -----------------------------
Compiling ...
/usr/bin/python3 ./MiniCC.py --reg-alloc=all_in_mem --output=./TP04/tests/students/relational/not_equal/test_inequality_int_false-all_in_mem.s ./TP04/tests/students/relational/not_equal/test_inequality_int_false.c
Exited with status: 1
Traceback (most recent call last):
  File "./MiniCC.py", line 218, in <module>
    main(args.filename, args.reg_alloc, args.ssa,
  File "./MiniCC.py", line 168, in main
    cfg.print_code(output, comment=comment)
  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
    for i in self.linearize():
  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
    assert(len(block._out) == 1)
AssertionError

_ TestCodeGen.test_alloc_mem[./TP04/tests/students/relational/not_equal/test_inequality_int_true.c] _

self = <test_codegen.TestCodeGen object at 0x7f142b1b0160>
filename = './TP04/tests/students/relational/not_equal/test_inequality_int_true.c'

    @pytest.mark.parametrize('filename', ALL_IN_MEM_FILES)
    def test_alloc_mem(self, filename):
        expect = self.get_expect(filename)
        actual = self.all_in_mem(filename, expect)
>       self.assert_equal(actual, expect)

test_codegen.py:247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_codegen.TestCodeGen object at 0x7f142b1b0160>
actual = testinfo(exitcode=1, execcode=0, output='Traceback (most recent call last):\n  File "./MiniCC.py", line 218, in <modul...y", line 327, in linearize\n    assert(len(block._out) == 1)\nAssertionError\n', linkargs=[], skip_test_expected=False)
expected = testinfo(exitcode=0, execcode=0, output='1\n', linkargs=[], skip_test_expected=False)

    def assert_equal(self, actual, expected):
        if TYPECHECK_ONLY and expected.exitcode == 0:
            # Compiler does not fail => no output expected
            assert actual.output == "", \
                "Compiler unexpectedly generated some output with --disable-codegen"
            assert actual.exitcode == 0, \
                "Compiler unexpectedly failed with --disable-codegen"
            return
        if DISABLE_TYPECHECK and expected.exitcode != 0:
            # Test should fail at typecheck, and we don't do
            # typechecking => nothing to check.
            pytest.skip("Test that doesn't typecheck with --disable-typecheck")
        if expected.output is not None and actual.output is not None:
>           assert actual.output == expected.output, \
                "Output of the program is incorrect."
E           AssertionError: Output of the program is incorrect.
E           assert ('Traceback (most recent call last):\n'\n '  File "./MiniCC.py", line 218, in <module>\n'\n '    main(args.filename, args.reg_alloc, args.ssa,\n'\n '  File "./MiniCC.py", line 168, in main\n'\n '    cfg.print_code(output, comment=comment)\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code\n'\n '    for i in self.linearize():\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize\n'\n '    assert(len(block._out) == 1)\n'\n 'AssertionError\n') == '1\n'
E             - 1
E             + Traceback (most recent call last):
E             +   File "./MiniCC.py", line 218, in <module>
E             +     main(args.filename, args.reg_alloc, args.ssa,
E             +   File "./MiniCC.py", line 168, in main
E             +     cfg.print_code(output, comment=comment)
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
E             +     for i in self.linearize():
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
E             +     assert(len(block._out) == 1)
E             + AssertionError

test_codegen.py:91: AssertionError
----------------------------- Captured stdout call -----------------------------
Compiling ...
/usr/bin/python3 ./MiniCC.py --reg-alloc=all_in_mem --output=./TP04/tests/students/relational/not_equal/test_inequality_int_true-all_in_mem.s ./TP04/tests/students/relational/not_equal/test_inequality_int_true.c
Exited with status: 1
Traceback (most recent call last):
  File "./MiniCC.py", line 218, in <module>
    main(args.filename, args.reg_alloc, args.ssa,
  File "./MiniCC.py", line 168, in main
    cfg.print_code(output, comment=comment)
  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
    for i in self.linearize():
  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
    assert(len(block._out) == 1)
AssertionError

____ TestCodeGen.test_alloc_mem[./TP04/tests/students/while/test_while_1.c] ____

self = <test_codegen.TestCodeGen object at 0x7f142b19a250>
filename = './TP04/tests/students/while/test_while_1.c'

    @pytest.mark.parametrize('filename', ALL_IN_MEM_FILES)
    def test_alloc_mem(self, filename):
        expect = self.get_expect(filename)
        actual = self.all_in_mem(filename, expect)
>       self.assert_equal(actual, expect)

test_codegen.py:247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_codegen.TestCodeGen object at 0x7f142b19a250>
actual = testinfo(exitcode=1, execcode=0, output='Traceback (most recent call last):\n  File "./MiniCC.py", line 218, in <modul...y", line 327, in linearize\n    assert(len(block._out) == 1)\nAssertionError\n', linkargs=[], skip_test_expected=False)
expected = testinfo(exitcode=0, execcode=0, output='', linkargs=[], skip_test_expected=False)

    def assert_equal(self, actual, expected):
        if TYPECHECK_ONLY and expected.exitcode == 0:
            # Compiler does not fail => no output expected
            assert actual.output == "", \
                "Compiler unexpectedly generated some output with --disable-codegen"
            assert actual.exitcode == 0, \
                "Compiler unexpectedly failed with --disable-codegen"
            return
        if DISABLE_TYPECHECK and expected.exitcode != 0:
            # Test should fail at typecheck, and we don't do
            # typechecking => nothing to check.
            pytest.skip("Test that doesn't typecheck with --disable-typecheck")
        if expected.output is not None and actual.output is not None:
>           assert actual.output == expected.output, \
                "Output of the program is incorrect."
E           AssertionError: Output of the program is incorrect.
E           assert ('Traceback (most recent call last):\n'\n '  File "./MiniCC.py", line 218, in <module>\n'\n '    main(args.filename, args.reg_alloc, args.ssa,\n'\n '  File "./MiniCC.py", line 168, in main\n'\n '    cfg.print_code(output, comment=comment)\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code\n'\n '    for i in self.linearize():\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize\n'\n '    assert(len(block._out) == 1)\n'\n 'AssertionError\n') == ''
E             + Traceback (most recent call last):
E             +   File "./MiniCC.py", line 218, in <module>
E             +     main(args.filename, args.reg_alloc, args.ssa,
E             +   File "./MiniCC.py", line 168, in main
E             +     cfg.print_code(output, comment=comment)
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
E             +     for i in self.linearize():
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
E             +     assert(len(block._out) == 1)
E             + AssertionError

test_codegen.py:91: AssertionError
----------------------------- Captured stdout call -----------------------------
Compiling ...
/usr/bin/python3 ./MiniCC.py --reg-alloc=all_in_mem --output=./TP04/tests/students/while/test_while_1-all_in_mem.s ./TP04/tests/students/while/test_while_1.c
Exited with status: 1
Traceback (most recent call last):
  File "./MiniCC.py", line 218, in <module>
    main(args.filename, args.reg_alloc, args.ssa,
  File "./MiniCC.py", line 168, in main
    cfg.print_code(output, comment=comment)
  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
    for i in self.linearize():
  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
    assert(len(block._out) == 1)
AssertionError

____ TestCodeGen.test_alloc_mem[./TP04/tests/students/while/test_while_2.c] ____

self = <test_codegen.TestCodeGen object at 0x7f142b1d5df0>
filename = './TP04/tests/students/while/test_while_2.c'

    @pytest.mark.parametrize('filename', ALL_IN_MEM_FILES)
    def test_alloc_mem(self, filename):
        expect = self.get_expect(filename)
        actual = self.all_in_mem(filename, expect)
>       self.assert_equal(actual, expect)

test_codegen.py:247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_codegen.TestCodeGen object at 0x7f142b1d5df0>
actual = testinfo(exitcode=1, execcode=0, output='Traceback (most recent call last):\n  File "./MiniCC.py", line 218, in <modul...y", line 327, in linearize\n    assert(len(block._out) == 1)\nAssertionError\n', linkargs=[], skip_test_expected=False)
expected = testinfo(exitcode=0, execcode=0, output='1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n', linkargs=[], skip_test_expected=False)

    def assert_equal(self, actual, expected):
        if TYPECHECK_ONLY and expected.exitcode == 0:
            # Compiler does not fail => no output expected
            assert actual.output == "", \
                "Compiler unexpectedly generated some output with --disable-codegen"
            assert actual.exitcode == 0, \
                "Compiler unexpectedly failed with --disable-codegen"
            return
        if DISABLE_TYPECHECK and expected.exitcode != 0:
            # Test should fail at typecheck, and we don't do
            # typechecking => nothing to check.
            pytest.skip("Test that doesn't typecheck with --disable-typecheck")
        if expected.output is not None and actual.output is not None:
>           assert actual.output == expected.output, \
                "Output of the program is incorrect."
E           AssertionError: Output of the program is incorrect.
E           assert ('Traceback (most recent call last):\n'\n '  File "./MiniCC.py", line 218, in <module>\n'\n '    main(args.filename, args.reg_alloc, args.ssa,\n'\n '  File "./MiniCC.py", line 168, in main\n'\n '    cfg.print_code(output, comment=comment)\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code\n'\n '    for i in self.linearize():\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize\n'\n '    assert(len(block._out) == 1)\n'\n 'AssertionError\n') == '1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n'
E             - 1
E             - 1
E             - 1
E             - 1
E             - 1
E             - 1
E             - 1
E             - 1
E             - 1
E             - 1
E             + Traceback (most recent call last):
E             +   File "./MiniCC.py", line 218, in <module>
E             +     main(args.filename, args.reg_alloc, args.ssa,
E             +   File "./MiniCC.py", line 168, in main
E             +     cfg.print_code(output, comment=comment)
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
E             +     for i in self.linearize():
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
E             +     assert(len(block._out) == 1)
E             + AssertionError

test_codegen.py:91: AssertionError
----------------------------- Captured stdout call -----------------------------
Compiling ...
/usr/bin/python3 ./MiniCC.py --reg-alloc=all_in_mem --output=./TP04/tests/students/while/test_while_2-all_in_mem.s ./TP04/tests/students/while/test_while_2.c
Exited with status: 1
Traceback (most recent call last):
  File "./MiniCC.py", line 218, in <module>
    main(args.filename, args.reg_alloc, args.ssa,
  File "./MiniCC.py", line 168, in main
    cfg.print_code(output, comment=comment)
  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
    for i in self.linearize():
  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
    assert(len(block._out) == 1)
AssertionError

____ TestCodeGen.test_alloc_mem[./TP04/tests/students/while/test_while_3.c] ____

self = <test_codegen.TestCodeGen object at 0x7f142b32d370>
filename = './TP04/tests/students/while/test_while_3.c'

    @pytest.mark.parametrize('filename', ALL_IN_MEM_FILES)
    def test_alloc_mem(self, filename):
        expect = self.get_expect(filename)
        actual = self.all_in_mem(filename, expect)
>       self.assert_equal(actual, expect)

test_codegen.py:247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_codegen.TestCodeGen object at 0x7f142b32d370>
actual = testinfo(exitcode=1, execcode=0, output='Traceback (most recent call last):\n  File "./MiniCC.py", line 218, in <modul...y", line 327, in linearize\n    assert(len(block._out) == 1)\nAssertionError\n', linkargs=[], skip_test_expected=False)
expected = testinfo(exitcode=0, execcode=0, output='', linkargs=[], skip_test_expected=False)

    def assert_equal(self, actual, expected):
        if TYPECHECK_ONLY and expected.exitcode == 0:
            # Compiler does not fail => no output expected
            assert actual.output == "", \
                "Compiler unexpectedly generated some output with --disable-codegen"
            assert actual.exitcode == 0, \
                "Compiler unexpectedly failed with --disable-codegen"
            return
        if DISABLE_TYPECHECK and expected.exitcode != 0:
            # Test should fail at typecheck, and we don't do
            # typechecking => nothing to check.
            pytest.skip("Test that doesn't typecheck with --disable-typecheck")
        if expected.output is not None and actual.output is not None:
>           assert actual.output == expected.output, \
                "Output of the program is incorrect."
E           AssertionError: Output of the program is incorrect.
E           assert ('Traceback (most recent call last):\n'\n '  File "./MiniCC.py", line 218, in <module>\n'\n '    main(args.filename, args.reg_alloc, args.ssa,\n'\n '  File "./MiniCC.py", line 168, in main\n'\n '    cfg.print_code(output, comment=comment)\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code\n'\n '    for i in self.linearize():\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize\n'\n '    assert(len(block._out) == 1)\n'\n 'AssertionError\n') == ''
E             + Traceback (most recent call last):
E             +   File "./MiniCC.py", line 218, in <module>
E             +     main(args.filename, args.reg_alloc, args.ssa,
E             +   File "./MiniCC.py", line 168, in main
E             +     cfg.print_code(output, comment=comment)
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
E             +     for i in self.linearize():
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
E             +     assert(len(block._out) == 1)
E             + AssertionError

test_codegen.py:91: AssertionError
----------------------------- Captured stdout call -----------------------------
Compiling ...
/usr/bin/python3 ./MiniCC.py --reg-alloc=all_in_mem --output=./TP04/tests/students/while/test_while_3-all_in_mem.s ./TP04/tests/students/while/test_while_3.c
Exited with status: 1
Traceback (most recent call last):
  File "./MiniCC.py", line 218, in <module>
    main(args.filename, args.reg_alloc, args.ssa,
  File "./MiniCC.py", line 168, in main
    cfg.print_code(output, comment=comment)
  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
    for i in self.linearize():
  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
    assert(len(block._out) == 1)
AssertionError

____ TestCodeGen.test_alloc_mem[./TP04/tests/students/while/test_while_7.c] ____

self = <test_codegen.TestCodeGen object at 0x7f142b17d0d0>
filename = './TP04/tests/students/while/test_while_7.c'

    @pytest.mark.parametrize('filename', ALL_IN_MEM_FILES)
    def test_alloc_mem(self, filename):
        expect = self.get_expect(filename)
        actual = self.all_in_mem(filename, expect)
>       self.assert_equal(actual, expect)

test_codegen.py:247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_codegen.TestCodeGen object at 0x7f142b17d0d0>
actual = testinfo(exitcode=1, execcode=0, output='Traceback (most recent call last):\n  File "./MiniCC.py", line 218, in <modul...y", line 327, in linearize\n    assert(len(block._out) == 1)\nAssertionError\n', linkargs=[], skip_test_expected=False)
expected = testinfo(exitcode=0, execcode=0, output='1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n', linkargs=[], skip_test_expected=False)

    def assert_equal(self, actual, expected):
        if TYPECHECK_ONLY and expected.exitcode == 0:
            # Compiler does not fail => no output expected
            assert actual.output == "", \
                "Compiler unexpectedly generated some output with --disable-codegen"
            assert actual.exitcode == 0, \
                "Compiler unexpectedly failed with --disable-codegen"
            return
        if DISABLE_TYPECHECK and expected.exitcode != 0:
            # Test should fail at typecheck, and we don't do
            # typechecking => nothing to check.
            pytest.skip("Test that doesn't typecheck with --disable-typecheck")
        if expected.output is not None and actual.output is not None:
>           assert actual.output == expected.output, \
                "Output of the program is incorrect."
E           AssertionError: Output of the program is incorrect.
E           assert ('Traceback (most recent call last):\n'\n '  File "./MiniCC.py", line 218, in <module>\n'\n '    main(args.filename, args.reg_alloc, args.ssa,\n'\n '  File "./MiniCC.py", line 168, in main\n'\n '    cfg.print_code(output, comment=comment)\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code\n'\n '    for i in self.linearize():\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize\n'\n '    assert(len(block._out) == 1)\n'\n 'AssertionError\n') == '1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n'
E             - 1
E             - 1
E             - 1
E             - 1
E             - 1
E             - 1
E             - 1
E             - 1
E             - 1
E             - 1
E             + Traceback (most recent call last):
E             +   File "./MiniCC.py", line 218, in <module>
E             +     main(args.filename, args.reg_alloc, args.ssa,
E             +   File "./MiniCC.py", line 168, in main
E             +     cfg.print_code(output, comment=comment)
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
E             +     for i in self.linearize():
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
E             +     assert(len(block._out) == 1)
E             + AssertionError

test_codegen.py:91: AssertionError
----------------------------- Captured stdout call -----------------------------
Compiling ...
/usr/bin/python3 ./MiniCC.py --reg-alloc=all_in_mem --output=./TP04/tests/students/while/test_while_7-all_in_mem.s ./TP04/tests/students/while/test_while_7.c
Exited with status: 1
Traceback (most recent call last):
  File "./MiniCC.py", line 218, in <module>
    main(args.filename, args.reg_alloc, args.ssa,
  File "./MiniCC.py", line 168, in main
    cfg.print_code(output, comment=comment)
  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
    for i in self.linearize():
  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
    assert(len(block._out) == 1)
AssertionError

____ TestCodeGen.test_alloc_mem[./TP04/tests/students/while/test_while_8.c] ____

self = <test_codegen.TestCodeGen object at 0x7f142b190970>
filename = './TP04/tests/students/while/test_while_8.c'

    @pytest.mark.parametrize('filename', ALL_IN_MEM_FILES)
    def test_alloc_mem(self, filename):
        expect = self.get_expect(filename)
        actual = self.all_in_mem(filename, expect)
>       self.assert_equal(actual, expect)

test_codegen.py:247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_codegen.TestCodeGen object at 0x7f142b190970>
actual = testinfo(exitcode=1, execcode=0, output='Traceback (most recent call last):\n  File "./MiniCC.py", line 218, in <modul...y", line 327, in linearize\n    assert(len(block._out) == 1)\nAssertionError\n', linkargs=[], skip_test_expected=False)
expected = testinfo(exitcode=0, execcode=0, output='1\n1\n', linkargs=[], skip_test_expected=False)

    def assert_equal(self, actual, expected):
        if TYPECHECK_ONLY and expected.exitcode == 0:
            # Compiler does not fail => no output expected
            assert actual.output == "", \
                "Compiler unexpectedly generated some output with --disable-codegen"
            assert actual.exitcode == 0, \
                "Compiler unexpectedly failed with --disable-codegen"
            return
        if DISABLE_TYPECHECK and expected.exitcode != 0:
            # Test should fail at typecheck, and we don't do
            # typechecking => nothing to check.
            pytest.skip("Test that doesn't typecheck with --disable-typecheck")
        if expected.output is not None and actual.output is not None:
>           assert actual.output == expected.output, \
                "Output of the program is incorrect."
E           AssertionError: Output of the program is incorrect.
E           assert ('Traceback (most recent call last):\n'\n '  File "./MiniCC.py", line 218, in <module>\n'\n '    main(args.filename, args.reg_alloc, args.ssa,\n'\n '  File "./MiniCC.py", line 168, in main\n'\n '    cfg.print_code(output, comment=comment)\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code\n'\n '    for i in self.linearize():\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize\n'\n '    assert(len(block._out) == 1)\n'\n 'AssertionError\n') == '1\n1\n'
E             - 1
E             - 1
E             + Traceback (most recent call last):
E             +   File "./MiniCC.py", line 218, in <module>
E             +     main(args.filename, args.reg_alloc, args.ssa,
E             +   File "./MiniCC.py", line 168, in main
E             +     cfg.print_code(output, comment=comment)
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
E             +     for i in self.linearize():
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
E             +     assert(len(block._out) == 1)
E             + AssertionError

test_codegen.py:91: AssertionError
----------------------------- Captured stdout call -----------------------------
Compiling ...
/usr/bin/python3 ./MiniCC.py --reg-alloc=all_in_mem --output=./TP04/tests/students/while/test_while_8-all_in_mem.s ./TP04/tests/students/while/test_while_8.c
Exited with status: 1
Traceback (most recent call last):
  File "./MiniCC.py", line 218, in <module>
    main(args.filename, args.reg_alloc, args.ssa,
  File "./MiniCC.py", line 168, in main
    cfg.print_code(output, comment=comment)
  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
    for i in self.linearize():
  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
    assert(len(block._out) == 1)
AssertionError

______ TestCodeGen.test_alloc_mem[./TP05/tests/provided/dataflow/df02.c] _______

self = <test_codegen.TestCodeGen object at 0x7f142b146b50>
filename = './TP05/tests/provided/dataflow/df02.c'

    @pytest.mark.parametrize('filename', ALL_IN_MEM_FILES)
    def test_alloc_mem(self, filename):
        expect = self.get_expect(filename)
        actual = self.all_in_mem(filename, expect)
>       self.assert_equal(actual, expect)

test_codegen.py:247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_codegen.TestCodeGen object at 0x7f142b146b50>
actual = testinfo(exitcode=1, execcode=0, output='Traceback (most recent call last):\n  File "./MiniCC.py", line 218, in <modul...y", line 327, in linearize\n    assert(len(block._out) == 1)\nAssertionError\n', linkargs=[], skip_test_expected=False)
expected = testinfo(exitcode=0, execcode=0, output='1\n', linkargs=[], skip_test_expected=False)

    def assert_equal(self, actual, expected):
        if TYPECHECK_ONLY and expected.exitcode == 0:
            # Compiler does not fail => no output expected
            assert actual.output == "", \
                "Compiler unexpectedly generated some output with --disable-codegen"
            assert actual.exitcode == 0, \
                "Compiler unexpectedly failed with --disable-codegen"
            return
        if DISABLE_TYPECHECK and expected.exitcode != 0:
            # Test should fail at typecheck, and we don't do
            # typechecking => nothing to check.
            pytest.skip("Test that doesn't typecheck with --disable-typecheck")
        if expected.output is not None and actual.output is not None:
>           assert actual.output == expected.output, \
                "Output of the program is incorrect."
E           AssertionError: Output of the program is incorrect.
E           assert ('Traceback (most recent call last):\n'\n '  File "./MiniCC.py", line 218, in <module>\n'\n '    main(args.filename, args.reg_alloc, args.ssa,\n'\n '  File "./MiniCC.py", line 168, in main\n'\n '    cfg.print_code(output, comment=comment)\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code\n'\n '    for i in self.linearize():\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize\n'\n '    assert(len(block._out) == 1)\n'\n 'AssertionError\n') == '1\n'
E             - 1
E             + Traceback (most recent call last):
E             +   File "./MiniCC.py", line 218, in <module>
E             +     main(args.filename, args.reg_alloc, args.ssa,
E             +   File "./MiniCC.py", line 168, in main
E             +     cfg.print_code(output, comment=comment)
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
E             +     for i in self.linearize():
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
E             +     assert(len(block._out) == 1)
E             + AssertionError

test_codegen.py:91: AssertionError
----------------------------- Captured stdout call -----------------------------
Compiling ...
/usr/bin/python3 ./MiniCC.py --reg-alloc=all_in_mem --output=./TP05/tests/provided/dataflow/df02-all_in_mem.s ./TP05/tests/provided/dataflow/df02.c
Exited with status: 1
Traceback (most recent call last):
  File "./MiniCC.py", line 218, in <module>
    main(args.filename, args.reg_alloc, args.ssa,
  File "./MiniCC.py", line 168, in main
    cfg.print_code(output, comment=comment)
  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
    for i in self.linearize():
  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
    assert(len(block._out) == 1)
AssertionError

______ TestCodeGen.test_alloc_mem[./TP05/tests/provided/dataflow/df03.c] _______

self = <test_codegen.TestCodeGen object at 0x7f142b1c5400>
filename = './TP05/tests/provided/dataflow/df03.c'

    @pytest.mark.parametrize('filename', ALL_IN_MEM_FILES)
    def test_alloc_mem(self, filename):
        expect = self.get_expect(filename)
        actual = self.all_in_mem(filename, expect)
>       self.assert_equal(actual, expect)

test_codegen.py:247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_codegen.TestCodeGen object at 0x7f142b1c5400>
actual = testinfo(exitcode=1, execcode=0, output='Traceback (most recent call last):\n  File "./MiniCC.py", line 218, in <modul...y", line 327, in linearize\n    assert(len(block._out) == 1)\nAssertionError\n', linkargs=[], skip_test_expected=False)
expected = testinfo(exitcode=0, execcode=0, output='15\n', linkargs=[], skip_test_expected=False)

    def assert_equal(self, actual, expected):
        if TYPECHECK_ONLY and expected.exitcode == 0:
            # Compiler does not fail => no output expected
            assert actual.output == "", \
                "Compiler unexpectedly generated some output with --disable-codegen"
            assert actual.exitcode == 0, \
                "Compiler unexpectedly failed with --disable-codegen"
            return
        if DISABLE_TYPECHECK and expected.exitcode != 0:
            # Test should fail at typecheck, and we don't do
            # typechecking => nothing to check.
            pytest.skip("Test that doesn't typecheck with --disable-typecheck")
        if expected.output is not None and actual.output is not None:
>           assert actual.output == expected.output, \
                "Output of the program is incorrect."
E           AssertionError: Output of the program is incorrect.
E           assert ('Traceback (most recent call last):\n'\n '  File "./MiniCC.py", line 218, in <module>\n'\n '    main(args.filename, args.reg_alloc, args.ssa,\n'\n '  File "./MiniCC.py", line 168, in main\n'\n '    cfg.print_code(output, comment=comment)\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code\n'\n '    for i in self.linearize():\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize\n'\n '    assert(len(block._out) == 1)\n'\n 'AssertionError\n') == '15\n'
E             - 15
E             + Traceback (most recent call last):
E             +   File "./MiniCC.py", line 218, in <module>
E             +     main(args.filename, args.reg_alloc, args.ssa,
E             +   File "./MiniCC.py", line 168, in main
E             +     cfg.print_code(output, comment=comment)
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
E             +     for i in self.linearize():
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
E             +     assert(len(block._out) == 1)
E             + AssertionError

test_codegen.py:91: AssertionError
----------------------------- Captured stdout call -----------------------------
Compiling ...
/usr/bin/python3 ./MiniCC.py --reg-alloc=all_in_mem --output=./TP05/tests/provided/dataflow/df03-all_in_mem.s ./TP05/tests/provided/dataflow/df03.c
Exited with status: 1
Traceback (most recent call last):
  File "./MiniCC.py", line 218, in <module>
    main(args.filename, args.reg_alloc, args.ssa,
  File "./MiniCC.py", line 168, in main
    cfg.print_code(output, comment=comment)
  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
    for i in self.linearize():
  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
    assert(len(block._out) == 1)
AssertionError

______ TestCodeGen.test_alloc_mem[./TP05/tests/provided/dataflow/df04.c] _______

self = <test_codegen.TestCodeGen object at 0x7f142b210a00>
filename = './TP05/tests/provided/dataflow/df04.c'

    @pytest.mark.parametrize('filename', ALL_IN_MEM_FILES)
    def test_alloc_mem(self, filename):
        expect = self.get_expect(filename)
        actual = self.all_in_mem(filename, expect)
>       self.assert_equal(actual, expect)

test_codegen.py:247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_codegen.TestCodeGen object at 0x7f142b210a00>
actual = testinfo(exitcode=1, execcode=0, output='Traceback (most recent call last):\n  File "./MiniCC.py", line 218, in <modul...y", line 327, in linearize\n    assert(len(block._out) == 1)\nAssertionError\n', linkargs=[], skip_test_expected=False)
expected = testinfo(exitcode=0, execcode=0, output='', linkargs=[], skip_test_expected=False)

    def assert_equal(self, actual, expected):
        if TYPECHECK_ONLY and expected.exitcode == 0:
            # Compiler does not fail => no output expected
            assert actual.output == "", \
                "Compiler unexpectedly generated some output with --disable-codegen"
            assert actual.exitcode == 0, \
                "Compiler unexpectedly failed with --disable-codegen"
            return
        if DISABLE_TYPECHECK and expected.exitcode != 0:
            # Test should fail at typecheck, and we don't do
            # typechecking => nothing to check.
            pytest.skip("Test that doesn't typecheck with --disable-typecheck")
        if expected.output is not None and actual.output is not None:
>           assert actual.output == expected.output, \
                "Output of the program is incorrect."
E           AssertionError: Output of the program is incorrect.
E           assert ('Traceback (most recent call last):\n'\n '  File "./MiniCC.py", line 218, in <module>\n'\n '    main(args.filename, args.reg_alloc, args.ssa,\n'\n '  File "./MiniCC.py", line 168, in main\n'\n '    cfg.print_code(output, comment=comment)\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code\n'\n '    for i in self.linearize():\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize\n'\n '    assert(len(block._out) == 1)\n'\n 'AssertionError\n') == ''
E             + Traceback (most recent call last):
E             +   File "./MiniCC.py", line 218, in <module>
E             +     main(args.filename, args.reg_alloc, args.ssa,
E             +   File "./MiniCC.py", line 168, in main
E             +     cfg.print_code(output, comment=comment)
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
E             +     for i in self.linearize():
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
E             +     assert(len(block._out) == 1)
E             + AssertionError

test_codegen.py:91: AssertionError
----------------------------- Captured stdout call -----------------------------
Compiling ...
/usr/bin/python3 ./MiniCC.py --reg-alloc=all_in_mem --output=./TP05/tests/provided/dataflow/df04-all_in_mem.s ./TP05/tests/provided/dataflow/df04.c
Exited with status: 1
Traceback (most recent call last):
  File "./MiniCC.py", line 218, in <module>
    main(args.filename, args.reg_alloc, args.ssa,
  File "./MiniCC.py", line 168, in main
    cfg.print_code(output, comment=comment)
  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
    for i in self.linearize():
  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
    assert(len(block._out) == 1)
AssertionError

______ TestCodeGen.test_alloc_mem[./TP05/tests/provided/dataflow/df05.c] _______

self = <test_codegen.TestCodeGen object at 0x7f142b120e50>
filename = './TP05/tests/provided/dataflow/df05.c'

    @pytest.mark.parametrize('filename', ALL_IN_MEM_FILES)
    def test_alloc_mem(self, filename):
        expect = self.get_expect(filename)
        actual = self.all_in_mem(filename, expect)
>       self.assert_equal(actual, expect)

test_codegen.py:247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_codegen.TestCodeGen object at 0x7f142b120e50>
actual = testinfo(exitcode=1, execcode=0, output='Traceback (most recent call last):\n  File "./MiniCC.py", line 218, in <modul...y", line 327, in linearize\n    assert(len(block._out) == 1)\nAssertionError\n', linkargs=[], skip_test_expected=False)
expected = testinfo(exitcode=0, execcode=0, output='', linkargs=[], skip_test_expected=False)

    def assert_equal(self, actual, expected):
        if TYPECHECK_ONLY and expected.exitcode == 0:
            # Compiler does not fail => no output expected
            assert actual.output == "", \
                "Compiler unexpectedly generated some output with --disable-codegen"
            assert actual.exitcode == 0, \
                "Compiler unexpectedly failed with --disable-codegen"
            return
        if DISABLE_TYPECHECK and expected.exitcode != 0:
            # Test should fail at typecheck, and we don't do
            # typechecking => nothing to check.
            pytest.skip("Test that doesn't typecheck with --disable-typecheck")
        if expected.output is not None and actual.output is not None:
>           assert actual.output == expected.output, \
                "Output of the program is incorrect."
E           AssertionError: Output of the program is incorrect.
E           assert ('Traceback (most recent call last):\n'\n '  File "./MiniCC.py", line 218, in <module>\n'\n '    main(args.filename, args.reg_alloc, args.ssa,\n'\n '  File "./MiniCC.py", line 168, in main\n'\n '    cfg.print_code(output, comment=comment)\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code\n'\n '    for i in self.linearize():\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize\n'\n '    assert(len(block._out) == 1)\n'\n 'AssertionError\n') == ''
E             + Traceback (most recent call last):
E             +   File "./MiniCC.py", line 218, in <module>
E             +     main(args.filename, args.reg_alloc, args.ssa,
E             +   File "./MiniCC.py", line 168, in main
E             +     cfg.print_code(output, comment=comment)
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
E             +     for i in self.linearize():
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
E             +     assert(len(block._out) == 1)
E             + AssertionError

test_codegen.py:91: AssertionError
----------------------------- Captured stdout call -----------------------------
Compiling ...
/usr/bin/python3 ./MiniCC.py --reg-alloc=all_in_mem --output=./TP05/tests/provided/dataflow/df05-all_in_mem.s ./TP05/tests/provided/dataflow/df05.c
Exited with status: 1
Traceback (most recent call last):
  File "./MiniCC.py", line 218, in <module>
    main(args.filename, args.reg_alloc, args.ssa,
  File "./MiniCC.py", line 168, in main
    cfg.print_code(output, comment=comment)
  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
    for i in self.linearize():
  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
    assert(len(block._out) == 1)
AssertionError

______ TestCodeGen.test_alloc_mem[./TP05/tests/students/dataflow/df01.c] _______

self = <test_codegen.TestCodeGen object at 0x7f142b20b4f0>
filename = './TP05/tests/students/dataflow/df01.c'

    @pytest.mark.parametrize('filename', ALL_IN_MEM_FILES)
    def test_alloc_mem(self, filename):
        expect = self.get_expect(filename)
        actual = self.all_in_mem(filename, expect)
>       self.assert_equal(actual, expect)

test_codegen.py:247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_codegen.TestCodeGen object at 0x7f142b20b4f0>
actual = testinfo(exitcode=1, execcode=0, output='Traceback (most recent call last):\n  File "./MiniCC.py", line 218, in <modul...y", line 327, in linearize\n    assert(len(block._out) == 1)\nAssertionError\n', linkargs=[], skip_test_expected=False)
expected = testinfo(exitcode=0, execcode=0, output='1\n', linkargs=[], skip_test_expected=False)

    def assert_equal(self, actual, expected):
        if TYPECHECK_ONLY and expected.exitcode == 0:
            # Compiler does not fail => no output expected
            assert actual.output == "", \
                "Compiler unexpectedly generated some output with --disable-codegen"
            assert actual.exitcode == 0, \
                "Compiler unexpectedly failed with --disable-codegen"
            return
        if DISABLE_TYPECHECK and expected.exitcode != 0:
            # Test should fail at typecheck, and we don't do
            # typechecking => nothing to check.
            pytest.skip("Test that doesn't typecheck with --disable-typecheck")
        if expected.output is not None and actual.output is not None:
>           assert actual.output == expected.output, \
                "Output of the program is incorrect."
E           AssertionError: Output of the program is incorrect.
E           assert ('Traceback (most recent call last):\n'\n '  File "./MiniCC.py", line 218, in <module>\n'\n '    main(args.filename, args.reg_alloc, args.ssa,\n'\n '  File "./MiniCC.py", line 168, in main\n'\n '    cfg.print_code(output, comment=comment)\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code\n'\n '    for i in self.linearize():\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize\n'\n '    assert(len(block._out) == 1)\n'\n 'AssertionError\n') == '1\n'
E             - 1
E             + Traceback (most recent call last):
E             +   File "./MiniCC.py", line 218, in <module>
E             +     main(args.filename, args.reg_alloc, args.ssa,
E             +   File "./MiniCC.py", line 168, in main
E             +     cfg.print_code(output, comment=comment)
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
E             +     for i in self.linearize():
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
E             +     assert(len(block._out) == 1)
E             + AssertionError

test_codegen.py:91: AssertionError
----------------------------- Captured stdout call -----------------------------
Compiling ...
/usr/bin/python3 ./MiniCC.py --reg-alloc=all_in_mem --output=./TP05/tests/students/dataflow/df01-all_in_mem.s ./TP05/tests/students/dataflow/df01.c
Exited with status: 1
Traceback (most recent call last):
  File "./MiniCC.py", line 218, in <module>
    main(args.filename, args.reg_alloc, args.ssa,
  File "./MiniCC.py", line 168, in main
    cfg.print_code(output, comment=comment)
  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
    for i in self.linearize():
  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
    assert(len(block._out) == 1)
AssertionError

______ TestCodeGen.test_alloc_mem[./TP05/tests/students/dataflow/df02.c] _______

self = <test_codegen.TestCodeGen object at 0x7f142b151610>
filename = './TP05/tests/students/dataflow/df02.c'

    @pytest.mark.parametrize('filename', ALL_IN_MEM_FILES)
    def test_alloc_mem(self, filename):
        expect = self.get_expect(filename)
        actual = self.all_in_mem(filename, expect)
>       self.assert_equal(actual, expect)

test_codegen.py:247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_codegen.TestCodeGen object at 0x7f142b151610>
actual = testinfo(exitcode=1, execcode=0, output='Traceback (most recent call last):\n  File "./MiniCC.py", line 218, in <modul...y", line 327, in linearize\n    assert(len(block._out) == 1)\nAssertionError\n', linkargs=[], skip_test_expected=False)
expected = testinfo(exitcode=0, execcode=0, output='1\n', linkargs=[], skip_test_expected=False)

    def assert_equal(self, actual, expected):
        if TYPECHECK_ONLY and expected.exitcode == 0:
            # Compiler does not fail => no output expected
            assert actual.output == "", \
                "Compiler unexpectedly generated some output with --disable-codegen"
            assert actual.exitcode == 0, \
                "Compiler unexpectedly failed with --disable-codegen"
            return
        if DISABLE_TYPECHECK and expected.exitcode != 0:
            # Test should fail at typecheck, and we don't do
            # typechecking => nothing to check.
            pytest.skip("Test that doesn't typecheck with --disable-typecheck")
        if expected.output is not None and actual.output is not None:
>           assert actual.output == expected.output, \
                "Output of the program is incorrect."
E           AssertionError: Output of the program is incorrect.
E           assert ('Traceback (most recent call last):\n'\n '  File "./MiniCC.py", line 218, in <module>\n'\n '    main(args.filename, args.reg_alloc, args.ssa,\n'\n '  File "./MiniCC.py", line 168, in main\n'\n '    cfg.print_code(output, comment=comment)\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code\n'\n '    for i in self.linearize():\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize\n'\n '    assert(len(block._out) == 1)\n'\n 'AssertionError\n') == '1\n'
E             - 1
E             + Traceback (most recent call last):
E             +   File "./MiniCC.py", line 218, in <module>
E             +     main(args.filename, args.reg_alloc, args.ssa,
E             +   File "./MiniCC.py", line 168, in main
E             +     cfg.print_code(output, comment=comment)
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
E             +     for i in self.linearize():
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
E             +     assert(len(block._out) == 1)
E             + AssertionError

test_codegen.py:91: AssertionError
----------------------------- Captured stdout call -----------------------------
Compiling ...
/usr/bin/python3 ./MiniCC.py --reg-alloc=all_in_mem --output=./TP05/tests/students/dataflow/df02-all_in_mem.s ./TP05/tests/students/dataflow/df02.c
Exited with status: 1
Traceback (most recent call last):
  File "./MiniCC.py", line 218, in <module>
    main(args.filename, args.reg_alloc, args.ssa,
  File "./MiniCC.py", line 168, in main
    cfg.print_code(output, comment=comment)
  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
    for i in self.linearize():
  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
    assert(len(block._out) == 1)
AssertionError

______ TestCodeGen.test_alloc_mem[./TP05/tests/students/dataflow/df03.c] _______

self = <test_codegen.TestCodeGen object at 0x7f142b32deb0>
filename = './TP05/tests/students/dataflow/df03.c'

    @pytest.mark.parametrize('filename', ALL_IN_MEM_FILES)
    def test_alloc_mem(self, filename):
        expect = self.get_expect(filename)
        actual = self.all_in_mem(filename, expect)
>       self.assert_equal(actual, expect)

test_codegen.py:247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_codegen.TestCodeGen object at 0x7f142b32deb0>
actual = testinfo(exitcode=1, execcode=0, output='Traceback (most recent call last):\n  File "./MiniCC.py", line 218, in <modul...y", line 327, in linearize\n    assert(len(block._out) == 1)\nAssertionError\n', linkargs=[], skip_test_expected=False)
expected = testinfo(exitcode=0, execcode=0, output='1\n', linkargs=[], skip_test_expected=False)

    def assert_equal(self, actual, expected):
        if TYPECHECK_ONLY and expected.exitcode == 0:
            # Compiler does not fail => no output expected
            assert actual.output == "", \
                "Compiler unexpectedly generated some output with --disable-codegen"
            assert actual.exitcode == 0, \
                "Compiler unexpectedly failed with --disable-codegen"
            return
        if DISABLE_TYPECHECK and expected.exitcode != 0:
            # Test should fail at typecheck, and we don't do
            # typechecking => nothing to check.
            pytest.skip("Test that doesn't typecheck with --disable-typecheck")
        if expected.output is not None and actual.output is not None:
>           assert actual.output == expected.output, \
                "Output of the program is incorrect."
E           AssertionError: Output of the program is incorrect.
E           assert ('Traceback (most recent call last):\n'\n '  File "./MiniCC.py", line 218, in <module>\n'\n '    main(args.filename, args.reg_alloc, args.ssa,\n'\n '  File "./MiniCC.py", line 168, in main\n'\n '    cfg.print_code(output, comment=comment)\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code\n'\n '    for i in self.linearize():\n'\n '  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize\n'\n '    assert(len(block._out) == 1)\n'\n 'AssertionError\n') == '1\n'
E             - 1
E             + Traceback (most recent call last):
E             +   File "./MiniCC.py", line 218, in <module>
E             +     main(args.filename, args.reg_alloc, args.ssa,
E             +   File "./MiniCC.py", line 168, in main
E             +     cfg.print_code(output, comment=comment)
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
E             +     for i in self.linearize():
E             +   File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
E             +     assert(len(block._out) == 1)
E             + AssertionError

test_codegen.py:91: AssertionError
----------------------------- Captured stdout call -----------------------------
Compiling ...
/usr/bin/python3 ./MiniCC.py --reg-alloc=all_in_mem --output=./TP05/tests/students/dataflow/df03-all_in_mem.s ./TP05/tests/students/dataflow/df03.c
Exited with status: 1
Traceback (most recent call last):
  File "./MiniCC.py", line 218, in <module>
    main(args.filename, args.reg_alloc, args.ssa,
  File "./MiniCC.py", line 168, in main
    cfg.print_code(output, comment=comment)
  File "/home/compil/MiniC/TP05/CFG.py", line 352, in print_code
    for i in self.linearize():
  File "/home/compil/MiniC/TP05/CFG.py", line 327, in linearize
    assert(len(block._out) == 1)
AssertionError

______ TestCodeGen.test_alloc_mem[./TP05/tests/students/dataflow/df04.c] _______

self = <test_codegen.TestCodeGen object at 0x7f142b156c10>
filename = './TP05/tests/students/dataflow/df04.c'

    @pytest.mark.parametrize('filename', ALL_IN_MEM_FILES)
    def test_alloc_mem(self, filename):
        expect = self.get_expect(filename)
        actual = self.all_in_mem(filename, expect)
>       self.assert_equal(actual, expect)

test_codegen.py:247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_codegen.TestCodeGen object at 0x7f142b156c10>
actual = testinfo(exitcode=0, execcode=0, output='', linkargs=[], skip_test_expected=False)
expected = testinfo(exitcode=0, execcode=0, output='1\n', linkargs=[], skip_test_expected=False)

    def assert_equal(self, actual, expected):
        if TYPECHECK_ONLY and expected.exitcode == 0:
            # Compiler does not fail => no output expected
            assert actual.output == "", \
                "Compiler unexpectedly generated some output with --disable-codegen"
            assert actual.exitcode == 0, \
                "Compiler unexpectedly failed with --disable-codegen"
            return
        if DISABLE_TYPECHECK and expected.exitcode != 0:
            # Test should fail at typecheck, and we don't do
            # typechecking => nothing to check.
            pytest.skip("Test that doesn't typecheck with --disable-typecheck")
        if expected.output is not None and actual.output is not None:
>           assert actual.output == expected.output, \
                "Output of the program is incorrect."
E           AssertionError: Output of the program is incorrect.
E           assert '' == '1\n'
E             - 1

test_codegen.py:91: AssertionError
----------------------------- Captured stdout call -----------------------------
Compiling ...
/usr/bin/python3 ./MiniCC.py --reg-alloc=all_in_mem --output=./TP05/tests/students/dataflow/df04-all_in_mem.s ./TP05/tests/students/dataflow/df04.c
Exited with status: 0

Compiling ... OK
testinfo(exitcode=0, execcode=0, output='1\n', linkargs=[], skip_test_expected=False)
Assembling and linking ./TP05/tests/students/dataflow/df04-all_in_mem.s: riscv64-unknown-elf-gcc ./TP05/tests/students/dataflow/df04-all_in_mem.s TP04/libprint.s -o ./TP05/tests/students/dataflow/df04.riscv
Assembling and linking ... OK
_____ TestCodeGen.test_smart_alloc[./TP05/tests/students/dataflow/df01.c] ______

self = <test_codegen.TestCodeGen object at 0x7f142b208700>
filename = './TP05/tests/students/dataflow/df01.c'

    @pytest.mark.parametrize('filename', ALLOC_FILES)
    def test_smart_alloc(self, filename):
        """Generate code with smart allocation."""
        expect = self.get_expect(filename)
        actual = self.smart_alloc(filename, expect)
>       self.assert_equal(actual, expect)

test_codegen.py:254: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_codegen.TestCodeGen object at 0x7f142b208700>
actual = testinfo(exitcode=0, execcode=0, output='', linkargs=[], skip_test_expected=False)
expected = testinfo(exitcode=0, execcode=0, output='1\n', linkargs=[], skip_test_expected=False)

    def assert_equal(self, actual, expected):
        if TYPECHECK_ONLY and expected.exitcode == 0:
            # Compiler does not fail => no output expected
            assert actual.output == "", \
                "Compiler unexpectedly generated some output with --disable-codegen"
            assert actual.exitcode == 0, \
                "Compiler unexpectedly failed with --disable-codegen"
            return
        if DISABLE_TYPECHECK and expected.exitcode != 0:
            # Test should fail at typecheck, and we don't do
            # typechecking => nothing to check.
            pytest.skip("Test that doesn't typecheck with --disable-typecheck")
        if expected.output is not None and actual.output is not None:
>           assert actual.output == expected.output, \
                "Output of the program is incorrect."
E           AssertionError: Output of the program is incorrect.
E           assert '' == '1\n'
E             - 1

test_codegen.py:91: AssertionError
----------------------------- Captured stdout call -----------------------------
Compiling ...
/usr/bin/python3 ./MiniCC.py --reg-alloc=smart --output=./TP05/tests/students/dataflow/df01-smart.s ./TP05/tests/students/dataflow/df01.c
Exited with status: 0
{temp_0: t6, temp_1: t4, temp_2: t6, temp_3: t5, temp_4: t6, temp_5: t6, temp_6: t5, temp_7: t6, temp_8: t6, temp_9: t6, temp_10: t5, temp_11: t6, temp_12: t6, temp_13: t5, temp_14: t6, temp_15: t6, temp_16: t6, temp_17: t6}

Compiling ... OK
testinfo(exitcode=0, execcode=0, output='1\n', linkargs=[], skip_test_expected=False)
Assembling and linking ./TP05/tests/students/dataflow/df01-smart.s: riscv64-unknown-elf-gcc ./TP05/tests/students/dataflow/df01-smart.s TP04/libprint.s -o ./TP05/tests/students/dataflow/df01.riscv
Assembling and linking ... OK
_____ TestCodeGen.test_smart_alloc[./TP05/tests/students/dataflow/df02.c] ______

self = <test_codegen.TestCodeGen object at 0x7f142b215e80>
filename = './TP05/tests/students/dataflow/df02.c'

    @pytest.mark.parametrize('filename', ALLOC_FILES)
    def test_smart_alloc(self, filename):
        """Generate code with smart allocation."""
        expect = self.get_expect(filename)
        actual = self.smart_alloc(filename, expect)
>       self.assert_equal(actual, expect)

test_codegen.py:254: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_codegen.TestCodeGen object at 0x7f142b215e80>
actual = testinfo(exitcode=0, execcode=0, output='', linkargs=[], skip_test_expected=False)
expected = testinfo(exitcode=0, execcode=0, output='1\n', linkargs=[], skip_test_expected=False)

    def assert_equal(self, actual, expected):
        if TYPECHECK_ONLY and expected.exitcode == 0:
            # Compiler does not fail => no output expected
            assert actual.output == "", \
                "Compiler unexpectedly generated some output with --disable-codegen"
            assert actual.exitcode == 0, \
                "Compiler unexpectedly failed with --disable-codegen"
            return
        if DISABLE_TYPECHECK and expected.exitcode != 0:
            # Test should fail at typecheck, and we don't do
            # typechecking => nothing to check.
            pytest.skip("Test that doesn't typecheck with --disable-typecheck")
        if expected.output is not None and actual.output is not None:
>           assert actual.output == expected.output, \
                "Output of the program is incorrect."
E           AssertionError: Output of the program is incorrect.
E           assert '' == '1\n'
E             - 1

test_codegen.py:91: AssertionError
----------------------------- Captured stdout call -----------------------------
Compiling ...
/usr/bin/python3 ./MiniCC.py --reg-alloc=smart --output=./TP05/tests/students/dataflow/df02-smart.s ./TP05/tests/students/dataflow/df02.c
Exited with status: 0
{temp_0: t6, temp_1: t4, temp_2: t6, temp_3: t5, temp_4: t6, temp_5: t6, temp_6: t6, temp_7: t6}

Compiling ... OK
testinfo(exitcode=0, execcode=0, output='1\n', linkargs=[], skip_test_expected=False)
Assembling and linking ./TP05/tests/students/dataflow/df02-smart.s: riscv64-unknown-elf-gcc ./TP05/tests/students/dataflow/df02-smart.s TP04/libprint.s -o ./TP05/tests/students/dataflow/df02.riscv
Assembling and linking ... OK
_____ TestCodeGen.test_smart_alloc[./TP05/tests/students/dataflow/df03.c] ______

self = <test_codegen.TestCodeGen object at 0x7f142b1d5970>
filename = './TP05/tests/students/dataflow/df03.c'

    @pytest.mark.parametrize('filename', ALLOC_FILES)
    def test_smart_alloc(self, filename):
        """Generate code with smart allocation."""
        expect = self.get_expect(filename)
        actual = self.smart_alloc(filename, expect)
>       self.assert_equal(actual, expect)

test_codegen.py:254: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_codegen.TestCodeGen object at 0x7f142b1d5970>
actual = testinfo(exitcode=0, execcode=0, output='', linkargs=[], skip_test_expected=False)
expected = testinfo(exitcode=0, execcode=0, output='1\n', linkargs=[], skip_test_expected=False)

    def assert_equal(self, actual, expected):
        if TYPECHECK_ONLY and expected.exitcode == 0:
            # Compiler does not fail => no output expected
            assert actual.output == "", \
                "Compiler unexpectedly generated some output with --disable-codegen"
            assert actual.exitcode == 0, \
                "Compiler unexpectedly failed with --disable-codegen"
            return
        if DISABLE_TYPECHECK and expected.exitcode != 0:
            # Test should fail at typecheck, and we don't do
            # typechecking => nothing to check.
            pytest.skip("Test that doesn't typecheck with --disable-typecheck")
        if expected.output is not None and actual.output is not None:
>           assert actual.output == expected.output, \
                "Output of the program is incorrect."
E           AssertionError: Output of the program is incorrect.
E           assert '' == '1\n'
E             - 1

test_codegen.py:91: AssertionError
----------------------------- Captured stdout call -----------------------------
Compiling ...
/usr/bin/python3 ./MiniCC.py --reg-alloc=smart --output=./TP05/tests/students/dataflow/df03-smart.s ./TP05/tests/students/dataflow/df03.c
Exited with status: 0
{temp_0: t4, temp_1: t6, temp_2: t5, temp_3: t6, temp_4: t6, temp_5: t6}

Compiling ... OK
testinfo(exitcode=0, execcode=0, output='1\n', linkargs=[], skip_test_expected=False)
Assembling and linking ./TP05/tests/students/dataflow/df03-smart.s: riscv64-unknown-elf-gcc ./TP05/tests/students/dataflow/df03-smart.s TP04/libprint.s -o ./TP05/tests/students/dataflow/df03.riscv
Assembling and linking ... OK
_____ TestCodeGen.test_smart_alloc[./TP05/tests/students/dataflow/df04.c] ______

self = <test_codegen.TestCodeGen object at 0x7f142b3381f0>
filename = './TP05/tests/students/dataflow/df04.c'

    @pytest.mark.parametrize('filename', ALLOC_FILES)
    def test_smart_alloc(self, filename):
        """Generate code with smart allocation."""
        expect = self.get_expect(filename)
        actual = self.smart_alloc(filename, expect)
>       self.assert_equal(actual, expect)

test_codegen.py:254: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_codegen.TestCodeGen object at 0x7f142b3381f0>
actual = testinfo(exitcode=0, execcode=0, output='', linkargs=[], skip_test_expected=False)
expected = testinfo(exitcode=0, execcode=0, output='1\n', linkargs=[], skip_test_expected=False)

    def assert_equal(self, actual, expected):
        if TYPECHECK_ONLY and expected.exitcode == 0:
            # Compiler does not fail => no output expected
            assert actual.output == "", \
                "Compiler unexpectedly generated some output with --disable-codegen"
            assert actual.exitcode == 0, \
                "Compiler unexpectedly failed with --disable-codegen"
            return
        if DISABLE_TYPECHECK and expected.exitcode != 0:
            # Test should fail at typecheck, and we don't do
            # typechecking => nothing to check.
            pytest.skip("Test that doesn't typecheck with --disable-typecheck")
        if expected.output is not None and actual.output is not None:
>           assert actual.output == expected.output, \
                "Output of the program is incorrect."
E           AssertionError: Output of the program is incorrect.
E           assert '' == '1\n'
E             - 1

test_codegen.py:91: AssertionError
----------------------------- Captured stdout call -----------------------------
Compiling ...
/usr/bin/python3 ./MiniCC.py --reg-alloc=smart --output=./TP05/tests/students/dataflow/df04-smart.s ./TP05/tests/students/dataflow/df04.c
Exited with status: 0
{temp_0: t6, temp_1: t0, temp_2: s10, temp_3: s11, temp_4: t1, temp_5: t2, temp_6: t3, temp_7: t4, temp_8: t5, temp_9: t6, temp_10: s4, temp_11: s5, temp_12: s6, temp_13: s7, temp_14: s8, temp_15: s9, temp_16: t6, temp_17: t6, temp_18: t6, temp_19: t6, temp_20: t6, temp_21: t6, temp_22: t6, temp_23: t5, temp_24: t4, temp_25: t3, temp_26: t2, temp_27: t1, temp_28: t0, temp_29: t0, temp_30: t0, temp_31: s9, temp_32: s9, temp_33: s9, temp_34: s9, temp_35: s9, temp_36: t6, temp_37: t6, temp_38: t6, temp_39: t6, temp_40: t6, temp_41: t6, temp_42: t6, temp_43: t6, temp_44: t6}

Compiling ... OK
testinfo(exitcode=0, execcode=0, output='1\n', linkargs=[], skip_test_expected=False)
Assembling and linking ./TP05/tests/students/dataflow/df04-smart.s: riscv64-unknown-elf-gcc ./TP05/tests/students/dataflow/df04-smart.s TP04/libprint.s -o ./TP05/tests/students/dataflow/df04.riscv
Assembling and linking ... OK

---------- coverage: platform linux, python 3.8.10-final-0 -----------
Name                            Stmts   Miss  Cover
---------------------------------------------------
Errors.py                           8      0   100%
MiniCC.py                         157     49    69%
MiniCInterpreter.py                48     48     0%
MiniCLexer.py                     184      1    99%
MiniCParser.py                   1407    263    81%
MiniCVisitor.py                    74     29    61%
TP03/MiniCTypingVisitor.py        138     10    93%
TP04/APIRiscV.py                  135     41    70%
TP04/Instruction3A.py             110     16    85%
TP04/MiniCCodeGen3AVisitor.py     169      0   100%
TP04/Operands.py                  127     19    85%
TP04/SimpleAllocations.py          54      0   100%
TP05/CFG.py                       207     27    87%
TP05/LibGraphes.py                235    153    35%
TP05/LivenessDataFlow.py           46      0   100%
TP05/LivenessSSA.py                51     37    27%
TP05/SSA.py                       114     89    22%
TP05/SmartAllocation.py            97     34    65%
test_codegen.py                   155     25    84%
test_expect_pragma.py             100     29    71%
test_interpreter.py                33     33     0%
---------------------------------------------------
TOTAL                            3649    903    75%
Coverage HTML written to dir htmlcov

=========================== short test summary info ============================
SKIPPED [75] test_codegen.py:233: Not testing the expected value for tests expecting exitcode!=0
SKIPPED [2] test_codegen.py:228: Skipping test because it contains SKIP TEST EXPECTED
SKIPPED [1] test_codegen.py:145: Too big for the naive allocator
SKIPPED [1] test_codegen.py:147: Too big for the all in memory allocator
============ 64 failed, 333 passed, 79 skipped in 360.07s (0:06:00) ============

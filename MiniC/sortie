java -jar /home/kasket/lib/antlr-4.9.2-complete.jar MiniC.g4 -Dlanguage=Python3 -visitor -no-listener
pyright .
No configuration file found.
pyproject.toml file found at /mnt/c/Users/kevin/Documents/git/mif08-2021/MiniC.
Loading pyproject.toml file at /mnt/c/Users/kevin/Documents/git/mif08-2021/MiniC/pyproject.toml
Unable to get Python version from interpreter
Assuming Python platform Linux
Auto-excluding **/node_modules
Auto-excluding **/__pycache__
Auto-excluding .git
Searching for source files
Found 22 source files
0 errors, 0 warnings, 0 infos 
Completed in 2.635sec
python3 -m pytest -vv -rs --failed-first --cov="/mnt/c/Users/kevin/Documents/git/mif08-2021/MiniC" --cov-report=term --cov-report=html  ./test_codegen.py -k 'not smart'
============================= test session starts ==============================
platform linux -- Python 3.8.10, pytest-6.2.5, py-1.10.0, pluggy-1.0.0 -- /usr/bin/python3
cachedir: .pytest_cache
rootdir: /mnt/c/Users/kevin/Documents/git/mif08-2021/MiniC
plugins: cov-3.0.0
collecting ... collected 102 items / 6 deselected / 96 selected
run-last-failure: rerun previous 36 failures first

test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/test_and.c] PASSED [  1%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/test_equality.c] PASSED [  2%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/test_not.c] PASSED [  3%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/test_or.c] PASSED [  4%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/provided/step1/test00.c] FAILED [  5%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/provided/step1/test00b.c] FAILED [  6%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/provided/step1/test00d.c] FAILED [  7%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/provided/step1/test01.c] FAILED [  8%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/provided/step1/test_print.c] FAILED [  9%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/provided/step1/test_var.c] FAILED [ 10%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/provided/step1/test_var_plus.c] FAILED [ 11%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/provided/step1/test_vars.c] FAILED [ 12%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/provided/step2/test02.c] FAILED [ 13%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/provided/step2/test04.c] FAILED [ 14%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/provided/step2/test05.c] FAILED [ 15%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/provided/step2/test06.c] FAILED [ 16%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/provided/step2/test07.c] FAILED [ 17%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/provided/step2/test_bool.c] FAILED [ 18%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/provided/step2/test_compare_1_1.c] FAILED [ 19%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/provided/step2/test_if2.c] FAILED [ 20%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/provided/step2/test_while1.c] FAILED [ 21%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/test_and.c] FAILED [ 22%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/test_div.c] FAILED [ 23%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/test_div_zero.c] FAILED [ 25%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/test_equality.c] FAILED [ 26%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/test_minus.c] FAILED [ 27%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/test_mult.c] FAILED [ 28%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/test_not.c] FAILED [ 29%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/test_or.c] FAILED [ 30%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/students/test_unary_minus.c] FAILED [ 31%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP05/tests/provided/dataflow/df00.c] FAILED [ 32%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP05/tests/provided/dataflow/df01.c] FAILED [ 33%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP05/tests/provided/dataflow/df02.c] FAILED [ 34%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP05/tests/provided/dataflow/df03.c] FAILED [ 35%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP05/tests/provided/dataflow/df04.c] FAILED [ 36%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP05/tests/provided/dataflow/df05.c] FAILED [ 37%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/provided/step1/test00.c] PASSED [ 38%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/provided/step1/test00b.c] PASSED [ 39%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/provided/step1/test00d.c] PASSED [ 40%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/provided/step1/test01.c] PASSED [ 41%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/provided/step1/test_print.c] PASSED [ 42%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/provided/step1/test_var.c] PASSED [ 43%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/provided/step1/test_var_plus.c] PASSED [ 44%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/provided/step1/test_vars.c] PASSED [ 45%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/provided/step2/test02.c] PASSED [ 46%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/provided/step2/test04.c] PASSED [ 47%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/provided/step2/test05.c] PASSED [ 48%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/provided/step2/test06.c] PASSED [ 50%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/provided/step2/test07.c] PASSED [ 51%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/provided/step2/test_bool.c] PASSED [ 52%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/provided/step2/test_compare_1_1.c] PASSED [ 53%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/provided/step2/test_if2.c] PASSED [ 54%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/provided/step2/test_while1.c] PASSED [ 55%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/provided/unsupported/float.c] SKIPPED [ 56%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/provided/unsupported/print_float.c] SKIPPED [ 57%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/provided/unsupported/print_string.c] SKIPPED [ 58%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/provided/unsupported/string.c] SKIPPED [ 59%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/test_and.c] PASSED [ 60%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/test_div.c] PASSED [ 61%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/test_div_zero.c] SKIPPED [ 62%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/test_equality.c] PASSED [ 63%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/test_minus.c] PASSED [ 64%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/test_mult.c] PASSED [ 65%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/test_not.c] PASSED [ 66%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/test_or.c] PASSED [ 67%]
test_codegen.py::TestCodeGen::test_expect[./TP04/tests/students/test_unary_minus.c] PASSED [ 68%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/provided/step1/test00.c] PASSED [ 69%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/provided/step1/test00b.c] PASSED [ 70%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/provided/step1/test00d.c] PASSED [ 71%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/provided/step1/test01.c] PASSED [ 72%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/provided/step1/test_print.c] PASSED [ 73%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/provided/step1/test_var.c] PASSED [ 75%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/provided/step1/test_var_plus.c] PASSED [ 76%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/provided/step1/test_vars.c] PASSED [ 77%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/provided/step2/test02.c] PASSED [ 78%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/provided/step2/test04.c] PASSED [ 79%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/provided/step2/test05.c] PASSED [ 80%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/provided/step2/test06.c] PASSED [ 81%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/provided/step2/test07.c] SKIPPED [ 82%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/provided/step2/test_bool.c] PASSED [ 83%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/provided/step2/test_compare_1_1.c] PASSED [ 84%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/provided/step2/test_if2.c] PASSED [ 85%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/provided/step2/test_while1.c] PASSED [ 86%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/provided/unsupported/float.c] PASSED [ 87%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/provided/unsupported/print_float.c] PASSED [ 88%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/provided/unsupported/print_string.c] PASSED [ 89%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/provided/unsupported/string.c] PASSED [ 90%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/test_div.c] PASSED [ 91%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/test_div_zero.c] PASSED [ 92%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/test_minus.c] PASSED [ 93%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/test_mult.c] PASSED [ 94%]
test_codegen.py::TestCodeGen::test_naive_alloc[./TP04/tests/students/test_unary_minus.c] PASSED [ 95%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/provided/unsupported/float.c] PASSED [ 96%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/provided/unsupported/print_float.c] PASSED [ 97%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/provided/unsupported/print_string.c] PASSED [ 98%]
test_codegen.py::TestCodeGen::test_alloc_mem[./TP04/tests/provided/unsupported/string.c] PASSED [100%]

=================================== FAILURES ===================================
_______ TestCodeGen.test_alloc_mem[./TP04/tests/provided/step1/test00.c] _______

self = <test_codegen.TestCodeGen object at 0x7fab86a20670>
output_name = './TP04/tests/provided/step1/test00-all_in_mem.s'
exec_name = './TP04/tests/provided/step1/test00.riscv'
info = testinfo(exitcode=0, execcode=0, output='42\n', linkargs=[], skip_test_expected=False)

    def link_and_run(self, output_name, exec_name, info):
        self.remove(exec_name)
        cmd = [
            ASM, output_name, 'TP04/libprint.s',
            '-o', exec_name
        ] + info.linkargs
        print(info)
        print("Assembling and linking " + output_name + ": " + ' '.join(cmd))
        try:
>           subprocess.check_output(cmd, timeout=60, stderr=subprocess.STDOUT)

test_codegen.py:169: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

timeout = 60
popenargs = (['riscv64-unknown-elf-gcc', './TP04/tests/provided/step1/test00-all_in_mem.s', 'TP04/libprint.s', '-o', './TP04/tests/provided/step1/test00.riscv'],)
kwargs = {'stderr': -2}

    def check_output(*popenargs, timeout=None, **kwargs):
        r"""Run command with arguments and return its output.
    
        If the exit code was non-zero it raises a CalledProcessError.  The
        CalledProcessError object will have the return code in the returncode
        attribute and output in the output attribute.
    
        The arguments are the same as for the Popen constructor.  Example:
    
        >>> check_output(["ls", "-l", "/dev/null"])
        b'crw-rw-rw- 1 root root 1, 3 Oct 18  2007 /dev/null\n'
    
        The stdout argument is not allowed as it is used internally.
        To capture standard error in the result, use stderr=STDOUT.
    
        >>> check_output(["/bin/sh", "-c",
        ...               "ls -l non_existent_file ; exit 0"],
        ...              stderr=STDOUT)
        b'ls: non_existent_file: No such file or directory\n'
    
        There is an additional optional argument, "input", allowing you to
        pass a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it too will be used internally.  Example:
    
        >>> check_output(["sed", "-e", "s/foo/bar/"],
        ...              input=b"when in the course of fooman events\n")
        b'when in the course of barman events\n'
    
        By default, all communication is in bytes, and therefore any "input"
        should be bytes, and the return value will be bytes.  If in text mode,
        any "input" should be a string, and the return value will be a string
        decoded according to locale encoding, or by "encoding" if set. Text mode
        is triggered by setting any of text, encoding, errors or universal_newlines.
        """
        if 'stdout' in kwargs:
            raise ValueError('stdout argument not allowed, it will be overridden.')
    
        if 'input' in kwargs and kwargs['input'] is None:
            # Explicitly passing input=None was previously equivalent to passing an
            # empty string. That is maintained here for backwards compatibility.
            if kwargs.get('universal_newlines') or kwargs.get('text'):
                empty = ''
            else:
                empty = b''
            kwargs['input'] = empty
    
>       return run(*popenargs, stdout=PIPE, timeout=timeout, check=True,
                   **kwargs).stdout

/usr/lib/python3.8/subprocess.py:415: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = False, timeout = 60, check = True
popenargs = (['riscv64-unknown-elf-gcc', './TP04/tests/provided/step1/test00-all_in_mem.s', 'TP04/libprint.s', '-o', './TP04/tests/provided/step1/test00.riscv'],)
kwargs = {'stderr': -2, 'stdout': -1}
process = <subprocess.Popen object at 0x7fab86a20a90>
stdout = b"./TP04/tests/provided/step1/test00-all_in_mem.s: Assembler messages:\n./TP04/tests/provided/step1/test00-all_in_mem....s:42: Error: illegal operands `mv'\n./TP04/tests/provided/step1/test00-all_in_mem.s:49: Error: illegal operands `li'\n"
stderr = None, retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout is given, and the process takes too long, a TimeoutExpired
        exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['riscv64-unknown-elf-gcc', './TP04/tests/provided/step1/test00-all_in_mem.s', 'TP04/libprint.s', '-o', './TP04/tests/provided/step1/test00.riscv']' returned non-zero exit status 1.

/usr/lib/python3.8/subprocess.py:516: CalledProcessError

During handling of the above exception, another exception occurred:

self = <test_codegen.TestCodeGen object at 0x7fab86a20670>
filename = './TP04/tests/provided/step1/test00.c'

    @pytest.mark.parametrize('filename', ALL_IN_MEM_FILES)
    def test_alloc_mem(self, filename):
        expect = self.get_expect(filename)
>       actual = self.all_in_mem(filename, expect)

test_codegen.py:242: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
test_codegen.py:100: in all_in_mem
    return self.compile_and_simulate(file, info, reg_alloc='all_in_mem')
test_codegen.py:216: in compile_and_simulate
    return self.link_and_run(output_name, exec_name, info)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_codegen.TestCodeGen object at 0x7fab86a20670>
output_name = './TP04/tests/provided/step1/test00-all_in_mem.s'
exec_name = './TP04/tests/provided/step1/test00.riscv'
info = testinfo(exitcode=0, execcode=0, output='42\n', linkargs=[], skip_test_expected=False)

    def link_and_run(self, output_name, exec_name, info):
        self.remove(exec_name)
        cmd = [
            ASM, output_name, 'TP04/libprint.s',
            '-o', exec_name
        ] + info.linkargs
        print(info)
        print("Assembling and linking " + output_name + ": " + ' '.join(cmd))
        try:
            subprocess.check_output(cmd, timeout=60, stderr=subprocess.STDOUT)
        except subprocess.CalledProcessError as e:
            print("Assembling failed:\n")
            print(e.output.decode())
            print("Assembler code below:\n")
            cat(output_name)
>           pytest.fail()
E           Failed

test_codegen.py:175: Failed
----------------------------- Captured stdout call -----------------------------
Compiling ...
/usr/bin/python3 ./MiniCC.py --reg-alloc=all_in_mem --output=./TP04/tests/provided/step1/test00-all_in_mem.s ./TP04/tests/provided/step1/test00.c
Exited with status: 0

Compiling ... OK
testinfo(exitcode=0, execcode=0, output='42\n', linkargs=[], skip_test_expected=False)
Assembling and linking ./TP04/tests/provided/step1/test00-all_in_mem.s: riscv64-unknown-elf-gcc ./TP04/tests/provided/step1/test00-all_in_mem.s TP04/libprint.s -o ./TP04/tests/provided/step1/test00.riscv
Assembling failed:

./TP04/tests/provided/step1/test00-all_in_mem.s: Assembler messages:
./TP04/tests/provided/step1/test00-all_in_mem.s:20: Error: illegal operands `la'
./TP04/tests/provided/step1/test00-all_in_mem.s:26: Error: illegal operands `li'
./TP04/tests/provided/step1/test00-all_in_mem.s:39: Error: illegal operands `li'
./TP04/tests/provided/step1/test00-all_in_mem.s:42: Error: illegal operands `mv'
./TP04/tests/provided/step1/test00-all_in_mem.s:49: Error: illegal operands `li'

Assembler code below:

##Automatically generated RISCV code, MIF08 & CAP
## all-in-memory allocation


##prelude

        .text
        .globl main
main:
        addi sp, sp, -32
        sd ra, 0(sp)
        sd fp, 8(sp)
        addi fp, sp, 32
        j lbl_main_1_main
        

##Generated Code
lbl_div_by_zero_0_main:
        # la a0, lbl_div_by_zero_0_main_msg
        la
        # end la a0, lbl_div_by_zero_0_main_msg
        # call println_string
        call
        # end call println_string
        # li a0, 1
        li
        # end li a0, 1
        # call exit
        call
        # end call exit
        j lbl_div_by_zero_0_main_msg
lbl_div_by_zero_0_main_msg:
        # .string "Division by 0"
        .string
        # end .string "Division by 0"
        j lbl_end_1_main
lbl_main_1_main:
        # (stat (print_stat println_int ( (expr (atom 42)) ) ;))
        # li temp_0, 42
        li
        # end li temp_0, 42
        # mv a0, temp_0
        mv
        # end mv a0, temp_0
        # call println_int
        call
        # end call println_int
        # Return at end of function:
        # li a0, 0
        li
        # end li a0, 0
        j lbl_end_1_main


##postlude

lbl_end_1_main:
        ld ra, 0(sp)
        ld fp, 8(sp)
        addi sp, sp, 32
        ret
        
______ TestCodeGen.test_alloc_mem[./TP04/tests/provided/step1/test00b.c] _______

self = <test_codegen.TestCodeGen object at 0x7fab86683370>
output_name = './TP04/tests/provided/step1/test00b-all_in_mem.s'
exec_name = './TP04/tests/provided/step1/test00b.riscv'
info = testinfo(exitcode=0, execcode=0, output='', linkargs=[], skip_test_expected=False)

    def link_and_run(self, output_name, exec_name, info):
        self.remove(exec_name)
        cmd = [
            ASM, output_name, 'TP04/libprint.s',
            '-o', exec_name
        ] + info.linkargs
        print(info)
        print("Assembling and linking " + output_name + ": " + ' '.join(cmd))
        try:
>           subprocess.check_output(cmd, timeout=60, stderr=subprocess.STDOUT)

test_codegen.py:169: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

timeout = 60
popenargs = (['riscv64-unknown-elf-gcc', './TP04/tests/provided/step1/test00b-all_in_mem.s', 'TP04/libprint.s', '-o', './TP04/tests/provided/step1/test00b.riscv'],)
kwargs = {'stderr': -2}

    def check_output(*popenargs, timeout=None, **kwargs):
        r"""Run command with arguments and return its output.
    
        If the exit code was non-zero it raises a CalledProcessError.  The
        CalledProcessError object will have the return code in the returncode
        attribute and output in the output attribute.
    
        The arguments are the same as for the Popen constructor.  Example:
    
        >>> check_output(["ls", "-l", "/dev/null"])
        b'crw-rw-rw- 1 root root 1, 3 Oct 18  2007 /dev/null\n'
    
        The stdout argument is not allowed as it is used internally.
        To capture standard error in the result, use stderr=STDOUT.
    
        >>> check_output(["/bin/sh", "-c",
        ...               "ls -l non_existent_file ; exit 0"],
        ...              stderr=STDOUT)
        b'ls: non_existent_file: No such file or directory\n'
    
        There is an additional optional argument, "input", allowing you to
        pass a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it too will be used internally.  Example:
    
        >>> check_output(["sed", "-e", "s/foo/bar/"],
        ...              input=b"when in the course of fooman events\n")
        b'when in the course of barman events\n'
    
        By default, all communication is in bytes, and therefore any "input"
        should be bytes, and the return value will be bytes.  If in text mode,
        any "input" should be a string, and the return value will be a string
        decoded according to locale encoding, or by "encoding" if set. Text mode
        is triggered by setting any of text, encoding, errors or universal_newlines.
        """
        if 'stdout' in kwargs:
            raise ValueError('stdout argument not allowed, it will be overridden.')
    
        if 'input' in kwargs and kwargs['input'] is None:
            # Explicitly passing input=None was previously equivalent to passing an
            # empty string. That is maintained here for backwards compatibility.
            if kwargs.get('universal_newlines') or kwargs.get('text'):
                empty = ''
            else:
                empty = b''
            kwargs['input'] = empty
    
>       return run(*popenargs, stdout=PIPE, timeout=timeout, check=True,
                   **kwargs).stdout

/usr/lib/python3.8/subprocess.py:415: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = False, timeout = 60, check = True
popenargs = (['riscv64-unknown-elf-gcc', './TP04/tests/provided/step1/test00b-all_in_mem.s', 'TP04/libprint.s', '-o', './TP04/tests/provided/step1/test00b.riscv'],)
kwargs = {'stderr': -2, 'stdout': -1}
process = <subprocess.Popen object at 0x7fab86683af0>
stdout = b"./TP04/tests/provided/step1/test00b-all_in_mem.s: Assembler messages:\n./TP04/tests/provided/step1/test00b-all_in_me...:58: Error: illegal operands `mv'\n./TP04/tests/provided/step1/test00b-all_in_mem.s:62: Error: illegal operands `li'\n"
stderr = None, retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout is given, and the process takes too long, a TimeoutExpired
        exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['riscv64-unknown-elf-gcc', './TP04/tests/provided/step1/test00b-all_in_mem.s', 'TP04/libprint.s', '-o', './TP04/tests/provided/step1/test00b.riscv']' returned non-zero exit status 1.

/usr/lib/python3.8/subprocess.py:516: CalledProcessError

During handling of the above exception, another exception occurred:

self = <test_codegen.TestCodeGen object at 0x7fab86683370>
filename = './TP04/tests/provided/step1/test00b.c'

    @pytest.mark.parametrize('filename', ALL_IN_MEM_FILES)
    def test_alloc_mem(self, filename):
        expect = self.get_expect(filename)
>       actual = self.all_in_mem(filename, expect)

test_codegen.py:242: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
test_codegen.py:100: in all_in_mem
    return self.compile_and_simulate(file, info, reg_alloc='all_in_mem')
test_codegen.py:216: in compile_and_simulate
    return self.link_and_run(output_name, exec_name, info)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_codegen.TestCodeGen object at 0x7fab86683370>
output_name = './TP04/tests/provided/step1/test00b-all_in_mem.s'
exec_name = './TP04/tests/provided/step1/test00b.riscv'
info = testinfo(exitcode=0, execcode=0, output='', linkargs=[], skip_test_expected=False)

    def link_and_run(self, output_name, exec_name, info):
        self.remove(exec_name)
        cmd = [
            ASM, output_name, 'TP04/libprint.s',
            '-o', exec_name
        ] + info.linkargs
        print(info)
        print("Assembling and linking " + output_name + ": " + ' '.join(cmd))
        try:
            subprocess.check_output(cmd, timeout=60, stderr=subprocess.STDOUT)
        except subprocess.CalledProcessError as e:
            print("Assembling failed:\n")
            print(e.output.decode())
            print("Assembler code below:\n")
            cat(output_name)
>           pytest.fail()
E           Failed

test_codegen.py:175: Failed
----------------------------- Captured stdout call -----------------------------
Compiling ...
/usr/bin/python3 ./MiniCC.py --reg-alloc=all_in_mem --output=./TP04/tests/provided/step1/test00b-all_in_mem.s ./TP04/tests/provided/step1/test00b.c
Exited with status: 0

Compiling ... OK
testinfo(exitcode=0, execcode=0, output='', linkargs=[], skip_test_expected=False)
Assembling and linking ./TP04/tests/provided/step1/test00b-all_in_mem.s: riscv64-unknown-elf-gcc ./TP04/tests/provided/step1/test00b-all_in_mem.s TP04/libprint.s -o ./TP04/tests/provided/step1/test00b.riscv
Assembling failed:

./TP04/tests/provided/step1/test00b-all_in_mem.s: Assembler messages:
./TP04/tests/provided/step1/test00b-all_in_mem.s:20: Error: illegal operands `la'
./TP04/tests/provided/step1/test00b-all_in_mem.s:26: Error: illegal operands `li'
./TP04/tests/provided/step1/test00b-all_in_mem.s:38: Error: illegal operands `li'
./TP04/tests/provided/step1/test00b-all_in_mem.s:41: Error: illegal operands `li'
./TP04/tests/provided/step1/test00b-all_in_mem.s:45: Error: illegal operands `li'
./TP04/tests/provided/step1/test00b-all_in_mem.s:48: Error: illegal operands `mv'
./TP04/tests/provided/step1/test00b-all_in_mem.s:52: Error: illegal operands `li'
./TP04/tests/provided/step1/test00b-all_in_mem.s:55: Error: illegal operands `add'
./TP04/tests/provided/step1/test00b-all_in_mem.s:58: Error: illegal operands `mv'
./TP04/tests/provided/step1/test00b-all_in_mem.s:62: Error: illegal operands `li'

Assembler code below:

##Automatically generated RISCV code, MIF08 & CAP
## all-in-memory allocation


##prelude

        .text
        .globl main
main:
        addi sp, sp, -64
        sd ra, 0(sp)
        sd fp, 8(sp)
        addi fp, sp, 64
        j lbl_main_1_main
        

##Generated Code
lbl_div_by_zero_0_main:
        # la a0, lbl_div_by_zero_0_main_msg
        la
        # end la a0, lbl_div_by_zero_0_main_msg
        # call println_string
        call
        # end call println_string
        # li a0, 1
        li
        # end li a0, 1
        # call exit
        call
        # end call exit
        j lbl_div_by_zero_0_main_msg
lbl_div_by_zero_0_main_msg:
        # .string "Division by 0"
        .string
        # end .string "Division by 0"
        j lbl_end_1_main
lbl_main_1_main:
        # li temp_0, 0
        li
        # end li temp_0, 0
        # li temp_1, 0
        li
        # end li temp_1, 0
        # (stat (assignment x = (expr (atom 4))) ;)
        # li temp_2, 4
        li
        # end li temp_2, 4
        # mv temp_1, temp_2
        mv
        # end mv temp_1, temp_2
        # (stat (assignment y = (expr (expr (atom 12)) + (expr (atom x)))) ;)
        # li temp_3, 12
        li
        # end li temp_3, 12
        # add temp_4, temp_3, temp_1
        add
        # end add temp_4, temp_3, temp_1
        # mv temp_0, temp_4
        mv
        # end mv temp_0, temp_4
        # Return at end of function:
        # li a0, 0
        li
        # end li a0, 0
        j lbl_end_1_main


##postlude

lbl_end_1_main:
        ld ra, 0(sp)
        ld fp, 8(sp)
        addi sp, sp, 64
        ret
        
______ TestCodeGen.test_alloc_mem[./TP04/tests/provided/step1/test00d.c] _______

self = <test_codegen.TestCodeGen object at 0x7fab866b53d0>
output_name = './TP04/tests/provided/step1/test00d-all_in_mem.s'
exec_name = './TP04/tests/provided/step1/test00d.riscv'
info = testinfo(exitcode=0, execcode=0, output='', linkargs=[], skip_test_expected=False)

    def link_and_run(self, output_name, exec_name, info):
        self.remove(exec_name)
        cmd = [
            ASM, output_name, 'TP04/libprint.s',
            '-o', exec_name
        ] + info.linkargs
        print(info)
        print("Assembling and linking " + output_name + ": " + ' '.join(cmd))
        try:
>           subprocess.check_output(cmd, timeout=60, stderr=subprocess.STDOUT)

test_codegen.py:169: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

timeout = 60
popenargs = (['riscv64-unknown-elf-gcc', './TP04/tests/provided/step1/test00d-all_in_mem.s', 'TP04/libprint.s', '-o', './TP04/tests/provided/step1/test00d.riscv'],)
kwargs = {'stderr': -2}

    def check_output(*popenargs, timeout=None, **kwargs):
        r"""Run command with arguments and return its output.
    
        If the exit code was non-zero it raises a CalledProcessError.  The
        CalledProcessError object will have the return code in the returncode
        attribute and output in the output attribute.
    
        The arguments are the same as for the Popen constructor.  Example:
    
        >>> check_output(["ls", "-l", "/dev/null"])
        b'crw-rw-rw- 1 root root 1, 3 Oct 18  2007 /dev/null\n'
    
        The stdout argument is not allowed as it is used internally.
        To capture standard error in the result, use stderr=STDOUT.
    
        >>> check_output(["/bin/sh", "-c",
        ...               "ls -l non_existent_file ; exit 0"],
        ...              stderr=STDOUT)
        b'ls: non_existent_file: No such file or directory\n'
    
        There is an additional optional argument, "input", allowing you to
        pass a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it too will be used internally.  Example:
    
        >>> check_output(["sed", "-e", "s/foo/bar/"],
        ...              input=b"when in the course of fooman events\n")
        b'when in the course of barman events\n'
    
        By default, all communication is in bytes, and therefore any "input"
        should be bytes, and the return value will be bytes.  If in text mode,
        any "input" should be a string, and the return value will be a string
        decoded according to locale encoding, or by "encoding" if set. Text mode
        is triggered by setting any of text, encoding, errors or universal_newlines.
        """
        if 'stdout' in kwargs:
            raise ValueError('stdout argument not allowed, it will be overridden.')
    
        if 'input' in kwargs and kwargs['input'] is None:
            # Explicitly passing input=None was previously equivalent to passing an
            # empty string. That is maintained here for backwards compatibility.
            if kwargs.get('universal_newlines') or kwargs.get('text'):
                empty = ''
            else:
                empty = b''
            kwargs['input'] = empty
    
>       return run(*popenargs, stdout=PIPE, timeout=timeout, check=True,
                   **kwargs).stdout

/usr/lib/python3.8/subprocess.py:415: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = False, timeout = 60, check = True
popenargs = (['riscv64-unknown-elf-gcc', './TP04/tests/provided/step1/test00d-all_in_mem.s', 'TP04/libprint.s', '-o', './TP04/tests/provided/step1/test00d.riscv'],)
kwargs = {'stderr': -2, 'stdout': -1}
process = <subprocess.Popen object at 0x7fab866b5370>
stdout = b"./TP04/tests/provided/step1/test00d-all_in_mem.s: Assembler messages:\n./TP04/tests/provided/step1/test00d-all_in_me...:58: Error: illegal operands `mv'\n./TP04/tests/provided/step1/test00d-all_in_mem.s:62: Error: illegal operands `li'\n"
stderr = None, retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout is given, and the process takes too long, a TimeoutExpired
        exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['riscv64-unknown-elf-gcc', './TP04/tests/provided/step1/test00d-all_in_mem.s', 'TP04/libprint.s', '-o', './TP04/tests/provided/step1/test00d.riscv']' returned non-zero exit status 1.

/usr/lib/python3.8/subprocess.py:516: CalledProcessError

During handling of the above exception, another exception occurred:

self = <test_codegen.TestCodeGen object at 0x7fab866b53d0>
filename = './TP04/tests/provided/step1/test00d.c'

    @pytest.mark.parametrize('filename', ALL_IN_MEM_FILES)
    def test_alloc_mem(self, filename):
        expect = self.get_expect(filename)
>       actual = self.all_in_mem(filename, expect)

test_codegen.py:242: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
test_codegen.py:100: in all_in_mem
    return self.compile_and_simulate(file, info, reg_alloc='all_in_mem')
test_codegen.py:216: in compile_and_simulate
    return self.link_and_run(output_name, exec_name, info)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_codegen.TestCodeGen object at 0x7fab866b53d0>
output_name = './TP04/tests/provided/step1/test00d-all_in_mem.s'
exec_name = './TP04/tests/provided/step1/test00d.riscv'
info = testinfo(exitcode=0, execcode=0, output='', linkargs=[], skip_test_expected=False)

    def link_and_run(self, output_name, exec_name, info):
        self.remove(exec_name)
        cmd = [
            ASM, output_name, 'TP04/libprint.s',
            '-o', exec_name
        ] + info.linkargs
        print(info)
        print("Assembling and linking " + output_name + ": " + ' '.join(cmd))
        try:
            subprocess.check_output(cmd, timeout=60, stderr=subprocess.STDOUT)
        except subprocess.CalledProcessError as e:
            print("Assembling failed:\n")
            print(e.output.decode())
            print("Assembler code below:\n")
            cat(output_name)
>           pytest.fail()
E           Failed

test_codegen.py:175: Failed
----------------------------- Captured stdout call -----------------------------
Compiling ...
/usr/bin/python3 ./MiniCC.py --reg-alloc=all_in_mem --output=./TP04/tests/provided/step1/test00d-all_in_mem.s ./TP04/tests/provided/step1/test00d.c
Exited with status: 0

Compiling ... OK
testinfo(exitcode=0, execcode=0, output='', linkargs=[], skip_test_expected=False)
Assembling and linking ./TP04/tests/provided/step1/test00d-all_in_mem.s: riscv64-unknown-elf-gcc ./TP04/tests/provided/step1/test00d-all_in_mem.s TP04/libprint.s -o ./TP04/tests/provided/step1/test00d.riscv
Assembling failed:

./TP04/tests/provided/step1/test00d-all_in_mem.s: Assembler messages:
./TP04/tests/provided/step1/test00d-all_in_mem.s:20: Error: illegal operands `la'
./TP04/tests/provided/step1/test00d-all_in_mem.s:26: Error: illegal operands `li'
./TP04/tests/provided/step1/test00d-all_in_mem.s:38: Error: illegal operands `li'
./TP04/tests/provided/step1/test00d-all_in_mem.s:41: Error: illegal operands `li'
./TP04/tests/provided/step1/test00d-all_in_mem.s:45: Error: illegal operands `li'
./TP04/tests/provided/step1/test00d-all_in_mem.s:48: Error: illegal operands `mv'
./TP04/tests/provided/step1/test00d-all_in_mem.s:52: Error: illegal operands `li'
./TP04/tests/provided/step1/test00d-all_in_mem.s:55: Error: illegal operands `add'
./TP04/tests/provided/step1/test00d-all_in_mem.s:58: Error: illegal operands `mv'
./TP04/tests/provided/step1/test00d-all_in_mem.s:62: Error: illegal operands `li'

Assembler code below:

##Automatically generated RISCV code, MIF08 & CAP
## all-in-memory allocation


##prelude

        .text
        .globl main
main:
        addi sp, sp, -64
        sd ra, 0(sp)
        sd fp, 8(sp)
        addi fp, sp, 64
        j lbl_main_1_main
        

##Generated Code
lbl_div_by_zero_0_main:
        # la a0, lbl_div_by_zero_0_main_msg
        la
        # end la a0, lbl_div_by_zero_0_main_msg
        # call println_string
        call
        # end call println_string
        # li a0, 1
        li
        # end li a0, 1
        # call exit
        call
        # end call exit
        j lbl_div_by_zero_0_main_msg
lbl_div_by_zero_0_main_msg:
        # .string "Division by 0"
        .string
        # end .string "Division by 0"
        j lbl_end_1_main
lbl_main_1_main:
        # li temp_0, 0
        li
        # end li temp_0, 0
        # li temp_1, 0
        li
        # end li temp_1, 0
        # (stat (assignment n = (expr (atom 1))) ;)
        # li temp_2, 1
        li
        # end li temp_2, 1
        # mv temp_0, temp_2
        mv
        # end mv temp_0, temp_2
        # (stat (assignment a = (expr (expr (atom n)) + (expr (atom 12)))) ;)
        # li temp_3, 12
        li
        # end li temp_3, 12
        # add temp_4, temp_0, temp_3
        add
        # end add temp_4, temp_0, temp_3
        # mv temp_1, temp_4
        mv
        # end mv temp_1, temp_4
        # Return at end of function:
        # li a0, 0
        li
        # end li a0, 0
        j lbl_end_1_main


##postlude

lbl_end_1_main:
        ld ra, 0(sp)
        ld fp, 8(sp)
        addi sp, sp, 64
        ret
        
_______ TestCodeGen.test_alloc_mem[./TP04/tests/provided/step1/test01.c] _______

self = <test_codegen.TestCodeGen object at 0x7fab8682f5e0>
output_name = './TP04/tests/provided/step1/test01-all_in_mem.s'
exec_name = './TP04/tests/provided/step1/test01.riscv'
info = testinfo(exitcode=0, execcode=0, output='', linkargs=[], skip_test_expected=False)

    def link_and_run(self, output_name, exec_name, info):
        self.remove(exec_name)
        cmd = [
            ASM, output_name, 'TP04/libprint.s',
            '-o', exec_name
        ] + info.linkargs
        print(info)
        print("Assembling and linking " + output_name + ": " + ' '.join(cmd))
        try:
>           subprocess.check_output(cmd, timeout=60, stderr=subprocess.STDOUT)

test_codegen.py:169: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

timeout = 60
popenargs = (['riscv64-unknown-elf-gcc', './TP04/tests/provided/step1/test01-all_in_mem.s', 'TP04/libprint.s', '-o', './TP04/tests/provided/step1/test01.riscv'],)
kwargs = {'stderr': -2}

    def check_output(*popenargs, timeout=None, **kwargs):
        r"""Run command with arguments and return its output.
    
        If the exit code was non-zero it raises a CalledProcessError.  The
        CalledProcessError object will have the return code in the returncode
        attribute and output in the output attribute.
    
        The arguments are the same as for the Popen constructor.  Example:
    
        >>> check_output(["ls", "-l", "/dev/null"])
        b'crw-rw-rw- 1 root root 1, 3 Oct 18  2007 /dev/null\n'
    
        The stdout argument is not allowed as it is used internally.
        To capture standard error in the result, use stderr=STDOUT.
    
        >>> check_output(["/bin/sh", "-c",
        ...               "ls -l non_existent_file ; exit 0"],
        ...              stderr=STDOUT)
        b'ls: non_existent_file: No such file or directory\n'
    
        There is an additional optional argument, "input", allowing you to
        pass a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it too will be used internally.  Example:
    
        >>> check_output(["sed", "-e", "s/foo/bar/"],
        ...              input=b"when in the course of fooman events\n")
        b'when in the course of barman events\n'
    
        By default, all communication is in bytes, and therefore any "input"
        should be bytes, and the return value will be bytes.  If in text mode,
        any "input" should be a string, and the return value will be a string
        decoded according to locale encoding, or by "encoding" if set. Text mode
        is triggered by setting any of text, encoding, errors or universal_newlines.
        """
        if 'stdout' in kwargs:
            raise ValueError('stdout argument not allowed, it will be overridden.')
    
        if 'input' in kwargs and kwargs['input'] is None:
            # Explicitly passing input=None was previously equivalent to passing an
            # empty string. That is maintained here for backwards compatibility.
            if kwargs.get('universal_newlines') or kwargs.get('text'):
                empty = ''
            else:
                empty = b''
            kwargs['input'] = empty
    
>       return run(*popenargs, stdout=PIPE, timeout=timeout, check=True,
                   **kwargs).stdout

/usr/lib/python3.8/subprocess.py:415: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = False, timeout = 60, check = True
popenargs = (['riscv64-unknown-elf-gcc', './TP04/tests/provided/step1/test01-all_in_mem.s', 'TP04/libprint.s', '-o', './TP04/tests/provided/step1/test01.riscv'],)
kwargs = {'stderr': -2, 'stdout': -1}
process = <subprocess.Popen object at 0x7fab8682f340>
stdout = b"./TP04/tests/provided/step1/test01-all_in_mem.s: Assembler messages:\n./TP04/tests/provided/step1/test01-all_in_mem....s:45: Error: illegal operands `mv'\n./TP04/tests/provided/step1/test01-all_in_mem.s:49: Error: illegal operands `li'\n"
stderr = None, retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout is given, and the process takes too long, a TimeoutExpired
        exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['riscv64-unknown-elf-gcc', './TP04/tests/provided/step1/test01-all_in_mem.s', 'TP04/libprint.s', '-o', './TP04/tests/provided/step1/test01.riscv']' returned non-zero exit status 1.

/usr/lib/python3.8/subprocess.py:516: CalledProcessError

During handling of the above exception, another exception occurred:

self = <test_codegen.TestCodeGen object at 0x7fab8682f5e0>
filename = './TP04/tests/provided/step1/test01.c'

    @pytest.mark.parametrize('filename', ALL_IN_MEM_FILES)
    def test_alloc_mem(self, filename):
        expect = self.get_expect(filename)
>       actual = self.all_in_mem(filename, expect)

test_codegen.py:242: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
test_codegen.py:100: in all_in_mem
    return self.compile_and_simulate(file, info, reg_alloc='all_in_mem')
test_codegen.py:216: in compile_and_simulate
    return self.link_and_run(output_name, exec_name, info)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_codegen.TestCodeGen object at 0x7fab8682f5e0>
output_name = './TP04/tests/provided/step1/test01-all_in_mem.s'
exec_name = './TP04/tests/provided/step1/test01.riscv'
info = testinfo(exitcode=0, execcode=0, output='', linkargs=[], skip_test_expected=False)

    def link_and_run(self, output_name, exec_name, info):
        self.remove(exec_name)
        cmd = [
            ASM, output_name, 'TP04/libprint.s',
            '-o', exec_name
        ] + info.linkargs
        print(info)
        print("Assembling and linking " + output_name + ": " + ' '.join(cmd))
        try:
            subprocess.check_output(cmd, timeout=60, stderr=subprocess.STDOUT)
        except subprocess.CalledProcessError as e:
            print("Assembling failed:\n")
            print(e.output.decode())
            print("Assembler code below:\n")
            cat(output_name)
>           pytest.fail()
E           Failed

test_codegen.py:175: Failed
----------------------------- Captured stdout call -----------------------------
Compiling ...
/usr/bin/python3 ./MiniCC.py --reg-alloc=all_in_mem --output=./TP04/tests/provided/step1/test01-all_in_mem.s ./TP04/tests/provided/step1/test01.c
Exited with status: 0

Compiling ... OK
testinfo(exitcode=0, execcode=0, output='', linkargs=[], skip_test_expected=False)
Assembling and linking ./TP04/tests/provided/step1/test01-all_in_mem.s: riscv64-unknown-elf-gcc ./TP04/tests/provided/step1/test01-all_in_mem.s TP04/libprint.s -o ./TP04/tests/provided/step1/test01.riscv
Assembling failed:

./TP04/tests/provided/step1/test01-all_in_mem.s: Assembler messages:
./TP04/tests/provided/step1/test01-all_in_mem.s:20: Error: illegal operands `la'
./TP04/tests/provided/step1/test01-all_in_mem.s:26: Error: illegal operands `li'
./TP04/tests/provided/step1/test01-all_in_mem.s:38: Error: illegal operands `li'
./TP04/tests/provided/step1/test01-all_in_mem.s:42: Error: illegal operands `li'
./TP04/tests/provided/step1/test01-all_in_mem.s:45: Error: illegal operands `mv'
./TP04/tests/provided/step1/test01-all_in_mem.s:49: Error: illegal operands `li'

Assembler code below:

##Automatically generated RISCV code, MIF08 & CAP
## all-in-memory allocation


##prelude

        .text
        .globl main
main:
        addi sp, sp, -32
        sd ra, 0(sp)
        sd fp, 8(sp)
        addi fp, sp, 32
        j lbl_main_1_main
        

##Generated Code
lbl_div_by_zero_0_main:
        # la a0, lbl_div_by_zero_0_main_msg
        la
        # end la a0, lbl_div_by_zero_0_main_msg
        # call println_string
        call
        # end call println_string
        # li a0, 1
        li
        # end li a0, 1
        # call exit
        call
        # end call exit
        j lbl_div_by_zero_0_main_msg
lbl_div_by_zero_0_main_msg:
        # .string "Division by 0"
        .string
        # end .string "Division by 0"
        j lbl_end_1_main
lbl_main_1_main:
        # li temp_0, 0
        li
        # end li temp_0, 0
        # (stat (assignment n = (expr (atom 6))) ;)
        # li temp_1, 6
        li
        # end li temp_1, 6
        # mv temp_0, temp_1
        mv
        # end mv temp_0, temp_1
        # Return at end of function:
        # li a0, 0
        li
        # end li a0, 0
        j lbl_end_1_main


##postlude

lbl_end_1_main:
        ld ra, 0(sp)
        ld fp, 8(sp)
        addi sp, sp, 32
        ret
        
_____ TestCodeGen.test_alloc_mem[./TP04/tests/provided/step1/test_print.c] _____

self = <test_codegen.TestCodeGen object at 0x7fab868c0160>
output_name = './TP04/tests/provided/step1/test_print-all_in_mem.s'
exec_name = './TP04/tests/provided/step1/test_print.riscv'
info = testinfo(exitcode=0, execcode=0, output='43\n', linkargs=[], skip_test_expected=False)

    def link_and_run(self, output_name, exec_name, info):
        self.remove(exec_name)
        cmd = [
            ASM, output_name, 'TP04/libprint.s',
            '-o', exec_name
        ] + info.linkargs
        print(info)
        print("Assembling and linking " + output_name + ": " + ' '.join(cmd))
        try:
>           subprocess.check_output(cmd, timeout=60, stderr=subprocess.STDOUT)

test_codegen.py:169: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

timeout = 60
popenargs = (['riscv64-unknown-elf-gcc', './TP04/tests/provided/step1/test_print-all_in_mem.s', 'TP04/libprint.s', '-o', './TP04/tests/provided/step1/test_print.riscv'],)
kwargs = {'stderr': -2}

    def check_output(*popenargs, timeout=None, **kwargs):
        r"""Run command with arguments and return its output.
    
        If the exit code was non-zero it raises a CalledProcessError.  The
        CalledProcessError object will have the return code in the returncode
        attribute and output in the output attribute.
    
        The arguments are the same as for the Popen constructor.  Example:
    
        >>> check_output(["ls", "-l", "/dev/null"])
        b'crw-rw-rw- 1 root root 1, 3 Oct 18  2007 /dev/null\n'
    
        The stdout argument is not allowed as it is used internally.
        To capture standard error in the result, use stderr=STDOUT.
    
        >>> check_output(["/bin/sh", "-c",
        ...               "ls -l non_existent_file ; exit 0"],
        ...              stderr=STDOUT)
        b'ls: non_existent_file: No such file or directory\n'
    
        There is an additional optional argument, "input", allowing you to
        pass a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it too will be used internally.  Example:
    
        >>> check_output(["sed", "-e", "s/foo/bar/"],
        ...              input=b"when in the course of fooman events\n")
        b'when in the course of barman events\n'
    
        By default, all communication is in bytes, and therefore any "input"
        should be bytes, and the return value will be bytes.  If in text mode,
        any "input" should be a string, and the return value will be a string
        decoded according to locale encoding, or by "encoding" if set. Text mode
        is triggered by setting any of text, encoding, errors or universal_newlines.
        """
        if 'stdout' in kwargs:
            raise ValueError('stdout argument not allowed, it will be overridden.')
    
        if 'input' in kwargs and kwargs['input'] is None:
            # Explicitly passing input=None was previously equivalent to passing an
            # empty string. That is maintained here for backwards compatibility.
            if kwargs.get('universal_newlines') or kwargs.get('text'):
                empty = ''
            else:
                empty = b''
            kwargs['input'] = empty
    
>       return run(*popenargs, stdout=PIPE, timeout=timeout, check=True,
                   **kwargs).stdout

/usr/lib/python3.8/subprocess.py:415: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = False, timeout = 60, check = True
popenargs = (['riscv64-unknown-elf-gcc', './TP04/tests/provided/step1/test_print-all_in_mem.s', 'TP04/libprint.s', '-o', './TP04/tests/provided/step1/test_print.riscv'],)
kwargs = {'stderr': -2, 'stdout': -1}
process = <subprocess.Popen object at 0x7fab868c0640>
stdout = b"./TP04/tests/provided/step1/test_print-all_in_mem.s: Assembler messages:\n./TP04/tests/provided/step1/test_print-all...: Error: illegal operands `mv'\n./TP04/tests/provided/step1/test_print-all_in_mem.s:49: Error: illegal operands `li'\n"
stderr = None, retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout is given, and the process takes too long, a TimeoutExpired
        exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['riscv64-unknown-elf-gcc', './TP04/tests/provided/step1/test_print-all_in_mem.s', 'TP04/libprint.s', '-o', './TP04/tests/provided/step1/test_print.riscv']' returned non-zero exit status 1.

/usr/lib/python3.8/subprocess.py:516: CalledProcessError

During handling of the above exception, another exception occurred:

self = <test_codegen.TestCodeGen object at 0x7fab868c0160>
filename = './TP04/tests/provided/step1/test_print.c'

    @pytest.mark.parametrize('filename', ALL_IN_MEM_FILES)
    def test_alloc_mem(self, filename):
        expect = self.get_expect(filename)
>       actual = self.all_in_mem(filename, expect)

test_codegen.py:242: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
test_codegen.py:100: in all_in_mem
    return self.compile_and_simulate(file, info, reg_alloc='all_in_mem')
test_codegen.py:216: in compile_and_simulate
    return self.link_and_run(output_name, exec_name, info)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_codegen.TestCodeGen object at 0x7fab868c0160>
output_name = './TP04/tests/provided/step1/test_print-all_in_mem.s'
exec_name = './TP04/tests/provided/step1/test_print.riscv'
info = testinfo(exitcode=0, execcode=0, output='43\n', linkargs=[], skip_test_expected=False)

    def link_and_run(self, output_name, exec_name, info):
        self.remove(exec_name)
        cmd = [
            ASM, output_name, 'TP04/libprint.s',
            '-o', exec_name
        ] + info.linkargs
        print(info)
        print("Assembling and linking " + output_name + ": " + ' '.join(cmd))
        try:
            subprocess.check_output(cmd, timeout=60, stderr=subprocess.STDOUT)
        except subprocess.CalledProcessError as e:
            print("Assembling failed:\n")
            print(e.output.decode())
            print("Assembler code below:\n")
            cat(output_name)
>           pytest.fail()
E           Failed

test_codegen.py:175: Failed
----------------------------- Captured stdout call -----------------------------
Compiling ...
/usr/bin/python3 ./MiniCC.py --reg-alloc=all_in_mem --output=./TP04/tests/provided/step1/test_print-all_in_mem.s ./TP04/tests/provided/step1/test_print.c
Exited with status: 0

Compiling ... OK
testinfo(exitcode=0, execcode=0, output='43\n', linkargs=[], skip_test_expected=False)
Assembling and linking ./TP04/tests/provided/step1/test_print-all_in_mem.s: riscv64-unknown-elf-gcc ./TP04/tests/provided/step1/test_print-all_in_mem.s TP04/libprint.s -o ./TP04/tests/provided/step1/test_print.riscv
Assembling failed:

./TP04/tests/provided/step1/test_print-all_in_mem.s: Assembler messages:
./TP04/tests/provided/step1/test_print-all_in_mem.s:20: Error: illegal operands `la'
./TP04/tests/provided/step1/test_print-all_in_mem.s:26: Error: illegal operands `li'
./TP04/tests/provided/step1/test_print-all_in_mem.s:39: Error: illegal operands `li'
./TP04/tests/provided/step1/test_print-all_in_mem.s:42: Error: illegal operands `mv'
./TP04/tests/provided/step1/test_print-all_in_mem.s:49: Error: illegal operands `li'

Assembler code below:

##Automatically generated RISCV code, MIF08 & CAP
## all-in-memory allocation


##prelude

        .text
        .globl main
main:
        addi sp, sp, -32
        sd ra, 0(sp)
        sd fp, 8(sp)
        addi fp, sp, 32
        j lbl_main_1_main
        

##Generated Code
lbl_div_by_zero_0_main:
        # la a0, lbl_div_by_zero_0_main_msg
        la
        # end la a0, lbl_div_by_zero_0_main_msg
        # call println_string
        call
        # end call println_string
        # li a0, 1
        li
        # end li a0, 1
        # call exit
        call
        # end call exit
        j lbl_div_by_zero_0_main_msg
lbl_div_by_zero_0_main_msg:
        # .string "Division by 0"
        .string
        # end .string "Division by 0"
        j lbl_end_1_main
lbl_main_1_main:
        # (stat (print_stat println_int ( (expr (atom 43)) ) ;))
        # li temp_0, 43
        li
        # end li temp_0, 43
        # mv a0, temp_0
        mv
        # end mv a0, temp_0
        # call println_int
        call
        # end call println_int
        # Return at end of function:
        # li a0, 0
        li
        # end li a0, 0
        j lbl_end_1_main


##postlude

lbl_end_1_main:
        ld ra, 0(sp)
        ld fp, 8(sp)
        addi sp, sp, 32
        ret
        
______ TestCodeGen.test_alloc_mem[./TP04/tests/provided/step1/test_var.c] ______

self = <test_codegen.TestCodeGen object at 0x7fab86a7e820>
output_name = './TP04/tests/provided/step1/test_var-all_in_mem.s'
exec_name = './TP04/tests/provided/step1/test_var.riscv'
info = testinfo(exitcode=0, execcode=0, output='42\n', linkargs=[], skip_test_expected=False)

    def link_and_run(self, output_name, exec_name, info):
        self.remove(exec_name)
        cmd = [
            ASM, output_name, 'TP04/libprint.s',
            '-o', exec_name
        ] + info.linkargs
        print(info)
        print("Assembling and linking " + output_name + ": " + ' '.join(cmd))
        try:
>           subprocess.check_output(cmd, timeout=60, stderr=subprocess.STDOUT)

test_codegen.py:169: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

timeout = 60
popenargs = (['riscv64-unknown-elf-gcc', './TP04/tests/provided/step1/test_var-all_in_mem.s', 'TP04/libprint.s', '-o', './TP04/tests/provided/step1/test_var.riscv'],)
kwargs = {'stderr': -2}

    def check_output(*popenargs, timeout=None, **kwargs):
        r"""Run command with arguments and return its output.
    
        If the exit code was non-zero it raises a CalledProcessError.  The
        CalledProcessError object will have the return code in the returncode
        attribute and output in the output attribute.
    
        The arguments are the same as for the Popen constructor.  Example:
    
        >>> check_output(["ls", "-l", "/dev/null"])
        b'crw-rw-rw- 1 root root 1, 3 Oct 18  2007 /dev/null\n'
    
        The stdout argument is not allowed as it is used internally.
        To capture standard error in the result, use stderr=STDOUT.
    
        >>> check_output(["/bin/sh", "-c",
        ...               "ls -l non_existent_file ; exit 0"],
        ...              stderr=STDOUT)
        b'ls: non_existent_file: No such file or directory\n'
    
        There is an additional optional argument, "input", allowing you to
        pass a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it too will be used internally.  Example:
    
        >>> check_output(["sed", "-e", "s/foo/bar/"],
        ...              input=b"when in the course of fooman events\n")
        b'when in the course of barman events\n'
    
        By default, all communication is in bytes, and therefore any "input"
        should be bytes, and the return value will be bytes.  If in text mode,
        any "input" should be a string, and the return value will be a string
        decoded according to locale encoding, or by "encoding" if set. Text mode
        is triggered by setting any of text, encoding, errors or universal_newlines.
        """
        if 'stdout' in kwargs:
            raise ValueError('stdout argument not allowed, it will be overridden.')
    
        if 'input' in kwargs and kwargs['input'] is None:
            # Explicitly passing input=None was previously equivalent to passing an
            # empty string. That is maintained here for backwards compatibility.
            if kwargs.get('universal_newlines') or kwargs.get('text'):
                empty = ''
            else:
                empty = b''
            kwargs['input'] = empty
    
>       return run(*popenargs, stdout=PIPE, timeout=timeout, check=True,
                   **kwargs).stdout

/usr/lib/python3.8/subprocess.py:415: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = False, timeout = 60, check = True
popenargs = (['riscv64-unknown-elf-gcc', './TP04/tests/provided/step1/test_var-all_in_mem.s', 'TP04/libprint.s', '-o', './TP04/tests/provided/step1/test_var.riscv'],)
kwargs = {'stderr': -2, 'stdout': -1}
process = <subprocess.Popen object at 0x7fab86a7e790>
stdout = b"./TP04/tests/provided/step1/test_var-all_in_mem.s: Assembler messages:\n./TP04/tests/provided/step1/test_var-all_in_...49: Error: illegal operands `mv'\n./TP04/tests/provided/step1/test_var-all_in_mem.s:56: Error: illegal operands `li'\n"
stderr = None, retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout is given, and the process takes too long, a TimeoutExpired
        exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['riscv64-unknown-elf-gcc', './TP04/tests/provided/step1/test_var-all_in_mem.s', 'TP04/libprint.s', '-o', './TP04/tests/provided/step1/test_var.riscv']' returned non-zero exit status 1.

/usr/lib/python3.8/subprocess.py:516: CalledProcessError

During handling of the above exception, another exception occurred:

self = <test_codegen.TestCodeGen object at 0x7fab86a7e820>
filename = './TP04/tests/provided/step1/test_var.c'

    @pytest.mark.parametrize('filename', ALL_IN_MEM_FILES)
    def test_alloc_mem(self, filename):
        expect = self.get_expect(filename)
>       actual = self.all_in_mem(filename, expect)

test_codegen.py:242: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
test_codegen.py:100: in all_in_mem
    return self.compile_and_simulate(file, info, reg_alloc='all_in_mem')
test_codegen.py:216: in compile_and_simulate
    return self.link_and_run(output_name, exec_name, info)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_codegen.TestCodeGen object at 0x7fab86a7e820>
output_name = './TP04/tests/provided/step1/test_var-all_in_mem.s'
exec_name = './TP04/tests/provided/step1/test_var.riscv'
info = testinfo(exitcode=0, execcode=0, output='42\n', linkargs=[], skip_test_expected=False)

    def link_and_run(self, output_name, exec_name, info):
        self.remove(exec_name)
        cmd = [
            ASM, output_name, 'TP04/libprint.s',
            '-o', exec_name
        ] + info.linkargs
        print(info)
        print("Assembling and linking " + output_name + ": " + ' '.join(cmd))
        try:
            subprocess.check_output(cmd, timeout=60, stderr=subprocess.STDOUT)
        except subprocess.CalledProcessError as e:
            print("Assembling failed:\n")
            print(e.output.decode())
            print("Assembler code below:\n")
            cat(output_name)
>           pytest.fail()
E           Failed

test_codegen.py:175: Failed
----------------------------- Captured stdout call -----------------------------
Compiling ...
/usr/bin/python3 ./MiniCC.py --reg-alloc=all_in_mem --output=./TP04/tests/provided/step1/test_var-all_in_mem.s ./TP04/tests/provided/step1/test_var.c
Exited with status: 0

Compiling ... OK
testinfo(exitcode=0, execcode=0, output='42\n', linkargs=[], skip_test_expected=False)
Assembling and linking ./TP04/tests/provided/step1/test_var-all_in_mem.s: riscv64-unknown-elf-gcc ./TP04/tests/provided/step1/test_var-all_in_mem.s TP04/libprint.s -o ./TP04/tests/provided/step1/test_var.riscv
Assembling failed:

./TP04/tests/provided/step1/test_var-all_in_mem.s: Assembler messages:
./TP04/tests/provided/step1/test_var-all_in_mem.s:20: Error: illegal operands `la'
./TP04/tests/provided/step1/test_var-all_in_mem.s:26: Error: illegal operands `li'
./TP04/tests/provided/step1/test_var-all_in_mem.s:38: Error: illegal operands `li'
./TP04/tests/provided/step1/test_var-all_in_mem.s:42: Error: illegal operands `li'
./TP04/tests/provided/step1/test_var-all_in_mem.s:45: Error: illegal operands `mv'
./TP04/tests/provided/step1/test_var-all_in_mem.s:49: Error: illegal operands `mv'
./TP04/tests/provided/step1/test_var-all_in_mem.s:56: Error: illegal operands `li'

Assembler code below:

##Automatically generated RISCV code, MIF08 & CAP
## all-in-memory allocation


##prelude

        .text
        .globl main
main:
        addi sp, sp, -32
        sd ra, 0(sp)
        sd fp, 8(sp)
        addi fp, sp, 32
        j lbl_main_1_main
        

##Generated Code
lbl_div_by_zero_0_main:
        # la a0, lbl_div_by_zero_0_main_msg
        la
        # end la a0, lbl_div_by_zero_0_main_msg
        # call println_string
        call
        # end call println_string
        # li a0, 1
        li
        # end li a0, 1
        # call exit
        call
        # end call exit
        j lbl_div_by_zero_0_main_msg
lbl_div_by_zero_0_main_msg:
        # .string "Division by 0"
        .string
        # end .string "Division by 0"
        j lbl_end_1_main
lbl_main_1_main:
        # li temp_0, 0
        li
        # end li temp_0, 0
        # (stat (assignment x = (expr (atom 42))) ;)
        # li temp_1, 42
        li
        # end li temp_1, 42
        # mv temp_0, temp_1
        mv
        # end mv temp_0, temp_1
        # (stat (print_stat println_int ( (expr (atom x)) ) ;))
        # mv a0, temp_0
        mv
        # end mv a0, temp_0
        # call println_int
        call
        # end call println_int
        # Return at end of function:
        # li a0, 0
        li
        # end li a0, 0
        j lbl_end_1_main


##postlude

lbl_end_1_main:
        ld ra, 0(sp)
        ld fp, 8(sp)
        addi sp, sp, 32
        ret
        
___ TestCodeGen.test_alloc_mem[./TP04/tests/provided/step1/test_var_plus.c] ____

self = <test_codegen.TestCodeGen object at 0x7fab869cefd0>
output_name = './TP04/tests/provided/step1/test_var_plus-all_in_mem.s'
exec_name = './TP04/tests/provided/step1/test_var_plus.riscv'
info = testinfo(exitcode=0, execcode=0, output='84\n43\n43\n', linkargs=[], skip_test_expected=False)

    def link_and_run(self, output_name, exec_name, info):
        self.remove(exec_name)
        cmd = [
            ASM, output_name, 'TP04/libprint.s',
            '-o', exec_name
        ] + info.linkargs
        print(info)
        print("Assembling and linking " + output_name + ": " + ' '.join(cmd))
        try:
>           subprocess.check_output(cmd, timeout=60, stderr=subprocess.STDOUT)

test_codegen.py:169: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

timeout = 60
popenargs = (['riscv64-unknown-elf-gcc', './TP04/tests/provided/step1/test_var_plus-all_in_mem.s', 'TP04/libprint.s', '-o', './TP04/tests/provided/step1/test_var_plus.riscv'],)
kwargs = {'stderr': -2}

    def check_output(*popenargs, timeout=None, **kwargs):
        r"""Run command with arguments and return its output.
    
        If the exit code was non-zero it raises a CalledProcessError.  The
        CalledProcessError object will have the return code in the returncode
        attribute and output in the output attribute.
    
        The arguments are the same as for the Popen constructor.  Example:
    
        >>> check_output(["ls", "-l", "/dev/null"])
        b'crw-rw-rw- 1 root root 1, 3 Oct 18  2007 /dev/null\n'
    
        The stdout argument is not allowed as it is used internally.
        To capture standard error in the result, use stderr=STDOUT.
    
        >>> check_output(["/bin/sh", "-c",
        ...               "ls -l non_existent_file ; exit 0"],
        ...              stderr=STDOUT)
        b'ls: non_existent_file: No such file or directory\n'
    
        There is an additional optional argument, "input", allowing you to
        pass a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it too will be used internally.  Example:
    
        >>> check_output(["sed", "-e", "s/foo/bar/"],
        ...              input=b"when in the course of fooman events\n")
        b'when in the course of barman events\n'
    
        By default, all communication is in bytes, and therefore any "input"
        should be bytes, and the return value will be bytes.  If in text mode,
        any "input" should be a string, and the return value will be a string
        decoded according to locale encoding, or by "encoding" if set. Text mode
        is triggered by setting any of text, encoding, errors or universal_newlines.
        """
        if 'stdout' in kwargs:
            raise ValueError('stdout argument not allowed, it will be overridden.')
    
        if 'input' in kwargs and kwargs['input'] is None:
            # Explicitly passing input=None was previously equivalent to passing an
            # empty string. That is maintained here for backwards compatibility.
            if kwargs.get('universal_newlines') or kwargs.get('text'):
                empty = ''
            else:
                empty = b''
            kwargs['input'] = empty
    
>       return run(*popenargs, stdout=PIPE, timeout=timeout, check=True,
                   **kwargs).stdout

/usr/lib/python3.8/subprocess.py:415: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = False, timeout = 60, check = True
popenargs = (['riscv64-unknown-elf-gcc', './TP04/tests/provided/step1/test_var_plus-all_in_mem.s', 'TP04/libprint.s', '-o', './TP04/tests/provided/step1/test_var_plus.riscv'],)
kwargs = {'stderr': -2, 'stdout': -1}
process = <subprocess.Popen object at 0x7fab869ce3a0>
stdout = b"./TP04/tests/provided/step1/test_var_plus-all_in_mem.s: Assembler messages:\n./TP04/tests/provided/step1/test_var_pl...rror: illegal operands `mv'\n./TP04/tests/provided/step1/test_var_plus-all_in_mem.s:85: Error: illegal operands `li'\n"
stderr = None, retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout is given, and the process takes too long, a TimeoutExpired
        exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['riscv64-unknown-elf-gcc', './TP04/tests/provided/step1/test_var_plus-all_in_mem.s', 'TP04/libprint.s', '-o', './TP04/tests/provided/step1/test_var_plus.riscv']' returned non-zero exit status 1.

/usr/lib/python3.8/subprocess.py:516: CalledProcessError

During handling of the above exception, another exception occurred:

self = <test_codegen.TestCodeGen object at 0x7fab869cefd0>
filename = './TP04/tests/provided/step1/test_var_plus.c'

    @pytest.mark.parametrize('filename', ALL_IN_MEM_FILES)
    def test_alloc_mem(self, filename):
        expect = self.get_expect(filename)
>       actual = self.all_in_mem(filename, expect)

test_codegen.py:242: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
test_codegen.py:100: in all_in_mem
    return self.compile_and_simulate(file, info, reg_alloc='all_in_mem')
test_codegen.py:216: in compile_and_simulate
    return self.link_and_run(output_name, exec_name, info)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_codegen.TestCodeGen object at 0x7fab869cefd0>
output_name = './TP04/tests/provided/step1/test_var_plus-all_in_mem.s'
exec_name = './TP04/tests/provided/step1/test_var_plus.riscv'
info = testinfo(exitcode=0, execcode=0, output='84\n43\n43\n', linkargs=[], skip_test_expected=False)

    def link_and_run(self, output_name, exec_name, info):
        self.remove(exec_name)
        cmd = [
            ASM, output_name, 'TP04/libprint.s',
            '-o', exec_name
        ] + info.linkargs
        print(info)
        print("Assembling and linking " + output_name + ": " + ' '.join(cmd))
        try:
            subprocess.check_output(cmd, timeout=60, stderr=subprocess.STDOUT)
        except subprocess.CalledProcessError as e:
            print("Assembling failed:\n")
            print(e.output.decode())
            print("Assembler code below:\n")
            cat(output_name)
>           pytest.fail()
E           Failed

test_codegen.py:175: Failed
----------------------------- Captured stdout call -----------------------------
Compiling ...
/usr/bin/python3 ./MiniCC.py --reg-alloc=all_in_mem --output=./TP04/tests/provided/step1/test_var_plus-all_in_mem.s ./TP04/tests/provided/step1/test_var_plus.c
Exited with status: 0

Compiling ... OK
testinfo(exitcode=0, execcode=0, output='84\n43\n43\n', linkargs=[], skip_test_expected=False)
Assembling and linking ./TP04/tests/provided/step1/test_var_plus-all_in_mem.s: riscv64-unknown-elf-gcc ./TP04/tests/provided/step1/test_var_plus-all_in_mem.s TP04/libprint.s -o ./TP04/tests/provided/step1/test_var_plus.riscv
Assembling failed:

./TP04/tests/provided/step1/test_var_plus-all_in_mem.s: Assembler messages:
./TP04/tests/provided/step1/test_var_plus-all_in_mem.s:20: Error: illegal operands `la'
./TP04/tests/provided/step1/test_var_plus-all_in_mem.s:26: Error: illegal operands `li'
./TP04/tests/provided/step1/test_var_plus-all_in_mem.s:38: Error: illegal operands `li'
./TP04/tests/provided/step1/test_var_plus-all_in_mem.s:42: Error: illegal operands `li'
./TP04/tests/provided/step1/test_var_plus-all_in_mem.s:45: Error: illegal operands `mv'
./TP04/tests/provided/step1/test_var_plus-all_in_mem.s:49: Error: illegal operands `add'
./TP04/tests/provided/step1/test_var_plus-all_in_mem.s:52: Error: illegal operands `mv'
./TP04/tests/provided/step1/test_var_plus-all_in_mem.s:59: Error: illegal operands `li'
./TP04/tests/provided/step1/test_var_plus-all_in_mem.s:62: Error: illegal operands `add'
./TP04/tests/provided/step1/test_var_plus-all_in_mem.s:65: Error: illegal operands `mv'
./TP04/tests/provided/step1/test_var_plus-all_in_mem.s:72: Error: illegal operands `li'
./TP04/tests/provided/step1/test_var_plus-all_in_mem.s:75: Error: illegal operands `add'
./TP04/tests/provided/step1/test_var_plus-all_in_mem.s:78: Error: illegal operands `mv'
./TP04/tests/provided/step1/test_var_plus-all_in_mem.s:85: Error: illegal operands `li'

Assembler code below:

##Automatically generated RISCV code, MIF08 & CAP
## all-in-memory allocation


##prelude

        .text
        .globl main
main:
        addi sp, sp, -80
        sd ra, 0(sp)
        sd fp, 8(sp)
        addi fp, sp, 80
        j lbl_main_1_main
        

##Generated Code
lbl_div_by_zero_0_main:
        # la a0, lbl_div_by_zero_0_main_msg
        la
        # end la a0, lbl_div_by_zero_0_main_msg
        # call println_string
        call
        # end call println_string
        # li a0, 1
        li
        # end li a0, 1
        # call exit
        call
        # end call exit
        j lbl_div_by_zero_0_main_msg
lbl_div_by_zero_0_main_msg:
        # .string "Division by 0"
        .string
        # end .string "Division by 0"
        j lbl_end_1_main
lbl_main_1_main:
        # li temp_0, 0
        li
        # end li temp_0, 0
        # (stat (assignment x = (expr (atom 42))) ;)
        # li temp_1, 42
        li
        # end li temp_1, 42
        # mv temp_0, temp_1
        mv
        # end mv temp_0, temp_1
        # (stat (print_stat println_int ( (expr (expr (atom x)) + (expr (atom x))) ) ;))
        # add temp_2, temp_0, temp_0
        add
        # end add temp_2, temp_0, temp_0
        # mv a0, temp_2
        mv
        # end mv a0, temp_2
        # call println_int
        call
        # end call println_int
        # (stat (print_stat println_int ( (expr (expr (atom x)) + (expr (atom 1))) ) ;))
        # li temp_3, 1
        li
        # end li temp_3, 1
        # add temp_4, temp_0, temp_3
        add
        # end add temp_4, temp_0, temp_3
        # mv a0, temp_4
        mv
        # end mv a0, temp_4
        # call println_int
        call
        # end call println_int
        # (stat (print_stat println_int ( (expr (expr (atom 1)) + (expr (atom x))) ) ;))
        # li temp_5, 1
        li
        # end li temp_5, 1
        # add temp_6, temp_5, temp_0
        add
        # end add temp_6, temp_5, temp_0
        # mv a0, temp_6
        mv
        # end mv a0, temp_6
        # call println_int
        call
        # end call println_int
        # Return at end of function:
        # li a0, 0
        li
        # end li a0, 0
        j lbl_end_1_main


##postlude

lbl_end_1_main:
        ld ra, 0(sp)
        ld fp, 8(sp)
        addi sp, sp, 80
        ret
        
_____ TestCodeGen.test_alloc_mem[./TP04/tests/provided/step1/test_vars.c] ______

self = <test_codegen.TestCodeGen object at 0x7fab869c8a00>
output_name = './TP04/tests/provided/step1/test_vars-all_in_mem.s'
exec_name = './TP04/tests/provided/step1/test_vars.riscv'
info = testinfo(exitcode=0, execcode=0, output='108\n67\n3\n', linkargs=[], skip_test_expected=False)

    def link_and_run(self, output_name, exec_name, info):
        self.remove(exec_name)
        cmd = [
            ASM, output_name, 'TP04/libprint.s',
            '-o', exec_name
        ] + info.linkargs
        print(info)
        print("Assembling and linking " + output_name + ": " + ' '.join(cmd))
        try:
>           subprocess.check_output(cmd, timeout=60, stderr=subprocess.STDOUT)

test_codegen.py:169: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

timeout = 60
popenargs = (['riscv64-unknown-elf-gcc', './TP04/tests/provided/step1/test_vars-all_in_mem.s', 'TP04/libprint.s', '-o', './TP04/tests/provided/step1/test_vars.riscv'],)
kwargs = {'stderr': -2}

    def check_output(*popenargs, timeout=None, **kwargs):
        r"""Run command with arguments and return its output.
    
        If the exit code was non-zero it raises a CalledProcessError.  The
        CalledProcessError object will have the return code in the returncode
        attribute and output in the output attribute.
    
        The arguments are the same as for the Popen constructor.  Example:
    
        >>> check_output(["ls", "-l", "/dev/null"])
        b'crw-rw-rw- 1 root root 1, 3 Oct 18  2007 /dev/null\n'
    
        The stdout argument is not allowed as it is used internally.
        To capture standard error in the result, use stderr=STDOUT.
    
        >>> check_output(["/bin/sh", "-c",
        ...               "ls -l non_existent_file ; exit 0"],
        ...              stderr=STDOUT)
        b'ls: non_existent_file: No such file or directory\n'
    
        There is an additional optional argument, "input", allowing you to
        pass a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it too will be used internally.  Example:
    
        >>> check_output(["sed", "-e", "s/foo/bar/"],
        ...              input=b"when in the course of fooman events\n")
        b'when in the course of barman events\n'
    
        By default, all communication is in bytes, and therefore any "input"
        should be bytes, and the return value will be bytes.  If in text mode,
        any "input" should be a string, and the return value will be a string
        decoded according to locale encoding, or by "encoding" if set. Text mode
        is triggered by setting any of text, encoding, errors or universal_newlines.
        """
        if 'stdout' in kwargs:
            raise ValueError('stdout argument not allowed, it will be overridden.')
    
        if 'input' in kwargs and kwargs['input'] is None:
            # Explicitly passing input=None was previously equivalent to passing an
            # empty string. That is maintained here for backwards compatibility.
            if kwargs.get('universal_newlines') or kwargs.get('text'):
                empty = ''
            else:
                empty = b''
            kwargs['input'] = empty
    
>       return run(*popenargs, stdout=PIPE, timeout=timeout, check=True,
                   **kwargs).stdout

/usr/lib/python3.8/subprocess.py:415: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = False, timeout = 60, check = True
popenargs = (['riscv64-unknown-elf-gcc', './TP04/tests/provided/step1/test_vars-all_in_mem.s', 'TP04/libprint.s', '-o', './TP04/tests/provided/step1/test_vars.riscv'],)
kwargs = {'stderr': -2, 'stdout': -1}
process = <subprocess.Popen object at 0x7fab869c8b50>
stdout = b"./TP04/tests/provided/step1/test_vars-all_in_mem.s: Assembler messages:\n./TP04/tests/provided/step1/test_vars-all_i...: Error: illegal operands `mv'\n./TP04/tests/provided/step1/test_vars-all_in_mem.s:103: Error: illegal operands `li'\n"
stderr = None, retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout is given, and the process takes too long, a TimeoutExpired
        exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['riscv64-unknown-elf-gcc', './TP04/tests/provided/step1/test_vars-all_in_mem.s', 'TP04/libprint.s', '-o', './TP04/tests/provided/step1/test_vars.riscv']' returned non-zero exit status 1.

/usr/lib/python3.8/subprocess.py:516: CalledProcessError

During handling of the above exception, another exception occurred:

self = <test_codegen.TestCodeGen object at 0x7fab869c8a00>
filename = './TP04/tests/provided/step1/test_vars.c'

    @pytest.mark.parametrize('filename', ALL_IN_MEM_FILES)
    def test_alloc_mem(self, filename):
        expect = self.get_expect(filename)
>       actual = self.all_in_mem(filename, expect)

test_codegen.py:242: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
test_codegen.py:100: in all_in_mem
    return self.compile_and_simulate(file, info, reg_alloc='all_in_mem')
test_codegen.py:216: in compile_and_simulate
    return self.link_and_run(output_name, exec_name, info)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_codegen.TestCodeGen object at 0x7fab869c8a00>
output_name = './TP04/tests/provided/step1/test_vars-all_in_mem.s'
exec_name = './TP04/tests/provided/step1/test_vars.riscv'
info = testinfo(exitcode=0, execcode=0, output='108\n67\n3\n', linkargs=[], skip_test_expected=False)

    def link_and_run(self, output_name, exec_name, info):
        self.remove(exec_name)
        cmd = [
            ASM, output_name, 'TP04/libprint.s',
            '-o', exec_name
        ] + info.linkargs
        print(info)
        print("Assembling and linking " + output_name + ": " + ' '.join(cmd))
        try:
            subprocess.check_output(cmd, timeout=60, stderr=subprocess.STDOUT)
        except subprocess.CalledProcessError as e:
            print("Assembling failed:\n")
            print(e.output.decode())
            print("Assembler code below:\n")
            cat(output_name)
>           pytest.fail()
E           Failed

test_codegen.py:175: Failed
----------------------------- Captured stdout call -----------------------------
Compiling ...
/usr/bin/python3 ./MiniCC.py --reg-alloc=all_in_mem --output=./TP04/tests/provided/step1/test_vars-all_in_mem.s ./TP04/tests/provided/step1/test_vars.c
Exited with status: 0

Compiling ... OK
testinfo(exitcode=0, execcode=0, output='108\n67\n3\n', linkargs=[], skip_test_expected=False)
Assembling and linking ./TP04/tests/provided/step1/test_vars-all_in_mem.s: riscv64-unknown-elf-gcc ./TP04/tests/provided/step1/test_vars-all_in_mem.s TP04/libprint.s -o ./TP04/tests/provided/step1/test_vars.riscv
Assembling failed:

./TP04/tests/provided/step1/test_vars-all_in_mem.s: Assembler messages:
./TP04/tests/provided/step1/test_vars-all_in_mem.s:20: Error: illegal operands `la'
./TP04/tests/provided/step1/test_vars-all_in_mem.s:26: Error: illegal operands `li'
./TP04/tests/provided/step1/test_vars-all_in_mem.s:38: Error: illegal operands `li'
./TP04/tests/provided/step1/test_vars-all_in_mem.s:41: Error: illegal operands `li'
./TP04/tests/provided/step1/test_vars-all_in_mem.s:45: Error: illegal operands `li'
./TP04/tests/provided/step1/test_vars-all_in_mem.s:48: Error: illegal operands `mv'
./TP04/tests/provided/step1/test_vars-all_in_mem.s:52: Error: illegal operands `li'
./TP04/tests/provided/step1/test_vars-all_in_mem.s:55: Error: illegal operands `mv'
./TP04/tests/provided/step1/test_vars-all_in_mem.s:59: Error: illegal operands `add'
./TP04/tests/provided/step1/test_vars-all_in_mem.s:62: Error: illegal operands `mv'
./TP04/tests/provided/step1/test_vars-all_in_mem.s:69: Error: illegal operands `li'
./TP04/tests/provided/step1/test_vars-all_in_mem.s:72: Error: illegal operands `mv'
./TP04/tests/provided/step1/test_vars-all_in_mem.s:76: Error: illegal operands `add'
./TP04/tests/provided/step1/test_vars-all_in_mem.s:79: Error: illegal operands `mv'
./TP04/tests/provided/step1/test_vars-all_in_mem.s:86: Error: illegal operands `li'
./TP04/tests/provided/step1/test_vars-all_in_mem.s:89: Error: illegal operands `mv'
./TP04/tests/provided/step1/test_vars-all_in_mem.s:93: Error: illegal operands `add'
./TP04/tests/provided/step1/test_vars-all_in_mem.s:96: Error: illegal operands `mv'
./TP04/tests/provided/step1/test_vars-all_in_mem.s:103: Error: illegal operands `li'

Assembler code below:

##Automatically generated RISCV code, MIF08 & CAP
## all-in-memory allocation


##prelude

        .text
        .globl main
main:
        addi sp, sp, -96
        sd ra, 0(sp)
        sd fp, 8(sp)
        addi fp, sp, 96
        j lbl_main_1_main
        

##Generated Code
lbl_div_by_zero_0_main:
        # la a0, lbl_div_by_zero_0_main_msg
        la
        # end la a0, lbl_div_by_zero_0_main_msg
        # call println_string
        call
        # end call println_string
        # li a0, 1
        li
        # end li a0, 1
        # call exit
        call
        # end call exit
        j lbl_div_by_zero_0_main_msg
lbl_div_by_zero_0_main_msg:
        # .string "Division by 0"
        .string
        # end .string "Division by 0"
        j lbl_end_1_main
lbl_main_1_main:
        # li temp_0, 0
        li
        # end li temp_0, 0
        # li temp_1, 0
        li
        # end li temp_1, 0
        # (stat (assignment x = (expr (atom 42))) ;)
        # li temp_2, 42
        li
        # end li temp_2, 42
        # mv temp_1, temp_2
        mv
        # end mv temp_1, temp_2
        # (stat (assignment y = (expr (atom 66))) ;)
        # li temp_3, 66
        li
        # end li temp_3, 66
        # mv temp_0, temp_3
        mv
        # end mv temp_0, temp_3
        # (stat (print_stat println_int ( (expr (expr (atom x)) + (expr (atom y))) ) ;))
        # add temp_4, temp_1, temp_0
        add
        # end add temp_4, temp_1, temp_0
        # mv a0, temp_4
        mv
        # end mv a0, temp_4
        # call println_int
        call
        # end call println_int
        # (stat (assignment x = (expr (atom 1))) ;)
        # li temp_5, 1
        li
        # end li temp_5, 1
        # mv temp_1, temp_5
        mv
        # end mv temp_1, temp_5
        # (stat (print_stat println_int ( (expr (expr (atom x)) + (expr (atom y))) ) ;))
        # add temp_6, temp_1, temp_0
        add
        # end add temp_6, temp_1, temp_0
        # mv a0, temp_6
        mv
        # end mv a0, temp_6
        # call println_int
        call
        # end call println_int
        # (stat (assignment y = (expr (atom 2))) ;)
        # li temp_7, 2
        li
        # end li temp_7, 2
        # mv temp_0, temp_7
        mv
        # end mv temp_0, temp_7
        # (stat (print_stat println_int ( (expr (expr (atom x)) + (expr (atom y))) ) ;))
        # add temp_8, temp_1, temp_0
        add
        # end add temp_8, temp_1, temp_0
        # mv a0, temp_8
        mv
        # end mv a0, temp_8
        # call println_int
        call
        # end call println_int
        # Return at end of function:
        # li a0, 0
        li
        # end li a0, 0
        j lbl_end_1_main


##postlude

lbl_end_1_main:
        ld ra, 0(sp)
        ld fp, 8(sp)
        addi sp, sp, 96
        ret
        
_______ TestCodeGen.test_alloc_mem[./TP04/tests/provided/step2/test02.c] _______

self = <test_codegen.TestCodeGen object at 0x7fab86a7e790>
output_name = './TP04/tests/provided/step2/test02-all_in_mem.s'
exec_name = './TP04/tests/provided/step2/test02.riscv'
info = testinfo(exitcode=0, execcode=0, output='', linkargs=[], skip_test_expected=False)

    def link_and_run(self, output_name, exec_name, info):
        self.remove(exec_name)
        cmd = [
            ASM, output_name, 'TP04/libprint.s',
            '-o', exec_name
        ] + info.linkargs
        print(info)
        print("Assembling and linking " + output_name + ": " + ' '.join(cmd))
        try:
>           subprocess.check_output(cmd, timeout=60, stderr=subprocess.STDOUT)

test_codegen.py:169: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

timeout = 60
popenargs = (['riscv64-unknown-elf-gcc', './TP04/tests/provided/step2/test02-all_in_mem.s', 'TP04/libprint.s', '-o', './TP04/tests/provided/step2/test02.riscv'],)
kwargs = {'stderr': -2}

    def check_output(*popenargs, timeout=None, **kwargs):
        r"""Run command with arguments and return its output.
    
        If the exit code was non-zero it raises a CalledProcessError.  The
        CalledProcessError object will have the return code in the returncode
        attribute and output in the output attribute.
    
        The arguments are the same as for the Popen constructor.  Example:
    
        >>> check_output(["ls", "-l", "/dev/null"])
        b'crw-rw-rw- 1 root root 1, 3 Oct 18  2007 /dev/null\n'
    
        The stdout argument is not allowed as it is used internally.
        To capture standard error in the result, use stderr=STDOUT.
    
        >>> check_output(["/bin/sh", "-c",
        ...               "ls -l non_existent_file ; exit 0"],
        ...              stderr=STDOUT)
        b'ls: non_existent_file: No such file or directory\n'
    
        There is an additional optional argument, "input", allowing you to
        pass a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it too will be used internally.  Example:
    
        >>> check_output(["sed", "-e", "s/foo/bar/"],
        ...              input=b"when in the course of fooman events\n")
        b'when in the course of barman events\n'
    
        By default, all communication is in bytes, and therefore any "input"
        should be bytes, and the return value will be bytes.  If in text mode,
        any "input" should be a string, and the return value will be a string
        decoded according to locale encoding, or by "encoding" if set. Text mode
        is triggered by setting any of text, encoding, errors or universal_newlines.
        """
        if 'stdout' in kwargs:
            raise ValueError('stdout argument not allowed, it will be overridden.')
    
        if 'input' in kwargs and kwargs['input'] is None:
            # Explicitly passing input=None was previously equivalent to passing an
            # empty string. That is maintained here for backwards compatibility.
            if kwargs.get('universal_newlines') or kwargs.get('text'):
                empty = ''
            else:
                empty = b''
            kwargs['input'] = empty
    
>       return run(*popenargs, stdout=PIPE, timeout=timeout, check=True,
                   **kwargs).stdout

/usr/lib/python3.8/subprocess.py:415: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = False, timeout = 60, check = True
popenargs = (['riscv64-unknown-elf-gcc', './TP04/tests/provided/step2/test02-all_in_mem.s', 'TP04/libprint.s', '-o', './TP04/tests/provided/step2/test02.riscv'],)
kwargs = {'stderr': -2, 'stdout': -1}
process = <subprocess.Popen object at 0x7fab86adc790>
stdout = b"./TP04/tests/provided/step2/test02-all_in_mem.s: Assembler messages:\n./TP04/tests/provided/step2/test02-all_in_mem....s:89: Error: illegal operands `mv'\n./TP04/tests/provided/step2/test02-all_in_mem.s:93: Error: illegal operands `li'\n"
stderr = None, retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout is given, and the process takes too long, a TimeoutExpired
        exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['riscv64-unknown-elf-gcc', './TP04/tests/provided/step2/test02-all_in_mem.s', 'TP04/libprint.s', '-o', './TP04/tests/provided/step2/test02.riscv']' returned non-zero exit status 1.

/usr/lib/python3.8/subprocess.py:516: CalledProcessError

During handling of the above exception, another exception occurred:

self = <test_codegen.TestCodeGen object at 0x7fab86a7e790>
filename = './TP04/tests/provided/step2/test02.c'

    @pytest.mark.parametrize('filename', ALL_IN_MEM_FILES)
    def test_alloc_mem(self, filename):
        expect = self.get_expect(filename)
>       actual = self.all_in_mem(filename, expect)

test_codegen.py:242: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
test_codegen.py:100: in all_in_mem
    return self.compile_and_simulate(file, info, reg_alloc='all_in_mem')
test_codegen.py:216: in compile_and_simulate
    return self.link_and_run(output_name, exec_name, info)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_codegen.TestCodeGen object at 0x7fab86a7e790>
output_name = './TP04/tests/provided/step2/test02-all_in_mem.s'
exec_name = './TP04/tests/provided/step2/test02.riscv'
info = testinfo(exitcode=0, execcode=0, output='', linkargs=[], skip_test_expected=False)

    def link_and_run(self, output_name, exec_name, info):
        self.remove(exec_name)
        cmd = [
            ASM, output_name, 'TP04/libprint.s',
            '-o', exec_name
        ] + info.linkargs
        print(info)
        print("Assembling and linking " + output_name + ": " + ' '.join(cmd))
        try:
            subprocess.check_output(cmd, timeout=60, stderr=subprocess.STDOUT)
        except subprocess.CalledProcessError as e:
            print("Assembling failed:\n")
            print(e.output.decode())
            print("Assembler code below:\n")
            cat(output_name)
>           pytest.fail()
E           Failed

test_codegen.py:175: Failed
----------------------------- Captured stdout call -----------------------------
Compiling ...
/usr/bin/python3 ./MiniCC.py --reg-alloc=all_in_mem --output=./TP04/tests/provided/step2/test02-all_in_mem.s ./TP04/tests/provided/step2/test02.c
Exited with status: 0

Compiling ... OK
testinfo(exitcode=0, execcode=0, output='', linkargs=[], skip_test_expected=False)
Assembling and linking ./TP04/tests/provided/step2/test02-all_in_mem.s: riscv64-unknown-elf-gcc ./TP04/tests/provided/step2/test02-all_in_mem.s TP04/libprint.s -o ./TP04/tests/provided/step2/test02.riscv
Assembling failed:

./TP04/tests/provided/step2/test02-all_in_mem.s: Assembler messages:
./TP04/tests/provided/step2/test02-all_in_mem.s:20: Error: illegal operands `la'
./TP04/tests/provided/step2/test02-all_in_mem.s:26: Error: illegal operands `li'
./TP04/tests/provided/step2/test02-all_in_mem.s:38: Error: illegal operands `li'
./TP04/tests/provided/step2/test02-all_in_mem.s:41: Error: illegal operands `li'
./TP04/tests/provided/step2/test02-all_in_mem.s:45: Error: illegal operands `li'
./TP04/tests/provided/step2/test02-all_in_mem.s:48: Error: illegal operands `mv'
./TP04/tests/provided/step2/test02-all_in_mem.s:52: Error: illegal operands `li'
./TP04/tests/provided/step2/test02-all_in_mem.s:55: Error: illegal operands `li'
./TP04/tests/provided/step2/test02-all_in_mem.s:58: Error: illegal operands `bge'
./TP04/tests/provided/step2/test02-all_in_mem.s:61: Error: illegal operands `li'
./TP04/tests/provided/step2/test02-all_in_mem.s:65: Error: illegal operands `li'
./TP04/tests/provided/step2/test02-all_in_mem.s:68: Error: illegal operands `beq'
./TP04/tests/provided/step2/test02-all_in_mem.s:71: Error: illegal operands `li'
./TP04/tests/provided/step2/test02-all_in_mem.s:74: Error: illegal operands `mv'
./TP04/tests/provided/step2/test02-all_in_mem.s:81: Error: illegal operands `li'
./TP04/tests/provided/step2/test02-all_in_mem.s:84: Error: illegal operands `mv'
./TP04/tests/provided/step2/test02-all_in_mem.s:89: Error: illegal operands `mv'
./TP04/tests/provided/step2/test02-all_in_mem.s:93: Error: illegal operands `li'

Assembler code below:

##Automatically generated RISCV code, MIF08 & CAP
## all-in-memory allocation


##prelude

        .text
        .globl main
main:
        addi sp, sp, -80
        sd ra, 0(sp)
        sd fp, 8(sp)
        addi fp, sp, 80
        j lbl_main_4_main
        

##Generated Code
lbl_div_by_zero_0_main:
        # la a0, lbl_div_by_zero_0_main_msg
        la
        # end la a0, lbl_div_by_zero_0_main_msg
        # call println_string
        call
        # end call println_string
        # li a0, 1
        li
        # end li a0, 1
        # call exit
        call
        # end call exit
        j lbl_div_by_zero_0_main_msg
lbl_div_by_zero_0_main_msg:
        # .string "Division by 0"
        .string
        # end .string "Division by 0"
        j lbl_end_4_main
lbl_main_4_main:
        # li temp_0, 0
        li
        # end li temp_0, 0
        # li temp_1, 0
        li
        # end li temp_1, 0
        # (stat (assignment x = (expr (atom 9))) ;)
        # li temp_2, 9
        li
        # end li temp_2, 9
        # mv temp_1, temp_2
        mv
        # end mv temp_1, temp_2
        # (stat (if_stat if ( (expr (expr (atom x)) < (expr (atom 2))) ) (stat_block (stat (assignment y = (expr (atom 7))) ;)) else (stat_block (stat (assignment y = (expr (atom 12))) ;))))
        # li temp_4, 2
        li
        # end li temp_4, 2
        # li temp_3, 0
        li
        # end li temp_3, 0
        # bge temp_1, temp_4, lbl_endrel_3_main
        bge
        # end bge temp_1, temp_4, lbl_endrel_3_main
        # li temp_3, 1
        li
        # end li temp_3, 1
lbl_endrel_3_main:
        # li temp_5, 0
        li
        # end li temp_5, 0
        # beq temp_3, temp_5, lbl_else_1_main
        beq
        # end beq temp_3, temp_5, lbl_else_1_main
        # li temp_6, 7
        li
        # end li temp_6, 7
        # mv temp_0, temp_6
        mv
        # end mv temp_0, temp_6
        # j lbl_end_if_2_main
        j
        # end j lbl_end_if_2_main
lbl_else_1_main:
        # li temp_7, 12
        li
        # end li temp_7, 12
        # mv temp_0, temp_7
        mv
        # end mv temp_0, temp_7
lbl_end_if_2_main:
        # (stat (assignment x = (expr (atom y))) ;)
        # mv temp_1, temp_0
        mv
        # end mv temp_1, temp_0
        # Return at end of function:
        # li a0, 0
        li
        # end li a0, 0
        j lbl_end_4_main


##postlude

lbl_end_4_main:
        ld ra, 0(sp)
        ld fp, 8(sp)
        addi sp, sp, 80
        ret
        
_______ TestCodeGen.test_alloc_mem[./TP04/tests/provided/step2/test04.c] _______

self = <test_codegen.TestCodeGen object at 0x7fab869b1b20>
output_name = './TP04/tests/provided/step2/test04-all_in_mem.s'
exec_name = './TP04/tests/provided/step2/test04.riscv'
info = testinfo(exitcode=0, execcode=0, output='', linkargs=[], skip_test_expected=False)

    def link_and_run(self, output_name, exec_name, info):
        self.remove(exec_name)
        cmd = [
            ASM, output_name, 'TP04/libprint.s',
            '-o', exec_name
        ] + info.linkargs
        print(info)
        print("Assembling and linking " + output_name + ": " + ' '.join(cmd))
        try:
>           subprocess.check_output(cmd, timeout=60, stderr=subprocess.STDOUT)

test_codegen.py:169: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

timeout = 60
popenargs = (['riscv64-unknown-elf-gcc', './TP04/tests/provided/step2/test04-all_in_mem.s', 'TP04/libprint.s', '-o', './TP04/tests/provided/step2/test04.riscv'],)
kwargs = {'stderr': -2}

    def check_output(*popenargs, timeout=None, **kwargs):
        r"""Run command with arguments and return its output.
    
        If the exit code was non-zero it raises a CalledProcessError.  The
        CalledProcessError object will have the return code in the returncode
        attribute and output in the output attribute.
    
        The arguments are the same as for the Popen constructor.  Example:
    
        >>> check_output(["ls", "-l", "/dev/null"])
        b'crw-rw-rw- 1 root root 1, 3 Oct 18  2007 /dev/null\n'
    
        The stdout argument is not allowed as it is used internally.
        To capture standard error in the result, use stderr=STDOUT.
    
        >>> check_output(["/bin/sh", "-c",
        ...               "ls -l non_existent_file ; exit 0"],
        ...              stderr=STDOUT)
        b'ls: non_existent_file: No such file or directory\n'
    
        There is an additional optional argument, "input", allowing you to
        pass a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it too will be used internally.  Example:
    
        >>> check_output(["sed", "-e", "s/foo/bar/"],
        ...              input=b"when in the course of fooman events\n")
        b'when in the course of barman events\n'
    
        By default, all communication is in bytes, and therefore any "input"
        should be bytes, and the return value will be bytes.  If in text mode,
        any "input" should be a string, and the return value will be a string
        decoded according to locale encoding, or by "encoding" if set. Text mode
        is triggered by setting any of text, encoding, errors or universal_newlines.
        """
        if 'stdout' in kwargs:
            raise ValueError('stdout argument not allowed, it will be overridden.')
    
        if 'input' in kwargs and kwargs['input'] is None:
            # Explicitly passing input=None was previously equivalent to passing an
            # empty string. That is maintained here for backwards compatibility.
            if kwargs.get('universal_newlines') or kwargs.get('text'):
                empty = ''
            else:
                empty = b''
            kwargs['input'] = empty
    
>       return run(*popenargs, stdout=PIPE, timeout=timeout, check=True,
                   **kwargs).stdout

/usr/lib/python3.8/subprocess.py:415: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = False, timeout = 60, check = True
popenargs = (['riscv64-unknown-elf-gcc', './TP04/tests/provided/step2/test04-all_in_mem.s', 'TP04/libprint.s', '-o', './TP04/tests/provided/step2/test04.riscv'],)
kwargs = {'stderr': -2, 'stdout': -1}
process = <subprocess.Popen object at 0x7fab869b1310>
stdout = b"./TP04/tests/provided/step2/test04-all_in_mem.s: Assembler messages:\n./TP04/tests/provided/step2/test04-all_in_mem....s:85: Error: illegal operands `mv'\n./TP04/tests/provided/step2/test04-all_in_mem.s:89: Error: illegal operands `li'\n"
stderr = None, retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout is given, and the process takes too long, a TimeoutExpired
        exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['riscv64-unknown-elf-gcc', './TP04/tests/provided/step2/test04-all_in_mem.s', 'TP04/libprint.s', '-o', './TP04/tests/provided/step2/test04.riscv']' returned non-zero exit status 1.

/usr/lib/python3.8/subprocess.py:516: CalledProcessError

During handling of the above exception, another exception occurred:

self = <test_codegen.TestCodeGen object at 0x7fab869b1b20>
filename = './TP04/tests/provided/step2/test04.c'

    @pytest.mark.parametrize('filename', ALL_IN_MEM_FILES)
    def test_alloc_mem(self, filename):
        expect = self.get_expect(filename)
>       actual = self.all_in_mem(filename, expect)

test_codegen.py:242: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
test_codegen.py:100: in all_in_mem
    return self.compile_and_simulate(file, info, reg_alloc='all_in_mem')
test_codegen.py:216: in compile_and_simulate
    return self.link_and_run(output_name, exec_name, info)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_codegen.TestCodeGen object at 0x7fab869b1b20>
output_name = './TP04/tests/provided/step2/test04-all_in_mem.s'
exec_name = './TP04/tests/provided/step2/test04.riscv'
info = testinfo(exitcode=0, execcode=0, output='', linkargs=[], skip_test_expected=False)

    def link_and_run(self, output_name, exec_name, info):
        self.remove(exec_name)
        cmd = [
            ASM, output_name, 'TP04/libprint.s',
            '-o', exec_name
        ] + info.linkargs
        print(info)
        print("Assembling and linking " + output_name + ": " + ' '.join(cmd))
        try:
            subprocess.check_output(cmd, timeout=60, stderr=subprocess.STDOUT)
        except subprocess.CalledProcessError as e:
            print("Assembling failed:\n")
            print(e.output.decode())
            print("Assembler code below:\n")
            cat(output_name)
>           pytest.fail()
E           Failed

test_codegen.py:175: Failed
----------------------------- Captured stdout call -----------------------------
Compiling ...
/usr/bin/python3 ./MiniCC.py --reg-alloc=all_in_mem --output=./TP04/tests/provided/step2/test04-all_in_mem.s ./TP04/tests/provided/step2/test04.c
Exited with status: 0
true

Compiling ... OK
testinfo(exitcode=0, execcode=0, output='', linkargs=[], skip_test_expected=False)
Assembling and linking ./TP04/tests/provided/step2/test04-all_in_mem.s: riscv64-unknown-elf-gcc ./TP04/tests/provided/step2/test04-all_in_mem.s TP04/libprint.s -o ./TP04/tests/provided/step2/test04.riscv
Assembling failed:

./TP04/tests/provided/step2/test04-all_in_mem.s: Assembler messages:
./TP04/tests/provided/step2/test04-all_in_mem.s:20: Error: illegal operands `la'
./TP04/tests/provided/step2/test04-all_in_mem.s:26: Error: illegal operands `li'
./TP04/tests/provided/step2/test04-all_in_mem.s:38: Error: illegal operands `li'
./TP04/tests/provided/step2/test04-all_in_mem.s:41: Error: illegal operands `li'
./TP04/tests/provided/step2/test04-all_in_mem.s:44: Error: illegal operands `li'
./TP04/tests/provided/step2/test04-all_in_mem.s:48: Error: illegal operands `li'
./TP04/tests/provided/step2/test04-all_in_mem.s:51: Error: illegal operands `mv'
./TP04/tests/provided/step2/test04-all_in_mem.s:55: Error: illegal operands `li'
./TP04/tests/provided/step2/test04-all_in_mem.s:58: Error: illegal operands `mv'
./TP04/tests/provided/step2/test04-all_in_mem.s:62: Error: illegal operands `li'
./TP04/tests/provided/step2/test04-all_in_mem.s:65: Error: illegal operands `li'
./TP04/tests/provided/step2/test04-all_in_mem.s:68: Error: illegal operands `bge'
./TP04/tests/provided/step2/test04-all_in_mem.s:71: Error: illegal operands `li'
./TP04/tests/provided/step2/test04-all_in_mem.s:75: Error: illegal operands `li'
./TP04/tests/provided/step2/test04-all_in_mem.s:78: Error: illegal operands `bne'
./TP04/tests/provided/step2/test04-all_in_mem.s:81: Error: illegal operands `li'
./TP04/tests/provided/step2/test04-all_in_mem.s:85: Error: illegal operands `mv'
./TP04/tests/provided/step2/test04-all_in_mem.s:89: Error: illegal operands `li'

Assembler code below:

##Automatically generated RISCV code, MIF08 & CAP
## all-in-memory allocation


##prelude

        .text
        .globl main
main:
        addi sp, sp, -80
        sd ra, 0(sp)
        sd fp, 8(sp)
        addi fp, sp, 80
        j lbl_main_3_main
        

##Generated Code
lbl_div_by_zero_0_main:
        # la a0, lbl_div_by_zero_0_main_msg
        la
        # end la a0, lbl_div_by_zero_0_main_msg
        # call println_string
        call
        # end call println_string
        # li a0, 1
        li
        # end li a0, 1
        # call exit
        call
        # end call exit
        j lbl_div_by_zero_0_main_msg
lbl_div_by_zero_0_main_msg:
        # .string "Division by 0"
        .string
        # end .string "Division by 0"
        j lbl_end_3_main
lbl_main_3_main:
        # li temp_0, 0
        li
        # end li temp_0, 0
        # li temp_1, 0
        li
        # end li temp_1, 0
        # li temp_2, 0
        li
        # end li temp_2, 0
        # (stat (assignment n = (expr (atom 1))) ;)
        # li temp_3, 1
        li
        # end li temp_3, 1
        # mv temp_0, temp_3
        mv
        # end mv temp_0, temp_3
        # (stat (assignment a = (expr (atom true))) ;)
        # li temp_4, 1
        li
        # end li temp_4, 1
        # mv temp_2, temp_4
        mv
        # end mv temp_2, temp_4
        # (stat (assignment b = (expr (atom ( (expr (expr (atom a)) == (expr (atom ( (expr (expr (atom n)) < (expr (atom 6))) )))) )))) ;)
        # li temp_7, 6
        li
        # end li temp_7, 6
        # li temp_6, 0
        li
        # end li temp_6, 0
        # bge temp_0, temp_7, lbl_endrel_1_main
        bge
        # end bge temp_0, temp_7, lbl_endrel_1_main
        # li temp_6, 1
        li
        # end li temp_6, 1
lbl_endrel_1_main:
        # li temp_5, 0
        li
        # end li temp_5, 0
        # bne temp_2, temp_6, lbl_endrel_2_main
        bne
        # end bne temp_2, temp_6, lbl_endrel_2_main
        # li temp_5, 1
        li
        # end li temp_5, 1
lbl_endrel_2_main:
        # mv temp_1, temp_5
        mv
        # end mv temp_1, temp_5
        # Return at end of function:
        # li a0, 0
        li
        # end li a0, 0
        j lbl_end_3_main


##postlude

lbl_end_3_main:
        ld ra, 0(sp)
        ld fp, 8(sp)
        addi sp, sp, 80
        ret
        
_______ TestCodeGen.test_alloc_mem[./TP04/tests/provided/step2/test05.c] _______

self = <test_codegen.TestCodeGen object at 0x7fab869b3340>
output_name = './TP04/tests/provided/step2/test05-all_in_mem.s'
exec_name = './TP04/tests/provided/step2/test05.riscv'
info = testinfo(exitcode=0, execcode=0, output='', linkargs=[], skip_test_expected=False)

    def link_and_run(self, output_name, exec_name, info):
        self.remove(exec_name)
        cmd = [
            ASM, output_name, 'TP04/libprint.s',
            '-o', exec_name
        ] + info.linkargs
        print(info)
        print("Assembling and linking " + output_name + ": " + ' '.join(cmd))
        try:
>           subprocess.check_output(cmd, timeout=60, stderr=subprocess.STDOUT)

test_codegen.py:169: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

timeout = 60
popenargs = (['riscv64-unknown-elf-gcc', './TP04/tests/provided/step2/test05-all_in_mem.s', 'TP04/libprint.s', '-o', './TP04/tests/provided/step2/test05.riscv'],)
kwargs = {'stderr': -2}

    def check_output(*popenargs, timeout=None, **kwargs):
        r"""Run command with arguments and return its output.
    
        If the exit code was non-zero it raises a CalledProcessError.  The
        CalledProcessError object will have the return code in the returncode
        attribute and output in the output attribute.
    
        The arguments are the same as for the Popen constructor.  Example:
    
        >>> check_output(["ls", "-l", "/dev/null"])
        b'crw-rw-rw- 1 root root 1, 3 Oct 18  2007 /dev/null\n'
    
        The stdout argument is not allowed as it is used internally.
        To capture standard error in the result, use stderr=STDOUT.
    
        >>> check_output(["/bin/sh", "-c",
        ...               "ls -l non_existent_file ; exit 0"],
        ...              stderr=STDOUT)
        b'ls: non_existent_file: No such file or directory\n'
    
        There is an additional optional argument, "input", allowing you to
        pass a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it too will be used internally.  Example:
    
        >>> check_output(["sed", "-e", "s/foo/bar/"],
        ...              input=b"when in the course of fooman events\n")
        b'when in the course of barman events\n'
    
        By default, all communication is in bytes, and therefore any "input"
        should be bytes, and the return value will be bytes.  If in text mode,
        any "input" should be a string, and the return value will be a string
        decoded according to locale encoding, or by "encoding" if set. Text mode
        is triggered by setting any of text, encoding, errors or universal_newlines.
        """
        if 'stdout' in kwargs:
            raise ValueError('stdout argument not allowed, it will be overridden.')
    
        if 'input' in kwargs and kwargs['input'] is None:
            # Explicitly passing input=None was previously equivalent to passing an
            # empty string. That is maintained here for backwards compatibility.
            if kwargs.get('universal_newlines') or kwargs.get('text'):
                empty = ''
            else:
                empty = b''
            kwargs['input'] = empty
    
>       return run(*popenargs, stdout=PIPE, timeout=timeout, check=True,
                   **kwargs).stdout

/usr/lib/python3.8/subprocess.py:415: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = False, timeout = 60, check = True
popenargs = (['riscv64-unknown-elf-gcc', './TP04/tests/provided/step2/test05-all_in_mem.s', 'TP04/libprint.s', '-o', './TP04/tests/provided/step2/test05.riscv'],)
kwargs = {'stderr': -2, 'stdout': -1}
process = <subprocess.Popen object at 0x7fab869b3280>
stdout = b"./TP04/tests/provided/step2/test05-all_in_mem.s: Assembler messages:\n./TP04/tests/provided/step2/test05-all_in_mem....s:78: Error: illegal operands `mv'\n./TP04/tests/provided/step2/test05-all_in_mem.s:86: Error: illegal operands `li'\n"
stderr = None, retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout is given, and the process takes too long, a TimeoutExpired
        exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['riscv64-unknown-elf-gcc', './TP04/tests/provided/step2/test05-all_in_mem.s', 'TP04/libprint.s', '-o', './TP04/tests/provided/step2/test05.riscv']' returned non-zero exit status 1.

/usr/lib/python3.8/subprocess.py:516: CalledProcessError

During handling of the above exception, another exception occurred:

self = <test_codegen.TestCodeGen object at 0x7fab869b3340>
filename = './TP04/tests/provided/step2/test05.c'

    @pytest.mark.parametrize('filename', ALL_IN_MEM_FILES)
    def test_alloc_mem(self, filename):
        expect = self.get_expect(filename)
>       actual = self.all_in_mem(filename, expect)

test_codegen.py:242: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
test_codegen.py:100: in all_in_mem
    return self.compile_and_simulate(file, info, reg_alloc='all_in_mem')
test_codegen.py:216: in compile_and_simulate
    return self.link_and_run(output_name, exec_name, info)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_codegen.TestCodeGen object at 0x7fab869b3340>
output_name = './TP04/tests/provided/step2/test05-all_in_mem.s'
exec_name = './TP04/tests/provided/step2/test05.riscv'
info = testinfo(exitcode=0, execcode=0, output='', linkargs=[], skip_test_expected=False)

    def link_and_run(self, output_name, exec_name, info):
        self.remove(exec_name)
        cmd = [
            ASM, output_name, 'TP04/libprint.s',
            '-o', exec_name
        ] + info.linkargs
        print(info)
        print("Assembling and linking " + output_name + ": " + ' '.join(cmd))
        try:
            subprocess.check_output(cmd, timeout=60, stderr=subprocess.STDOUT)
        except subprocess.CalledProcessError as e:
            print("Assembling failed:\n")
            print(e.output.decode())
            print("Assembler code below:\n")
            cat(output_name)
>           pytest.fail()
E           Failed

test_codegen.py:175: Failed
----------------------------- Captured stdout call -----------------------------
Compiling ...
/usr/bin/python3 ./MiniCC.py --reg-alloc=all_in_mem --output=./TP04/tests/provided/step2/test05-all_in_mem.s ./TP04/tests/provided/step2/test05.c
Exited with status: 0

Compiling ... OK
testinfo(exitcode=0, execcode=0, output='', linkargs=[], skip_test_expected=False)
Assembling and linking ./TP04/tests/provided/step2/test05-all_in_mem.s: riscv64-unknown-elf-gcc ./TP04/tests/provided/step2/test05-all_in_mem.s TP04/libprint.s -o ./TP04/tests/provided/step2/test05.riscv
Assembling failed:

./TP04/tests/provided/step2/test05-all_in_mem.s: Assembler messages:
./TP04/tests/provided/step2/test05-all_in_mem.s:20: Error: illegal operands `la'
./TP04/tests/provided/step2/test05-all_in_mem.s:26: Error: illegal operands `li'
./TP04/tests/provided/step2/test05-all_in_mem.s:38: Error: illegal operands `li'
./TP04/tests/provided/step2/test05-all_in_mem.s:41: Error: illegal operands `li'
./TP04/tests/provided/step2/test05-all_in_mem.s:45: Error: illegal operands `li'
./TP04/tests/provided/step2/test05-all_in_mem.s:48: Error: illegal operands `mv'
./TP04/tests/provided/step2/test05-all_in_mem.s:52: Error: illegal operands `li'
./TP04/tests/provided/step2/test05-all_in_mem.s:55: Error: illegal operands `li'
./TP04/tests/provided/step2/test05-all_in_mem.s:58: Error: illegal operands `bge'
./TP04/tests/provided/step2/test05-all_in_mem.s:61: Error: illegal operands `li'
./TP04/tests/provided/step2/test05-all_in_mem.s:65: Error: illegal operands `li'
./TP04/tests/provided/step2/test05-all_in_mem.s:68: Error: illegal operands `beq'
./TP04/tests/provided/step2/test05-all_in_mem.s:72: Error: illegal operands `li'
./TP04/tests/provided/step2/test05-all_in_mem.s:75: Error: illegal operands `add'
./TP04/tests/provided/step2/test05-all_in_mem.s:78: Error: illegal operands `mv'
./TP04/tests/provided/step2/test05-all_in_mem.s:86: Error: illegal operands `li'

Assembler code below:

##Automatically generated RISCV code, MIF08 & CAP
## all-in-memory allocation


##prelude

        .text
        .globl main
main:
        addi sp, sp, -80
        sd ra, 0(sp)
        sd fp, 8(sp)
        addi fp, sp, 80
        j lbl_main_4_main
        

##Generated Code
lbl_div_by_zero_0_main:
        # la a0, lbl_div_by_zero_0_main_msg
        la
        # end la a0, lbl_div_by_zero_0_main_msg
        # call println_string
        call
        # end call println_string
        # li a0, 1
        li
        # end li a0, 1
        # call exit
        call
        # end call exit
        j lbl_div_by_zero_0_main_msg
lbl_div_by_zero_0_main_msg:
        # .string "Division by 0"
        .string
        # end .string "Division by 0"
        j lbl_end_4_main
lbl_main_4_main:
        # li temp_0, 0
        li
        # end li temp_0, 0
        # li temp_1, 0
        li
        # end li temp_1, 0
        # (stat (assignment x = (expr (atom 3))) ;)
        # li temp_2, 3
        li
        # end li temp_2, 3
        # mv temp_1, temp_2
        mv
        # end mv temp_1, temp_2
        # (stat (if_stat if ( (expr (expr (atom x)) < (expr (atom 5))) ) (stat_block { (block (stat (assignment y = (expr (expr (atom x)) + (expr (atom 1)))) ;)) })))
        # li temp_4, 5
        li
        # end li temp_4, 5
        # li temp_3, 0
        li
        # end li temp_3, 0
        # bge temp_1, temp_4, lbl_endrel_3_main
        bge
        # end bge temp_1, temp_4, lbl_endrel_3_main
        # li temp_3, 1
        li
        # end li temp_3, 1
lbl_endrel_3_main:
        # li temp_5, 0
        li
        # end li temp_5, 0
        # beq temp_3, temp_5, lbl_end_if_2_main
        beq
        # end beq temp_3, temp_5, lbl_end_if_2_main
        # (stat (assignment y = (expr (expr (atom x)) + (expr (atom 1)))) ;)
        # li temp_6, 1
        li
        # end li temp_6, 1
        # add temp_7, temp_1, temp_6
        add
        # end add temp_7, temp_1, temp_6
        # mv temp_0, temp_7
        mv
        # end mv temp_0, temp_7
        # j lbl_end_if_2_main
        j
        # end j lbl_end_if_2_main
lbl_end_if_2_main:
        # Return at end of function:
        # li a0, 0
        li
        # end li a0, 0
        j lbl_end_4_main


##postlude

lbl_end_4_main:
        ld ra, 0(sp)
        ld fp, 8(sp)
        addi sp, sp, 80
        ret
        
_______ TestCodeGen.test_alloc_mem[./TP04/tests/provided/step2/test06.c] _______

self = <test_codegen.TestCodeGen object at 0x7fab866ec250>
output_name = './TP04/tests/provided/step2/test06-all_in_mem.s'
exec_name = './TP04/tests/provided/step2/test06.riscv'
info = testinfo(exitcode=0, execcode=0, output='', linkargs=[], skip_test_expected=False)

    def link_and_run(self, output_name, exec_name, info):
        self.remove(exec_name)
        cmd = [
            ASM, output_name, 'TP04/libprint.s',
            '-o', exec_name
        ] + info.linkargs
        print(info)
        print("Assembling and linking " + output_name + ": " + ' '.join(cmd))
        try:
>           subprocess.check_output(cmd, timeout=60, stderr=subprocess.STDOUT)

test_codegen.py:169: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

timeout = 60
popenargs = (['riscv64-unknown-elf-gcc', './TP04/tests/provided/step2/test06-all_in_mem.s', 'TP04/libprint.s', '-o', './TP04/tests/provided/step2/test06.riscv'],)
kwargs = {'stderr': -2}

    def check_output(*popenargs, timeout=None, **kwargs):
        r"""Run command with arguments and return its output.
    
        If the exit code was non-zero it raises a CalledProcessError.  The
        CalledProcessError object will have the return code in the returncode
        attribute and output in the output attribute.
    
        The arguments are the same as for the Popen constructor.  Example:
    
        >>> check_output(["ls", "-l", "/dev/null"])
        b'crw-rw-rw- 1 root root 1, 3 Oct 18  2007 /dev/null\n'
    
        The stdout argument is not allowed as it is used internally.
        To capture standard error in the result, use stderr=STDOUT.
    
        >>> check_output(["/bin/sh", "-c",
        ...               "ls -l non_existent_file ; exit 0"],
        ...              stderr=STDOUT)
        b'ls: non_existent_file: No such file or directory\n'
    
        There is an additional optional argument, "input", allowing you to
        pass a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it too will be used internally.  Example:
    
        >>> check_output(["sed", "-e", "s/foo/bar/"],
        ...              input=b"when in the course of fooman events\n")
        b'when in the course of barman events\n'
    
        By default, all communication is in bytes, and therefore any "input"
        should be bytes, and the return value will be bytes.  If in text mode,
        any "input" should be a string, and the return value will be a string
        decoded according to locale encoding, or by "encoding" if set. Text mode
        is triggered by setting any of text, encoding, errors or universal_newlines.
        """
        if 'stdout' in kwargs:
            raise ValueError('stdout argument not allowed, it will be overridden.')
    
        if 'input' in kwargs and kwargs['input'] is None:
            # Explicitly passing input=None was previously equivalent to passing an
            # empty string. That is maintained here for backwards compatibility.
            if kwargs.get('universal_newlines') or kwargs.get('text'):
                empty = ''
            else:
                empty = b''
            kwargs['input'] = empty
    
>       return run(*popenargs, stdout=PIPE, timeout=timeout, check=True,
                   **kwargs).stdout

/usr/lib/python3.8/subprocess.py:415: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = False, timeout = 60, check = True
popenargs = (['riscv64-unknown-elf-gcc', './TP04/tests/provided/step2/test06-all_in_mem.s', 'TP04/libprint.s', '-o', './TP04/tests/provided/step2/test06.riscv'],)
kwargs = {'stderr': -2, 'stdout': -1}
process = <subprocess.Popen object at 0x7fab866b5700>
stdout = b"./TP04/tests/provided/step2/test06-all_in_mem.s: Assembler messages:\n./TP04/tests/provided/step2/test06-all_in_mem....100: Error: illegal operands `mv'\n./TP04/tests/provided/step2/test06-all_in_mem.s:104: Error: illegal operands `li'\n"
stderr = None, retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout is given, and the process takes too long, a TimeoutExpired
        exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['riscv64-unknown-elf-gcc', './TP04/tests/provided/step2/test06-all_in_mem.s', 'TP04/libprint.s', '-o', './TP04/tests/provided/step2/test06.riscv']' returned non-zero exit status 1.

/usr/lib/python3.8/subprocess.py:516: CalledProcessError

During handling of the above exception, another exception occurred:

self = <test_codegen.TestCodeGen object at 0x7fab866ec250>
filename = './TP04/tests/provided/step2/test06.c'

    @pytest.mark.parametrize('filename', ALL_IN_MEM_FILES)
    def test_alloc_mem(self, filename):
        expect = self.get_expect(filename)
>       actual = self.all_in_mem(filename, expect)

test_codegen.py:242: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
test_codegen.py:100: in all_in_mem
    return self.compile_and_simulate(file, info, reg_alloc='all_in_mem')
test_codegen.py:216: in compile_and_simulate
    return self.link_and_run(output_name, exec_name, info)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_codegen.TestCodeGen object at 0x7fab866ec250>
output_name = './TP04/tests/provided/step2/test06-all_in_mem.s'
exec_name = './TP04/tests/provided/step2/test06.riscv'
info = testinfo(exitcode=0, execcode=0, output='', linkargs=[], skip_test_expected=False)

    def link_and_run(self, output_name, exec_name, info):
        self.remove(exec_name)
        cmd = [
            ASM, output_name, 'TP04/libprint.s',
            '-o', exec_name
        ] + info.linkargs
        print(info)
        print("Assembling and linking " + output_name + ": " + ' '.join(cmd))
        try:
            subprocess.check_output(cmd, timeout=60, stderr=subprocess.STDOUT)
        except subprocess.CalledProcessError as e:
            print("Assembling failed:\n")
            print(e.output.decode())
            print("Assembler code below:\n")
            cat(output_name)
>           pytest.fail()
E           Failed

test_codegen.py:175: Failed
----------------------------- Captured stdout call -----------------------------
Compiling ...
/usr/bin/python3 ./MiniCC.py --reg-alloc=all_in_mem --output=./TP04/tests/provided/step2/test06-all_in_mem.s ./TP04/tests/provided/step2/test06.c
Exited with status: 0

Compiling ... OK
testinfo(exitcode=0, execcode=0, output='', linkargs=[], skip_test_expected=False)
Assembling and linking ./TP04/tests/provided/step2/test06-all_in_mem.s: riscv64-unknown-elf-gcc ./TP04/tests/provided/step2/test06-all_in_mem.s TP04/libprint.s -o ./TP04/tests/provided/step2/test06.riscv
Assembling failed:

./TP04/tests/provided/step2/test06-all_in_mem.s: Assembler messages:
./TP04/tests/provided/step2/test06-all_in_mem.s:20: Error: illegal operands `la'
./TP04/tests/provided/step2/test06-all_in_mem.s:26: Error: illegal operands `li'
./TP04/tests/provided/step2/test06-all_in_mem.s:38: Error: illegal operands `li'
./TP04/tests/provided/step2/test06-all_in_mem.s:41: Error: illegal operands `li'
./TP04/tests/provided/step2/test06-all_in_mem.s:44: Error: illegal operands `li'
./TP04/tests/provided/step2/test06-all_in_mem.s:48: Error: illegal operands `li'
./TP04/tests/provided/step2/test06-all_in_mem.s:51: Error: illegal operands `mv'
./TP04/tests/provided/step2/test06-all_in_mem.s:55: Error: illegal operands `li'
./TP04/tests/provided/step2/test06-all_in_mem.s:58: Error: illegal operands `li'
./TP04/tests/provided/step2/test06-all_in_mem.s:61: Error: illegal operands `bge'
./TP04/tests/provided/step2/test06-all_in_mem.s:64: Error: illegal operands `li'
./TP04/tests/provided/step2/test06-all_in_mem.s:68: Error: illegal operands `li'
./TP04/tests/provided/step2/test06-all_in_mem.s:71: Error: illegal operands `beq'
./TP04/tests/provided/step2/test06-all_in_mem.s:75: Error: illegal operands `li'
./TP04/tests/provided/step2/test06-all_in_mem.s:78: Error: illegal operands `mv'
./TP04/tests/provided/step2/test06-all_in_mem.s:86: Error: illegal operands `li'
./TP04/tests/provided/step2/test06-all_in_mem.s:89: Error: illegal operands `mv'
./TP04/tests/provided/step2/test06-all_in_mem.s:94: Error: illegal operands `li'
./TP04/tests/provided/step2/test06-all_in_mem.s:97: Error: illegal operands `add'
./TP04/tests/provided/step2/test06-all_in_mem.s:100: Error: illegal operands `mv'
./TP04/tests/provided/step2/test06-all_in_mem.s:104: Error: illegal operands `li'

Assembler code below:

##Automatically generated RISCV code, MIF08 & CAP
## all-in-memory allocation


##prelude

        .text
        .globl main
main:
        addi sp, sp, -112
        sd ra, 0(sp)
        sd fp, 8(sp)
        addi fp, sp, 112
        j lbl_main_4_main
        

##Generated Code
lbl_div_by_zero_0_main:
        # la a0, lbl_div_by_zero_0_main_msg
        la
        # end la a0, lbl_div_by_zero_0_main_msg
        # call println_string
        call
        # end call println_string
        # li a0, 1
        li
        # end li a0, 1
        # call exit
        call
        # end call exit
        j lbl_div_by_zero_0_main_msg
lbl_div_by_zero_0_main_msg:
        # .string "Division by 0"
        .string
        # end .string "Division by 0"
        j lbl_end_4_main
lbl_main_4_main:
        # li temp_0, 0
        li
        # end li temp_0, 0
        # li temp_1, 0
        li
        # end li temp_1, 0
        # li temp_2, 0
        li
        # end li temp_2, 0
        # (stat (assignment x = (expr (atom 2))) ;)
        # li temp_3, 2
        li
        # end li temp_3, 2
        # mv temp_2, temp_3
        mv
        # end mv temp_2, temp_3
        # (stat (if_stat if ( (expr (expr (atom x)) < (expr (atom 3))) ) (stat_block { (block (stat (assignment y = (expr (atom 7))) ;)) }) else (stat_block { (block (stat (assignment y = (expr (atom 8))) ;)) })))
        # li temp_5, 3
        li
        # end li temp_5, 3
        # li temp_4, 0
        li
        # end li temp_4, 0
        # bge temp_2, temp_5, lbl_endrel_3_main
        bge
        # end bge temp_2, temp_5, lbl_endrel_3_main
        # li temp_4, 1
        li
        # end li temp_4, 1
lbl_endrel_3_main:
        # li temp_6, 0
        li
        # end li temp_6, 0
        # beq temp_4, temp_6, lbl_else_1_main
        beq
        # end beq temp_4, temp_6, lbl_else_1_main
        # (stat (assignment y = (expr (atom 7))) ;)
        # li temp_7, 7
        li
        # end li temp_7, 7
        # mv temp_1, temp_7
        mv
        # end mv temp_1, temp_7
        # j lbl_end_if_2_main
        j
        # end j lbl_end_if_2_main
lbl_else_1_main:
        # (stat (assignment y = (expr (atom 8))) ;)
        # li temp_8, 8
        li
        # end li temp_8, 8
        # mv temp_1, temp_8
        mv
        # end mv temp_1, temp_8
lbl_end_if_2_main:
        # (stat (assignment z = (expr (expr (atom y)) + (expr (atom 1)))) ;)
        # li temp_9, 1
        li
        # end li temp_9, 1
        # add temp_10, temp_1, temp_9
        add
        # end add temp_10, temp_1, temp_9
        # mv temp_0, temp_10
        mv
        # end mv temp_0, temp_10
        # Return at end of function:
        # li a0, 0
        li
        # end li a0, 0
        j lbl_end_4_main


##postlude

lbl_end_4_main:
        ld ra, 0(sp)
        ld fp, 8(sp)
        addi sp, sp, 112
        ret
        
_______ TestCodeGen.test_alloc_mem[./TP04/tests/provided/step2/test07.c] _______

self = <test_codegen.TestCodeGen object at 0x7fab869ce280>
output_name = './TP04/tests/provided/step2/test07-all_in_mem.s'
exec_name = './TP04/tests/provided/step2/test07.riscv'
info = testinfo(exitcode=0, execcode=0, output='', linkargs=[], skip_test_expected=False)

    def link_and_run(self, output_name, exec_name, info):
        self.remove(exec_name)
        cmd = [
            ASM, output_name, 'TP04/libprint.s',
            '-o', exec_name
        ] + info.linkargs
        print(info)
        print("Assembling and linking " + output_name + ": " + ' '.join(cmd))
        try:
>           subprocess.check_output(cmd, timeout=60, stderr=subprocess.STDOUT)

test_codegen.py:169: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

timeout = 60
popenargs = (['riscv64-unknown-elf-gcc', './TP04/tests/provided/step2/test07-all_in_mem.s', 'TP04/libprint.s', '-o', './TP04/tests/provided/step2/test07.riscv'],)
kwargs = {'stderr': -2}

    def check_output(*popenargs, timeout=None, **kwargs):
        r"""Run command with arguments and return its output.
    
        If the exit code was non-zero it raises a CalledProcessError.  The
        CalledProcessError object will have the return code in the returncode
        attribute and output in the output attribute.
    
        The arguments are the same as for the Popen constructor.  Example:
    
        >>> check_output(["ls", "-l", "/dev/null"])
        b'crw-rw-rw- 1 root root 1, 3 Oct 18  2007 /dev/null\n'
    
        The stdout argument is not allowed as it is used internally.
        To capture standard error in the result, use stderr=STDOUT.
    
        >>> check_output(["/bin/sh", "-c",
        ...               "ls -l non_existent_file ; exit 0"],
        ...              stderr=STDOUT)
        b'ls: non_existent_file: No such file or directory\n'
    
        There is an additional optional argument, "input", allowing you to
        pass a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it too will be used internally.  Example:
    
        >>> check_output(["sed", "-e", "s/foo/bar/"],
        ...              input=b"when in the course of fooman events\n")
        b'when in the course of barman events\n'
    
        By default, all communication is in bytes, and therefore any "input"
        should be bytes, and the return value will be bytes.  If in text mode,
        any "input" should be a string, and the return value will be a string
        decoded according to locale encoding, or by "encoding" if set. Text mode
        is triggered by setting any of text, encoding, errors or universal_newlines.
        """
        if 'stdout' in kwargs:
            raise ValueError('stdout argument not allowed, it will be overridden.')
    
        if 'input' in kwargs and kwargs['input'] is None:
            # Explicitly passing input=None was previously equivalent to passing an
            # empty string. That is maintained here for backwards compatibility.
            if kwargs.get('universal_newlines') or kwargs.get('text'):
                empty = ''
            else:
                empty = b''
            kwargs['input'] = empty
    
>       return run(*popenargs, stdout=PIPE, timeout=timeout, check=True,
                   **kwargs).stdout

/usr/lib/python3.8/subprocess.py:415: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = False, timeout = 60, check = True
popenargs = (['riscv64-unknown-elf-gcc', './TP04/tests/provided/step2/test07-all_in_mem.s', 'TP04/libprint.s', '-o', './TP04/tests/provided/step2/test07.riscv'],)
kwargs = {'stderr': -2, 'stdout': -1}
process = <subprocess.Popen object at 0x7fab869ceca0>
stdout = b"./TP04/tests/provided/step2/test07-all_in_mem.s: Assembler messages:\n./TP04/tests/provided/step2/test07-all_in_mem....134: Error: illegal operands `mv'\n./TP04/tests/provided/step2/test07-all_in_mem.s:138: Error: illegal operands `li'\n"
stderr = None, retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout is given, and the process takes too long, a TimeoutExpired
        exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['riscv64-unknown-elf-gcc', './TP04/tests/provided/step2/test07-all_in_mem.s', 'TP04/libprint.s', '-o', './TP04/tests/provided/step2/test07.riscv']' returned non-zero exit status 1.

/usr/lib/python3.8/subprocess.py:516: CalledProcessError

During handling of the above exception, another exception occurred:

self = <test_codegen.TestCodeGen object at 0x7fab869ce280>
filename = './TP04/tests/provided/step2/test07.c'

    @pytest.mark.parametrize('filename', ALL_IN_MEM_FILES)
    def test_alloc_mem(self, filename):
        expect = self.get_expect(filename)
>       actual = self.all_in_mem(filename, expect)

test_codegen.py:242: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
test_codegen.py:100: in all_in_mem
    return self.compile_and_simulate(file, info, reg_alloc='all_in_mem')
test_codegen.py:216: in compile_and_simulate
    return self.link_and_run(output_name, exec_name, info)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_codegen.TestCodeGen object at 0x7fab869ce280>
output_name = './TP04/tests/provided/step2/test07-all_in_mem.s'
exec_name = './TP04/tests/provided/step2/test07.riscv'
info = testinfo(exitcode=0, execcode=0, output='', linkargs=[], skip_test_expected=False)

    def link_and_run(self, output_name, exec_name, info):
        self.remove(exec_name)
        cmd = [
            ASM, output_name, 'TP04/libprint.s',
            '-o', exec_name
        ] + info.linkargs
        print(info)
        print("Assembling and linking " + output_name + ": " + ' '.join(cmd))
        try:
            subprocess.check_output(cmd, timeout=60, stderr=subprocess.STDOUT)
        except subprocess.CalledProcessError as e:
            print("Assembling failed:\n")
            print(e.output.decode())
            print("Assembler code below:\n")
            cat(output_name)
>           pytest.fail()
E           Failed

test_codegen.py:175: Failed
----------------------------- Captured stdout call -----------------------------
Compiling ...
/usr/bin/python3 ./MiniCC.py --reg-alloc=all_in_mem --output=./TP04/tests/provided/step2/test07-all_in_mem.s ./TP04/tests/provided/step2/test07.c
Exited with status: 0

Compiling ... OK
testinfo(exitcode=0, execcode=0, output='', linkargs=[], skip_test_expected=False)
Assembling and linking ./TP04/tests/provided/step2/test07-all_in_mem.s: riscv64-unknown-elf-gcc ./TP04/tests/provided/step2/test07-all_in_mem.s TP04/libprint.s -o ./TP04/tests/provided/step2/test07.riscv
Assembling failed:

./TP04/tests/provided/step2/test07-all_in_mem.s: Assembler messages:
./TP04/tests/provided/step2/test07-all_in_mem.s:20: Error: illegal operands `la'
./TP04/tests/provided/step2/test07-all_in_mem.s:26: Error: illegal operands `li'
./TP04/tests/provided/step2/test07-all_in_mem.s:38: Error: illegal operands `li'
./TP04/tests/provided/step2/test07-all_in_mem.s:41: Error: illegal operands `li'
./TP04/tests/provided/step2/test07-all_in_mem.s:44: Error: illegal operands `li'
./TP04/tests/provided/step2/test07-all_in_mem.s:47: Error: illegal operands `li'
./TP04/tests/provided/step2/test07-all_in_mem.s:51: Error: illegal operands `li'
./TP04/tests/provided/step2/test07-all_in_mem.s:54: Error: illegal operands `mv'
./TP04/tests/provided/step2/test07-all_in_mem.s:58: Error: illegal operands `li'
./TP04/tests/provided/step2/test07-all_in_mem.s:61: Error: illegal operands `li'
./TP04/tests/provided/step2/test07-all_in_mem.s:64: Error: illegal operands `bge'
./TP04/tests/provided/step2/test07-all_in_mem.s:67: Error: illegal operands `li'
./TP04/tests/provided/step2/test07-all_in_mem.s:71: Error: illegal operands `li'
./TP04/tests/provided/step2/test07-all_in_mem.s:74: Error: illegal operands `beq'
./TP04/tests/provided/step2/test07-all_in_mem.s:78: Error: illegal operands `li'
./TP04/tests/provided/step2/test07-all_in_mem.s:81: Error: illegal operands `mv'
./TP04/tests/provided/step2/test07-all_in_mem.s:88: Error: illegal operands `li'
./TP04/tests/provided/step2/test07-all_in_mem.s:91: Error: illegal operands `li'
./TP04/tests/provided/step2/test07-all_in_mem.s:94: Error: illegal operands `bge'
./TP04/tests/provided/step2/test07-all_in_mem.s:97: Error: illegal operands `li'
./TP04/tests/provided/step2/test07-all_in_mem.s:101: Error: illegal operands `li'
./TP04/tests/provided/step2/test07-all_in_mem.s:104: Error: illegal operands `beq'
./TP04/tests/provided/step2/test07-all_in_mem.s:108: Error: illegal operands `li'
./TP04/tests/provided/step2/test07-all_in_mem.s:111: Error: illegal operands `mv'
./TP04/tests/provided/step2/test07-all_in_mem.s:119: Error: illegal operands `li'
./TP04/tests/provided/step2/test07-all_in_mem.s:122: Error: illegal operands `mv'
./TP04/tests/provided/step2/test07-all_in_mem.s:128: Error: illegal operands `li'
./TP04/tests/provided/step2/test07-all_in_mem.s:131: Error: illegal operands `add'
./TP04/tests/provided/step2/test07-all_in_mem.s:134: Error: illegal operands `mv'
./TP04/tests/provided/step2/test07-all_in_mem.s:138: Error: illegal operands `li'

Assembler code below:

##Automatically generated RISCV code, MIF08 & CAP
## all-in-memory allocation


##prelude

        .text
        .globl main
main:
        addi sp, sp, -144
        sd ra, 0(sp)
        sd fp, 8(sp)
        addi fp, sp, 144
        j lbl_main_7_main
        

##Generated Code
lbl_div_by_zero_0_main:
        # la a0, lbl_div_by_zero_0_main_msg
        la
        # end la a0, lbl_div_by_zero_0_main_msg
        # call println_string
        call
        # end call println_string
        # li a0, 1
        li
        # end li a0, 1
        # call exit
        call
        # end call exit
        j lbl_div_by_zero_0_main_msg
lbl_div_by_zero_0_main_msg:
        # .string "Division by 0"
        .string
        # end .string "Division by 0"
        j lbl_end_7_main
lbl_main_7_main:
        # li temp_0, 0
        li
        # end li temp_0, 0
        # li temp_1, 0
        li
        # end li temp_1, 0
        # li temp_2, 0
        li
        # end li temp_2, 0
        # li temp_3, 0
        li
        # end li temp_3, 0
        # (stat (assignment x = (expr (atom 3))) ;)
        # li temp_4, 3
        li
        # end li temp_4, 3
        # mv temp_3, temp_4
        mv
        # end mv temp_3, temp_4
        # (stat (if_stat if ( (expr (expr (atom x)) < (expr (atom 4))) ) (stat_block { (block (stat (assignment z = (expr (atom 4))) ;)) }) else (stat_block (stat (if_stat if ( (expr (expr (atom x)) < (expr (atom 5))) ) (stat_block { (block (stat (assignment z = (expr (atom 5))) ;)) }) else (stat_block { (block (stat (assignment z = (expr (atom 6))) ;)) }))))))
        # li temp_6, 4
        li
        # end li temp_6, 4
        # li temp_5, 0
        li
        # end li temp_5, 0
        # bge temp_3, temp_6, lbl_endrel_3_main
        bge
        # end bge temp_3, temp_6, lbl_endrel_3_main
        # li temp_5, 1
        li
        # end li temp_5, 1
lbl_endrel_3_main:
        # li temp_7, 0
        li
        # end li temp_7, 0
        # beq temp_5, temp_7, lbl_else_1_main
        beq
        # end beq temp_5, temp_7, lbl_else_1_main
        # (stat (assignment z = (expr (atom 4))) ;)
        # li temp_8, 4
        li
        # end li temp_8, 4
        # mv temp_1, temp_8
        mv
        # end mv temp_1, temp_8
        # j lbl_end_if_2_main
        j
        # end j lbl_end_if_2_main
lbl_else_1_main:
        # li temp_10, 5
        li
        # end li temp_10, 5
        # li temp_9, 0
        li
        # end li temp_9, 0
        # bge temp_3, temp_10, lbl_endrel_6_main
        bge
        # end bge temp_3, temp_10, lbl_endrel_6_main
        # li temp_9, 1
        li
        # end li temp_9, 1
lbl_endrel_6_main:
        # li temp_11, 0
        li
        # end li temp_11, 0
        # beq temp_9, temp_11, lbl_else_4_main
        beq
        # end beq temp_9, temp_11, lbl_else_4_main
        # (stat (assignment z = (expr (atom 5))) ;)
        # li temp_12, 5
        li
        # end li temp_12, 5
        # mv temp_1, temp_12
        mv
        # end mv temp_1, temp_12
        # j lbl_end_if_5_main
        j
        # end j lbl_end_if_5_main
lbl_else_4_main:
        # (stat (assignment z = (expr (atom 6))) ;)
        # li temp_13, 6
        li
        # end li temp_13, 6
        # mv temp_1, temp_13
        mv
        # end mv temp_1, temp_13
lbl_end_if_5_main:
lbl_end_if_2_main:
        # (stat (assignment u = (expr (expr (atom z)) + (expr (atom 1)))) ;)
        # li temp_14, 1
        li
        # end li temp_14, 1
        # add temp_15, temp_1, temp_14
        add
        # end add temp_15, temp_1, temp_14
        # mv temp_0, temp_15
        mv
        # end mv temp_0, temp_15
        # Return at end of function:
        # li a0, 0
        li
        # end li a0, 0
        j lbl_end_7_main


##postlude

lbl_end_7_main:
        ld ra, 0(sp)
        ld fp, 8(sp)
        addi sp, sp, 144
        ret
        
_____ TestCodeGen.test_alloc_mem[./TP04/tests/provided/step2/test_bool.c] ______

self = <test_codegen.TestCodeGen object at 0x7fab867babe0>
output_name = './TP04/tests/provided/step2/test_bool-all_in_mem.s'
exec_name = './TP04/tests/provided/step2/test_bool.riscv'
info = testinfo(exitcode=0, execcode=0, output='0\n1\n1\n0\n', linkargs=[], skip_test_expected=False)

    def link_and_run(self, output_name, exec_name, info):
        self.remove(exec_name)
        cmd = [
            ASM, output_name, 'TP04/libprint.s',
            '-o', exec_name
        ] + info.linkargs
        print(info)
        print("Assembling and linking " + output_name + ": " + ' '.join(cmd))
        try:
>           subprocess.check_output(cmd, timeout=60, stderr=subprocess.STDOUT)

test_codegen.py:169: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

timeout = 60
popenargs = (['riscv64-unknown-elf-gcc', './TP04/tests/provided/step2/test_bool-all_in_mem.s', 'TP04/libprint.s', '-o', './TP04/tests/provided/step2/test_bool.riscv'],)
kwargs = {'stderr': -2}

    def check_output(*popenargs, timeout=None, **kwargs):
        r"""Run command with arguments and return its output.
    
        If the exit code was non-zero it raises a CalledProcessError.  The
        CalledProcessError object will have the return code in the returncode
        attribute and output in the output attribute.
    
        The arguments are the same as for the Popen constructor.  Example:
    
        >>> check_output(["ls", "-l", "/dev/null"])
        b'crw-rw-rw- 1 root root 1, 3 Oct 18  2007 /dev/null\n'
    
        The stdout argument is not allowed as it is used internally.
        To capture standard error in the result, use stderr=STDOUT.
    
        >>> check_output(["/bin/sh", "-c",
        ...               "ls -l non_existent_file ; exit 0"],
        ...              stderr=STDOUT)
        b'ls: non_existent_file: No such file or directory\n'
    
        There is an additional optional argument, "input", allowing you to
        pass a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it too will be used internally.  Example:
    
        >>> check_output(["sed", "-e", "s/foo/bar/"],
        ...              input=b"when in the course of fooman events\n")
        b'when in the course of barman events\n'
    
        By default, all communication is in bytes, and therefore any "input"
        should be bytes, and the return value will be bytes.  If in text mode,
        any "input" should be a string, and the return value will be a string
        decoded according to locale encoding, or by "encoding" if set. Text mode
        is triggered by setting any of text, encoding, errors or universal_newlines.
        """
        if 'stdout' in kwargs:
            raise ValueError('stdout argument not allowed, it will be overridden.')
    
        if 'input' in kwargs and kwargs['input'] is None:
            # Explicitly passing input=None was previously equivalent to passing an
            # empty string. That is maintained here for backwards compatibility.
            if kwargs.get('universal_newlines') or kwargs.get('text'):
                empty = ''
            else:
                empty = b''
            kwargs['input'] = empty
    
>       return run(*popenargs, stdout=PIPE, timeout=timeout, check=True,
                   **kwargs).stdout

/usr/lib/python3.8/subprocess.py:415: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = False, timeout = 60, check = True
popenargs = (['riscv64-unknown-elf-gcc', './TP04/tests/provided/step2/test_bool-all_in_mem.s', 'TP04/libprint.s', '-o', './TP04/tests/provided/step2/test_bool.riscv'],)
kwargs = {'stderr': -2, 'stdout': -1}
process = <subprocess.Popen object at 0x7fab867baf70>
stdout = b"./TP04/tests/provided/step2/test_bool-all_in_mem.s: Assembler messages:\n./TP04/tests/provided/step2/test_bool-all_i...3: Error: illegal operands `mv'\n./TP04/tests/provided/step2/test_bool-all_in_mem.s:90: Error: illegal operands `li'\n"
stderr = None, retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout is given, and the process takes too long, a TimeoutExpired
        exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['riscv64-unknown-elf-gcc', './TP04/tests/provided/step2/test_bool-all_in_mem.s', 'TP04/libprint.s', '-o', './TP04/tests/provided/step2/test_bool.riscv']' returned non-zero exit status 1.

/usr/lib/python3.8/subprocess.py:516: CalledProcessError

During handling of the above exception, another exception occurred:

self = <test_codegen.TestCodeGen object at 0x7fab867babe0>
filename = './TP04/tests/provided/step2/test_bool.c'

    @pytest.mark.parametrize('filename', ALL_IN_MEM_FILES)
    def test_alloc_mem(self, filename):
        expect = self.get_expect(filename)
>       actual = self.all_in_mem(filename, expect)

test_codegen.py:242: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
test_codegen.py:100: in all_in_mem
    return self.compile_and_simulate(file, info, reg_alloc='all_in_mem')
test_codegen.py:216: in compile_and_simulate
    return self.link_and_run(output_name, exec_name, info)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_codegen.TestCodeGen object at 0x7fab867babe0>
output_name = './TP04/tests/provided/step2/test_bool-all_in_mem.s'
exec_name = './TP04/tests/provided/step2/test_bool.riscv'
info = testinfo(exitcode=0, execcode=0, output='0\n1\n1\n0\n', linkargs=[], skip_test_expected=False)

    def link_and_run(self, output_name, exec_name, info):
        self.remove(exec_name)
        cmd = [
            ASM, output_name, 'TP04/libprint.s',
            '-o', exec_name
        ] + info.linkargs
        print(info)
        print("Assembling and linking " + output_name + ": " + ' '.join(cmd))
        try:
            subprocess.check_output(cmd, timeout=60, stderr=subprocess.STDOUT)
        except subprocess.CalledProcessError as e:
            print("Assembling failed:\n")
            print(e.output.decode())
            print("Assembler code below:\n")
            cat(output_name)
>           pytest.fail()
E           Failed

test_codegen.py:175: Failed
----------------------------- Captured stdout call -----------------------------
Compiling ...
/usr/bin/python3 ./MiniCC.py --reg-alloc=all_in_mem --output=./TP04/tests/provided/step2/test_bool-all_in_mem.s ./TP04/tests/provided/step2/test_bool.c
Exited with status: 0
false
true
true
false

Compiling ... OK
testinfo(exitcode=0, execcode=0, output='0\n1\n1\n0\n', linkargs=[], skip_test_expected=False)
Assembling and linking ./TP04/tests/provided/step2/test_bool-all_in_mem.s: riscv64-unknown-elf-gcc ./TP04/tests/provided/step2/test_bool-all_in_mem.s TP04/libprint.s -o ./TP04/tests/provided/step2/test_bool.riscv
Assembling failed:

./TP04/tests/provided/step2/test_bool-all_in_mem.s: Assembler messages:
./TP04/tests/provided/step2/test_bool-all_in_mem.s:20: Error: illegal operands `la'
./TP04/tests/provided/step2/test_bool-all_in_mem.s:26: Error: illegal operands `li'
./TP04/tests/provided/step2/test_bool-all_in_mem.s:38: Error: illegal operands `li'
./TP04/tests/provided/step2/test_bool-all_in_mem.s:42: Error: illegal operands `li'
./TP04/tests/provided/step2/test_bool-all_in_mem.s:45: Error: illegal operands `mv'
./TP04/tests/provided/step2/test_bool-all_in_mem.s:49: Error: illegal operands `mv'
./TP04/tests/provided/step2/test_bool-all_in_mem.s:56: Error: illegal operands `li'
./TP04/tests/provided/step2/test_bool-all_in_mem.s:59: Error: illegal operands `mv'
./TP04/tests/provided/step2/test_bool-all_in_mem.s:63: Error: illegal operands `mv'
./TP04/tests/provided/step2/test_bool-all_in_mem.s:70: Error: illegal operands `li'
./TP04/tests/provided/step2/test_bool-all_in_mem.s:73: Error: illegal operands `mv'
./TP04/tests/provided/step2/test_bool-all_in_mem.s:80: Error: illegal operands `li'
./TP04/tests/provided/step2/test_bool-all_in_mem.s:83: Error: illegal operands `mv'
./TP04/tests/provided/step2/test_bool-all_in_mem.s:90: Error: illegal operands `li'

Assembler code below:

##Automatically generated RISCV code, MIF08 & CAP
## all-in-memory allocation


##prelude

        .text
        .globl main
main:
        addi sp, sp, -64
        sd ra, 0(sp)
        sd fp, 8(sp)
        addi fp, sp, 64
        j lbl_main_1_main
        

##Generated Code
lbl_div_by_zero_0_main:
        # la a0, lbl_div_by_zero_0_main_msg
        la
        # end la a0, lbl_div_by_zero_0_main_msg
        # call println_string
        call
        # end call println_string
        # li a0, 1
        li
        # end li a0, 1
        # call exit
        call
        # end call exit
        j lbl_div_by_zero_0_main_msg
lbl_div_by_zero_0_main_msg:
        # .string "Division by 0"
        .string
        # end .string "Division by 0"
        j lbl_end_1_main
lbl_main_1_main:
        # li temp_0, 0
        li
        # end li temp_0, 0
        # (stat (assignment b = (expr (atom false))) ;)
        # li temp_1, 0
        li
        # end li temp_1, 0
        # mv temp_0, temp_1
        mv
        # end mv temp_0, temp_1
        # (stat (print_stat println_int ( (expr (atom b)) ) ;))
        # mv a0, temp_0
        mv
        # end mv a0, temp_0
        # call println_int
        call
        # end call println_int
        # (stat (assignment b = (expr (atom true))) ;)
        # li temp_2, 1
        li
        # end li temp_2, 1
        # mv temp_0, temp_2
        mv
        # end mv temp_0, temp_2
        # (stat (print_stat println_int ( (expr (atom b)) ) ;))
        # mv a0, temp_0
        mv
        # end mv a0, temp_0
        # call println_int
        call
        # end call println_int
        # (stat (print_stat println_int ( (expr (atom true)) ) ;))
        # li temp_3, 1
        li
        # end li temp_3, 1
        # mv a0, temp_3
        mv
        # end mv a0, temp_3
        # call println_int
        call
        # end call println_int
        # (stat (print_stat println_int ( (expr (atom false)) ) ;))
        # li temp_4, 0
        li
        # end li temp_4, 0
        # mv a0, temp_4
        mv
        # end mv a0, temp_4
        # call println_int
        call
        # end call println_int
        # Return at end of function:
        # li a0, 0
        li
        # end li a0, 0
        j lbl_end_1_main


##postlude

lbl_end_1_main:
        ld ra, 0(sp)
        ld fp, 8(sp)
        addi sp, sp, 64
        ret
        
__ TestCodeGen.test_alloc_mem[./TP04/tests/provided/step2/test_compare_1_1.c] __

self = <test_codegen.TestCodeGen object at 0x7fab869b7760>
output_name = './TP04/tests/provided/step2/test_compare_1_1-all_in_mem.s'
exec_name = './TP04/tests/provided/step2/test_compare_1_1.riscv'
info = testinfo(exitcode=0, execcode=0, output='1\n', linkargs=[], skip_test_expected=False)

    def link_and_run(self, output_name, exec_name, info):
        self.remove(exec_name)
        cmd = [
            ASM, output_name, 'TP04/libprint.s',
            '-o', exec_name
        ] + info.linkargs
        print(info)
        print("Assembling and linking " + output_name + ": " + ' '.join(cmd))
        try:
>           subprocess.check_output(cmd, timeout=60, stderr=subprocess.STDOUT)

test_codegen.py:169: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

timeout = 60
popenargs = (['riscv64-unknown-elf-gcc', './TP04/tests/provided/step2/test_compare_1_1-all_in_mem.s', 'TP04/libprint.s', '-o', './TP04/tests/provided/step2/test_compare_1_1.riscv'],)
kwargs = {'stderr': -2}

    def check_output(*popenargs, timeout=None, **kwargs):
        r"""Run command with arguments and return its output.
    
        If the exit code was non-zero it raises a CalledProcessError.  The
        CalledProcessError object will have the return code in the returncode
        attribute and output in the output attribute.
    
        The arguments are the same as for the Popen constructor.  Example:
    
        >>> check_output(["ls", "-l", "/dev/null"])
        b'crw-rw-rw- 1 root root 1, 3 Oct 18  2007 /dev/null\n'
    
        The stdout argument is not allowed as it is used internally.
        To capture standard error in the result, use stderr=STDOUT.
    
        >>> check_output(["/bin/sh", "-c",
        ...               "ls -l non_existent_file ; exit 0"],
        ...              stderr=STDOUT)
        b'ls: non_existent_file: No such file or directory\n'
    
        There is an additional optional argument, "input", allowing you to
        pass a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it too will be used internally.  Example:
    
        >>> check_output(["sed", "-e", "s/foo/bar/"],
        ...              input=b"when in the course of fooman events\n")
        b'when in the course of barman events\n'
    
        By default, all communication is in bytes, and therefore any "input"
        should be bytes, and the return value will be bytes.  If in text mode,
        any "input" should be a string, and the return value will be a string
        decoded according to locale encoding, or by "encoding" if set. Text mode
        is triggered by setting any of text, encoding, errors or universal_newlines.
        """
        if 'stdout' in kwargs:
            raise ValueError('stdout argument not allowed, it will be overridden.')
    
        if 'input' in kwargs and kwargs['input'] is None:
            # Explicitly passing input=None was previously equivalent to passing an
            # empty string. That is maintained here for backwards compatibility.
            if kwargs.get('universal_newlines') or kwargs.get('text'):
                empty = ''
            else:
                empty = b''
            kwargs['input'] = empty
    
>       return run(*popenargs, stdout=PIPE, timeout=timeout, check=True,
                   **kwargs).stdout

/usr/lib/python3.8/subprocess.py:415: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = False, timeout = 60, check = True
popenargs = (['riscv64-unknown-elf-gcc', './TP04/tests/provided/step2/test_compare_1_1-all_in_mem.s', 'TP04/libprint.s', '-o', './TP04/tests/provided/step2/test_compare_1_1.riscv'],)
kwargs = {'stderr': -2, 'stdout': -1}
process = <subprocess.Popen object at 0x7fab869b7880>
stdout = b"./TP04/tests/provided/step2/test_compare_1_1-all_in_mem.s: Assembler messages:\n./TP04/tests/provided/step2/test_com...r: illegal operands `mv'\n./TP04/tests/provided/step2/test_compare_1_1-all_in_mem.s:62: Error: illegal operands `li'\n"
stderr = None, retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout is given, and the process takes too long, a TimeoutExpired
        exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['riscv64-unknown-elf-gcc', './TP04/tests/provided/step2/test_compare_1_1-all_in_mem.s', 'TP04/libprint.s', '-o', './TP04/tests/provided/step2/test_compare_1_1.riscv']' returned non-zero exit status 1.

/usr/lib/python3.8/subprocess.py:516: CalledProcessError

During handling of the above exception, another exception occurred:

self = <test_codegen.TestCodeGen object at 0x7fab869b7760>
filename = './TP04/tests/provided/step2/test_compare_1_1.c'

    @pytest.mark.parametrize('filename', ALL_IN_MEM_FILES)
    def test_alloc_mem(self, filename):
        expect = self.get_expect(filename)
>       actual = self.all_in_mem(filename, expect)

test_codegen.py:242: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
test_codegen.py:100: in all_in_mem
    return self.compile_and_simulate(file, info, reg_alloc='all_in_mem')
test_codegen.py:216: in compile_and_simulate
    return self.link_and_run(output_name, exec_name, info)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_codegen.TestCodeGen object at 0x7fab869b7760>
output_name = './TP04/tests/provided/step2/test_compare_1_1-all_in_mem.s'
exec_name = './TP04/tests/provided/step2/test_compare_1_1.riscv'
info = testinfo(exitcode=0, execcode=0, output='1\n', linkargs=[], skip_test_expected=False)

    def link_and_run(self, output_name, exec_name, info):
        self.remove(exec_name)
        cmd = [
            ASM, output_name, 'TP04/libprint.s',
            '-o', exec_name
        ] + info.linkargs
        print(info)
        print("Assembling and linking " + output_name + ": " + ' '.join(cmd))
        try:
            subprocess.check_output(cmd, timeout=60, stderr=subprocess.STDOUT)
        except subprocess.CalledProcessError as e:
            print("Assembling failed:\n")
            print(e.output.decode())
            print("Assembler code below:\n")
            cat(output_name)
>           pytest.fail()
E           Failed

test_codegen.py:175: Failed
----------------------------- Captured stdout call -----------------------------
Compiling ...
/usr/bin/python3 ./MiniCC.py --reg-alloc=all_in_mem --output=./TP04/tests/provided/step2/test_compare_1_1-all_in_mem.s ./TP04/tests/provided/step2/test_compare_1_1.c
Exited with status: 0

Compiling ... OK
testinfo(exitcode=0, execcode=0, output='1\n', linkargs=[], skip_test_expected=False)
Assembling and linking ./TP04/tests/provided/step2/test_compare_1_1-all_in_mem.s: riscv64-unknown-elf-gcc ./TP04/tests/provided/step2/test_compare_1_1-all_in_mem.s TP04/libprint.s -o ./TP04/tests/provided/step2/test_compare_1_1.riscv
Assembling failed:

./TP04/tests/provided/step2/test_compare_1_1-all_in_mem.s: Assembler messages:
./TP04/tests/provided/step2/test_compare_1_1-all_in_mem.s:20: Error: illegal operands `la'
./TP04/tests/provided/step2/test_compare_1_1-all_in_mem.s:26: Error: illegal operands `li'
./TP04/tests/provided/step2/test_compare_1_1-all_in_mem.s:39: Error: illegal operands `li'
./TP04/tests/provided/step2/test_compare_1_1-all_in_mem.s:42: Error: illegal operands `li'
./TP04/tests/provided/step2/test_compare_1_1-all_in_mem.s:45: Error: illegal operands `li'
./TP04/tests/provided/step2/test_compare_1_1-all_in_mem.s:48: Error: illegal operands `blt'
./TP04/tests/provided/step2/test_compare_1_1-all_in_mem.s:51: Error: illegal operands `li'
./TP04/tests/provided/step2/test_compare_1_1-all_in_mem.s:55: Error: illegal operands `mv'
./TP04/tests/provided/step2/test_compare_1_1-all_in_mem.s:62: Error: illegal operands `li'

Assembler code below:

##Automatically generated RISCV code, MIF08 & CAP
## all-in-memory allocation


##prelude

        .text
        .globl main
main:
        addi sp, sp, -48
        sd ra, 0(sp)
        sd fp, 8(sp)
        addi fp, sp, 48
        j lbl_main_2_main
        

##Generated Code
lbl_div_by_zero_0_main:
        # la a0, lbl_div_by_zero_0_main_msg
        la
        # end la a0, lbl_div_by_zero_0_main_msg
        # call println_string
        call
        # end call println_string
        # li a0, 1
        li
        # end li a0, 1
        # call exit
        call
        # end call exit
        j lbl_div_by_zero_0_main_msg
lbl_div_by_zero_0_main_msg:
        # .string "Division by 0"
        .string
        # end .string "Division by 0"
        j lbl_end_2_main
lbl_main_2_main:
        # (stat (print_stat println_int ( (expr (expr (atom 3)) >= (expr (atom 2))) ) ;))
        # li temp_1, 3
        li
        # end li temp_1, 3
        # li temp_2, 2
        li
        # end li temp_2, 2
        # li temp_0, 0
        li
        # end li temp_0, 0
        # blt temp_1, temp_2, lbl_endrel_1_main
        blt
        # end blt temp_1, temp_2, lbl_endrel_1_main
        # li temp_0, 1
        li
        # end li temp_0, 1
lbl_endrel_1_main:
        # mv a0, temp_0
        mv
        # end mv a0, temp_0
        # call println_int
        call
        # end call println_int
        # Return at end of function:
        # li a0, 0
        li
        # end li a0, 0
        j lbl_end_2_main


##postlude

lbl_end_2_main:
        ld ra, 0(sp)
        ld fp, 8(sp)
        addi sp, sp, 48
        ret
        
______ TestCodeGen.test_alloc_mem[./TP04/tests/provided/step2/test_if2.c] ______

self = <test_codegen.TestCodeGen object at 0x7fab86779dc0>
output_name = './TP04/tests/provided/step2/test_if2-all_in_mem.s'
exec_name = './TP04/tests/provided/step2/test_if2.riscv'
info = testinfo(exitcode=0, execcode=0, output='12\n14\n', linkargs=[], skip_test_expected=False)

    def link_and_run(self, output_name, exec_name, info):
        self.remove(exec_name)
        cmd = [
            ASM, output_name, 'TP04/libprint.s',
            '-o', exec_name
        ] + info.linkargs
        print(info)
        print("Assembling and linking " + output_name + ": " + ' '.join(cmd))
        try:
>           subprocess.check_output(cmd, timeout=60, stderr=subprocess.STDOUT)

test_codegen.py:169: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

timeout = 60
popenargs = (['riscv64-unknown-elf-gcc', './TP04/tests/provided/step2/test_if2-all_in_mem.s', 'TP04/libprint.s', '-o', './TP04/tests/provided/step2/test_if2.riscv'],)
kwargs = {'stderr': -2}

    def check_output(*popenargs, timeout=None, **kwargs):
        r"""Run command with arguments and return its output.
    
        If the exit code was non-zero it raises a CalledProcessError.  The
        CalledProcessError object will have the return code in the returncode
        attribute and output in the output attribute.
    
        The arguments are the same as for the Popen constructor.  Example:
    
        >>> check_output(["ls", "-l", "/dev/null"])
        b'crw-rw-rw- 1 root root 1, 3 Oct 18  2007 /dev/null\n'
    
        The stdout argument is not allowed as it is used internally.
        To capture standard error in the result, use stderr=STDOUT.
    
        >>> check_output(["/bin/sh", "-c",
        ...               "ls -l non_existent_file ; exit 0"],
        ...              stderr=STDOUT)
        b'ls: non_existent_file: No such file or directory\n'
    
        There is an additional optional argument, "input", allowing you to
        pass a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it too will be used internally.  Example:
    
        >>> check_output(["sed", "-e", "s/foo/bar/"],
        ...              input=b"when in the course of fooman events\n")
        b'when in the course of barman events\n'
    
        By default, all communication is in bytes, and therefore any "input"
        should be bytes, and the return value will be bytes.  If in text mode,
        any "input" should be a string, and the return value will be a string
        decoded according to locale encoding, or by "encoding" if set. Text mode
        is triggered by setting any of text, encoding, errors or universal_newlines.
        """
        if 'stdout' in kwargs:
            raise ValueError('stdout argument not allowed, it will be overridden.')
    
        if 'input' in kwargs and kwargs['input'] is None:
            # Explicitly passing input=None was previously equivalent to passing an
            # empty string. That is maintained here for backwards compatibility.
            if kwargs.get('universal_newlines') or kwargs.get('text'):
                empty = ''
            else:
                empty = b''
            kwargs['input'] = empty
    
>       return run(*popenargs, stdout=PIPE, timeout=timeout, check=True,
                   **kwargs).stdout

/usr/lib/python3.8/subprocess.py:415: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = False, timeout = 60, check = True
popenargs = (['riscv64-unknown-elf-gcc', './TP04/tests/provided/step2/test_if2-all_in_mem.s', 'TP04/libprint.s', '-o', './TP04/tests/provided/step2/test_if2.riscv'],)
kwargs = {'stderr': -2, 'stdout': -1}
process = <subprocess.Popen object at 0x7fab86779c40>
stdout = b"./TP04/tests/provided/step2/test_if2-all_in_mem.s: Assembler messages:\n./TP04/tests/provided/step2/test_if2-all_in_...7: Error: illegal operands `mv'\n./TP04/tests/provided/step2/test_if2-all_in_mem.s:134: Error: illegal operands `li'\n"
stderr = None, retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout is given, and the process takes too long, a TimeoutExpired
        exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['riscv64-unknown-elf-gcc', './TP04/tests/provided/step2/test_if2-all_in_mem.s', 'TP04/libprint.s', '-o', './TP04/tests/provided/step2/test_if2.riscv']' returned non-zero exit status 1.

/usr/lib/python3.8/subprocess.py:516: CalledProcessError

During handling of the above exception, another exception occurred:

self = <test_codegen.TestCodeGen object at 0x7fab86779dc0>
filename = './TP04/tests/provided/step2/test_if2.c'

    @pytest.mark.parametrize('filename', ALL_IN_MEM_FILES)
    def test_alloc_mem(self, filename):
        expect = self.get_expect(filename)
>       actual = self.all_in_mem(filename, expect)

test_codegen.py:242: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
test_codegen.py:100: in all_in_mem
    return self.compile_and_simulate(file, info, reg_alloc='all_in_mem')
test_codegen.py:216: in compile_and_simulate
    return self.link_and_run(output_name, exec_name, info)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_codegen.TestCodeGen object at 0x7fab86779dc0>
output_name = './TP04/tests/provided/step2/test_if2-all_in_mem.s'
exec_name = './TP04/tests/provided/step2/test_if2.riscv'
info = testinfo(exitcode=0, execcode=0, output='12\n14\n', linkargs=[], skip_test_expected=False)

    def link_and_run(self, output_name, exec_name, info):
        self.remove(exec_name)
        cmd = [
            ASM, output_name, 'TP04/libprint.s',
            '-o', exec_name
        ] + info.linkargs
        print(info)
        print("Assembling and linking " + output_name + ": " + ' '.join(cmd))
        try:
            subprocess.check_output(cmd, timeout=60, stderr=subprocess.STDOUT)
        except subprocess.CalledProcessError as e:
            print("Assembling failed:\n")
            print(e.output.decode())
            print("Assembler code below:\n")
            cat(output_name)
>           pytest.fail()
E           Failed

test_codegen.py:175: Failed
----------------------------- Captured stdout call -----------------------------
Compiling ...
/usr/bin/python3 ./MiniCC.py --reg-alloc=all_in_mem --output=./TP04/tests/provided/step2/test_if2-all_in_mem.s ./TP04/tests/provided/step2/test_if2.c
Exited with status: 0

Compiling ... OK
testinfo(exitcode=0, execcode=0, output='12\n14\n', linkargs=[], skip_test_expected=False)
Assembling and linking ./TP04/tests/provided/step2/test_if2-all_in_mem.s: riscv64-unknown-elf-gcc ./TP04/tests/provided/step2/test_if2-all_in_mem.s TP04/libprint.s -o ./TP04/tests/provided/step2/test_if2.riscv
Assembling failed:

./TP04/tests/provided/step2/test_if2-all_in_mem.s: Assembler messages:
./TP04/tests/provided/step2/test_if2-all_in_mem.s:20: Error: illegal operands `la'
./TP04/tests/provided/step2/test_if2-all_in_mem.s:26: Error: illegal operands `li'
./TP04/tests/provided/step2/test_if2-all_in_mem.s:39: Error: illegal operands `li'
./TP04/tests/provided/step2/test_if2-all_in_mem.s:42: Error: illegal operands `li'
./TP04/tests/provided/step2/test_if2-all_in_mem.s:45: Error: illegal operands `li'
./TP04/tests/provided/step2/test_if2-all_in_mem.s:48: Error: illegal operands `bne'
./TP04/tests/provided/step2/test_if2-all_in_mem.s:51: Error: illegal operands `li'
./TP04/tests/provided/step2/test_if2-all_in_mem.s:55: Error: illegal operands `li'
./TP04/tests/provided/step2/test_if2-all_in_mem.s:58: Error: illegal operands `beq'
./TP04/tests/provided/step2/test_if2-all_in_mem.s:62: Error: illegal operands `li'
./TP04/tests/provided/step2/test_if2-all_in_mem.s:65: Error: illegal operands `mv'
./TP04/tests/provided/step2/test_if2-all_in_mem.s:75: Error: illegal operands `li'
./TP04/tests/provided/step2/test_if2-all_in_mem.s:78: Error: illegal operands `li'
./TP04/tests/provided/step2/test_if2-all_in_mem.s:81: Error: illegal operands `li'
./TP04/tests/provided/step2/test_if2-all_in_mem.s:84: Error: illegal operands `bne'
./TP04/tests/provided/step2/test_if2-all_in_mem.s:87: Error: illegal operands `li'
./TP04/tests/provided/step2/test_if2-all_in_mem.s:91: Error: illegal operands `li'
./TP04/tests/provided/step2/test_if2-all_in_mem.s:94: Error: illegal operands `beq'
./TP04/tests/provided/step2/test_if2-all_in_mem.s:98: Error: illegal operands `li'
./TP04/tests/provided/step2/test_if2-all_in_mem.s:101: Error: illegal operands `mv'
./TP04/tests/provided/step2/test_if2-all_in_mem.s:112: Error: illegal operands `li'
./TP04/tests/provided/step2/test_if2-all_in_mem.s:115: Error: illegal operands `mv'
./TP04/tests/provided/step2/test_if2-all_in_mem.s:124: Error: illegal operands `li'
./TP04/tests/provided/step2/test_if2-all_in_mem.s:127: Error: illegal operands `mv'
./TP04/tests/provided/step2/test_if2-all_in_mem.s:134: Error: illegal operands `li'

Assembler code below:

##Automatically generated RISCV code, MIF08 & CAP
## all-in-memory allocation


##prelude

        .text
        .globl main
main:
        addi sp, sp, -112
        sd ra, 0(sp)
        sd fp, 8(sp)
        addi fp, sp, 112
        j lbl_main_7_main
        

##Generated Code
lbl_div_by_zero_0_main:
        # la a0, lbl_div_by_zero_0_main_msg
        la
        # end la a0, lbl_div_by_zero_0_main_msg
        # call println_string
        call
        # end call println_string
        # li a0, 1
        li
        # end li a0, 1
        # call exit
        call
        # end call exit
        j lbl_div_by_zero_0_main_msg
lbl_div_by_zero_0_main_msg:
        # .string "Division by 0"
        .string
        # end .string "Division by 0"
        j lbl_end_7_main
lbl_main_7_main:
        # (stat (if_stat if ( (expr (expr (atom 10)) == (expr (atom 10))) ) (stat_block { (block (stat (print_stat println_int ( (expr (atom 12)) ) ;))) }) else (stat_block (stat (if_stat if ( (expr (expr (atom 10)) == (expr (atom 10))) ) (stat_block { (block (stat (print_stat println_int ( (expr (atom 15)) ) ;))) }) else (stat_block { (block (stat (print_stat println_int ( (expr (atom 13)) ) ;))) }))))))
        # li temp_1, 10
        li
        # end li temp_1, 10
        # li temp_2, 10
        li
        # end li temp_2, 10
        # li temp_0, 0
        li
        # end li temp_0, 0
        # bne temp_1, temp_2, lbl_endrel_3_main
        bne
        # end bne temp_1, temp_2, lbl_endrel_3_main
        # li temp_0, 1
        li
        # end li temp_0, 1
lbl_endrel_3_main:
        # li temp_3, 0
        li
        # end li temp_3, 0
        # beq temp_0, temp_3, lbl_else_1_main
        beq
        # end beq temp_0, temp_3, lbl_else_1_main
        # (stat (print_stat println_int ( (expr (atom 12)) ) ;))
        # li temp_4, 12
        li
        # end li temp_4, 12
        # mv a0, temp_4
        mv
        # end mv a0, temp_4
        # call println_int
        call
        # end call println_int
        # j lbl_end_if_2_main
        j
        # end j lbl_end_if_2_main
lbl_else_1_main:
        # li temp_6, 10
        li
        # end li temp_6, 10
        # li temp_7, 10
        li
        # end li temp_7, 10
        # li temp_5, 0
        li
        # end li temp_5, 0
        # bne temp_6, temp_7, lbl_endrel_6_main
        bne
        # end bne temp_6, temp_7, lbl_endrel_6_main
        # li temp_5, 1
        li
        # end li temp_5, 1
lbl_endrel_6_main:
        # li temp_8, 0
        li
        # end li temp_8, 0
        # beq temp_5, temp_8, lbl_else_4_main
        beq
        # end beq temp_5, temp_8, lbl_else_4_main
        # (stat (print_stat println_int ( (expr (atom 15)) ) ;))
        # li temp_9, 15
        li
        # end li temp_9, 15
        # mv a0, temp_9
        mv
        # end mv a0, temp_9
        # call println_int
        call
        # end call println_int
        # j lbl_end_if_5_main
        j
        # end j lbl_end_if_5_main
lbl_else_4_main:
        # (stat (print_stat println_int ( (expr (atom 13)) ) ;))
        # li temp_10, 13
        li
        # end li temp_10, 13
        # mv a0, temp_10
        mv
        # end mv a0, temp_10
        # call println_int
        call
        # end call println_int
lbl_end_if_5_main:
lbl_end_if_2_main:
        # (stat (print_stat println_int ( (expr (atom 14)) ) ;))
        # li temp_11, 14
        li
        # end li temp_11, 14
        # mv a0, temp_11
        mv
        # end mv a0, temp_11
        # call println_int
        call
        # end call println_int
        # Return at end of function:
        # li a0, 0
        li
        # end li a0, 0
        j lbl_end_7_main


##postlude

lbl_end_7_main:
        ld ra, 0(sp)
        ld fp, 8(sp)
        addi sp, sp, 112
        ret
        
____ TestCodeGen.test_alloc_mem[./TP04/tests/provided/step2/test_while1.c] _____

self = <test_codegen.TestCodeGen object at 0x7fab86610790>
output_name = './TP04/tests/provided/step2/test_while1-all_in_mem.s'
exec_name = './TP04/tests/provided/step2/test_while1.riscv'
info = testinfo(exitcode=0, execcode=0, output='8\n7\n6\n5\n4\n3\n2\n1\n0\n', linkargs=[], skip_test_expected=False)

    def link_and_run(self, output_name, exec_name, info):
        self.remove(exec_name)
        cmd = [
            ASM, output_name, 'TP04/libprint.s',
            '-o', exec_name
        ] + info.linkargs
        print(info)
        print("Assembling and linking " + output_name + ": " + ' '.join(cmd))
        try:
>           subprocess.check_output(cmd, timeout=60, stderr=subprocess.STDOUT)

test_codegen.py:169: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

timeout = 60
popenargs = (['riscv64-unknown-elf-gcc', './TP04/tests/provided/step2/test_while1-all_in_mem.s', 'TP04/libprint.s', '-o', './TP04/tests/provided/step2/test_while1.riscv'],)
kwargs = {'stderr': -2}

    def check_output(*popenargs, timeout=None, **kwargs):
        r"""Run command with arguments and return its output.
    
        If the exit code was non-zero it raises a CalledProcessError.  The
        CalledProcessError object will have the return code in the returncode
        attribute and output in the output attribute.
    
        The arguments are the same as for the Popen constructor.  Example:
    
        >>> check_output(["ls", "-l", "/dev/null"])
        b'crw-rw-rw- 1 root root 1, 3 Oct 18  2007 /dev/null\n'
    
        The stdout argument is not allowed as it is used internally.
        To capture standard error in the result, use stderr=STDOUT.
    
        >>> check_output(["/bin/sh", "-c",
        ...               "ls -l non_existent_file ; exit 0"],
        ...              stderr=STDOUT)
        b'ls: non_existent_file: No such file or directory\n'
    
        There is an additional optional argument, "input", allowing you to
        pass a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it too will be used internally.  Example:
    
        >>> check_output(["sed", "-e", "s/foo/bar/"],
        ...              input=b"when in the course of fooman events\n")
        b'when in the course of barman events\n'
    
        By default, all communication is in bytes, and therefore any "input"
        should be bytes, and the return value will be bytes.  If in text mode,
        any "input" should be a string, and the return value will be a string
        decoded according to locale encoding, or by "encoding" if set. Text mode
        is triggered by setting any of text, encoding, errors or universal_newlines.
        """
        if 'stdout' in kwargs:
            raise ValueError('stdout argument not allowed, it will be overridden.')
    
        if 'input' in kwargs and kwargs['input'] is None:
            # Explicitly passing input=None was previously equivalent to passing an
            # empty string. That is maintained here for backwards compatibility.
            if kwargs.get('universal_newlines') or kwargs.get('text'):
                empty = ''
            else:
                empty = b''
            kwargs['input'] = empty
    
>       return run(*popenargs, stdout=PIPE, timeout=timeout, check=True,
                   **kwargs).stdout

/usr/lib/python3.8/subprocess.py:415: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = False, timeout = 60, check = True
popenargs = (['riscv64-unknown-elf-gcc', './TP04/tests/provided/step2/test_while1-all_in_mem.s', 'TP04/libprint.s', '-o', './TP04/tests/provided/step2/test_while1.riscv'],)
kwargs = {'stderr': -2, 'stdout': -1}
process = <subprocess.Popen object at 0x7fab86610a60>
stdout = b"./TP04/tests/provided/step2/test_while1-all_in_mem.s: Assembler messages:\n./TP04/tests/provided/step2/test_while1-a... Error: illegal operands `mv'\n./TP04/tests/provided/step2/test_while1-all_in_mem.s:91: Error: illegal operands `li'\n"
stderr = None, retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout is given, and the process takes too long, a TimeoutExpired
        exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['riscv64-unknown-elf-gcc', './TP04/tests/provided/step2/test_while1-all_in_mem.s', 'TP04/libprint.s', '-o', './TP04/tests/provided/step2/test_while1.riscv']' returned non-zero exit status 1.

/usr/lib/python3.8/subprocess.py:516: CalledProcessError

During handling of the above exception, another exception occurred:

self = <test_codegen.TestCodeGen object at 0x7fab86610790>
filename = './TP04/tests/provided/step2/test_while1.c'

    @pytest.mark.parametrize('filename', ALL_IN_MEM_FILES)
    def test_alloc_mem(self, filename):
        expect = self.get_expect(filename)
>       actual = self.all_in_mem(filename, expect)

test_codegen.py:242: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
test_codegen.py:100: in all_in_mem
    return self.compile_and_simulate(file, info, reg_alloc='all_in_mem')
test_codegen.py:216: in compile_and_simulate
    return self.link_and_run(output_name, exec_name, info)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_codegen.TestCodeGen object at 0x7fab86610790>
output_name = './TP04/tests/provided/step2/test_while1-all_in_mem.s'
exec_name = './TP04/tests/provided/step2/test_while1.riscv'
info = testinfo(exitcode=0, execcode=0, output='8\n7\n6\n5\n4\n3\n2\n1\n0\n', linkargs=[], skip_test_expected=False)

    def link_and_run(self, output_name, exec_name, info):
        self.remove(exec_name)
        cmd = [
            ASM, output_name, 'TP04/libprint.s',
            '-o', exec_name
        ] + info.linkargs
        print(info)
        print("Assembling and linking " + output_name + ": " + ' '.join(cmd))
        try:
            subprocess.check_output(cmd, timeout=60, stderr=subprocess.STDOUT)
        except subprocess.CalledProcessError as e:
            print("Assembling failed:\n")
            print(e.output.decode())
            print("Assembler code below:\n")
            cat(output_name)
>           pytest.fail()
E           Failed

test_codegen.py:175: Failed
----------------------------- Captured stdout call -----------------------------
Compiling ...
/usr/bin/python3 ./MiniCC.py --reg-alloc=all_in_mem --output=./TP04/tests/provided/step2/test_while1-all_in_mem.s ./TP04/tests/provided/step2/test_while1.c
Exited with status: 0

Compiling ... OK
testinfo(exitcode=0, execcode=0, output='8\n7\n6\n5\n4\n3\n2\n1\n0\n', linkargs=[], skip_test_expected=False)
Assembling and linking ./TP04/tests/provided/step2/test_while1-all_in_mem.s: riscv64-unknown-elf-gcc ./TP04/tests/provided/step2/test_while1-all_in_mem.s TP04/libprint.s -o ./TP04/tests/provided/step2/test_while1.riscv
Assembling failed:

./TP04/tests/provided/step2/test_while1-all_in_mem.s: Assembler messages:
./TP04/tests/provided/step2/test_while1-all_in_mem.s:20: Error: illegal operands `la'
./TP04/tests/provided/step2/test_while1-all_in_mem.s:26: Error: illegal operands `li'
./TP04/tests/provided/step2/test_while1-all_in_mem.s:38: Error: illegal operands `li'
./TP04/tests/provided/step2/test_while1-all_in_mem.s:42: Error: illegal operands `li'
./TP04/tests/provided/step2/test_while1-all_in_mem.s:45: Error: illegal operands `mv'
./TP04/tests/provided/step2/test_while1-all_in_mem.s:50: Error: illegal operands `li'
./TP04/tests/provided/step2/test_while1-all_in_mem.s:53: Error: illegal operands `li'
./TP04/tests/provided/step2/test_while1-all_in_mem.s:56: Error: illegal operands `ble'
./TP04/tests/provided/step2/test_while1-all_in_mem.s:59: Error: illegal operands `li'
./TP04/tests/provided/step2/test_while1-all_in_mem.s:63: Error: illegal operands `li'
./TP04/tests/provided/step2/test_while1-all_in_mem.s:66: Error: illegal operands `beq'
./TP04/tests/provided/step2/test_while1-all_in_mem.s:70: Error: illegal operands `li'
./TP04/tests/provided/step2/test_while1-all_in_mem.s:73: Error: illegal operands `sub'
./TP04/tests/provided/step2/test_while1-all_in_mem.s:76: Error: illegal operands `mv'
./TP04/tests/provided/step2/test_while1-all_in_mem.s:80: Error: illegal operands `mv'
./TP04/tests/provided/step2/test_while1-all_in_mem.s:91: Error: illegal operands `li'

Assembler code below:

##Automatically generated RISCV code, MIF08 & CAP
## all-in-memory allocation


##prelude

        .text
        .globl main
main:
        addi sp, sp, -80
        sd ra, 0(sp)
        sd fp, 8(sp)
        addi fp, sp, 80
        j lbl_main_4_main
        

##Generated Code
lbl_div_by_zero_0_main:
        # la a0, lbl_div_by_zero_0_main_msg
        la
        # end la a0, lbl_div_by_zero_0_main_msg
        # call println_string
        call
        # end call println_string
        # li a0, 1
        li
        # end li a0, 1
        # call exit
        call
        # end call exit
        j lbl_div_by_zero_0_main_msg
lbl_div_by_zero_0_main_msg:
        # .string "Division by 0"
        .string
        # end .string "Division by 0"
        j lbl_end_4_main
lbl_main_4_main:
        # li temp_0, 0
        li
        # end li temp_0, 0
        # (stat (assignment n = (expr (atom 9))) ;)
        # li temp_1, 9
        li
        # end li temp_1, 9
        # mv temp_0, temp_1
        mv
        # end mv temp_0, temp_1
        # (stat (while_stat while ( (expr (expr (atom n)) > (expr (atom 0))) ) (stat_block { (block (stat (assignment n = (expr (expr (atom n)) - (expr (atom 1)))) ;) (stat (print_stat println_int ( (expr (atom n)) ) ;))) })))
lbl_test_1_main:
        # li temp_3, 0
        li
        # end li temp_3, 0
        # li temp_2, 0
        li
        # end li temp_2, 0
        # ble temp_0, temp_3, lbl_endrel_3_main
        ble
        # end ble temp_0, temp_3, lbl_endrel_3_main
        # li temp_2, 1
        li
        # end li temp_2, 1
lbl_endrel_3_main:
        # li temp_4, 0
        li
        # end li temp_4, 0
        # beq temp_2, temp_4, lbl_endwhile_2_main
        beq
        # end beq temp_2, temp_4, lbl_endwhile_2_main
        # (stat (assignment n = (expr (expr (atom n)) - (expr (atom 1)))) ;)
        # li temp_5, 1
        li
        # end li temp_5, 1
        # sub temp_6, temp_0, temp_5
        sub
        # end sub temp_6, temp_0, temp_5
        # mv temp_0, temp_6
        mv
        # end mv temp_0, temp_6
        # (stat (print_stat println_int ( (expr (atom n)) ) ;))
        # mv a0, temp_0
        mv
        # end mv a0, temp_0
        # call println_int
        call
        # end call println_int
        # j lbl_test_1_main
        j
        # end j lbl_test_1_main
lbl_endwhile_2_main:
        # Return at end of function:
        # li a0, 0
        li
        # end li a0, 0
        j lbl_end_4_main


##postlude

lbl_end_4_main:
        ld ra, 0(sp)
        ld fp, 8(sp)
        addi sp, sp, 80
        ret
        
_________ TestCodeGen.test_alloc_mem[./TP04/tests/students/test_and.c] _________

self = <test_codegen.TestCodeGen object at 0x7fab868c0c70>
output_name = './TP04/tests/students/test_and-all_in_mem.s'
exec_name = './TP04/tests/students/test_and.riscv'
info = testinfo(exitcode=0, execcode=0, output='0\n', linkargs=[], skip_test_expected=False)

    def link_and_run(self, output_name, exec_name, info):
        self.remove(exec_name)
        cmd = [
            ASM, output_name, 'TP04/libprint.s',
            '-o', exec_name
        ] + info.linkargs
        print(info)
        print("Assembling and linking " + output_name + ": " + ' '.join(cmd))
        try:
>           subprocess.check_output(cmd, timeout=60, stderr=subprocess.STDOUT)

test_codegen.py:169: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

timeout = 60
popenargs = (['riscv64-unknown-elf-gcc', './TP04/tests/students/test_and-all_in_mem.s', 'TP04/libprint.s', '-o', './TP04/tests/students/test_and.riscv'],)
kwargs = {'stderr': -2}

    def check_output(*popenargs, timeout=None, **kwargs):
        r"""Run command with arguments and return its output.
    
        If the exit code was non-zero it raises a CalledProcessError.  The
        CalledProcessError object will have the return code in the returncode
        attribute and output in the output attribute.
    
        The arguments are the same as for the Popen constructor.  Example:
    
        >>> check_output(["ls", "-l", "/dev/null"])
        b'crw-rw-rw- 1 root root 1, 3 Oct 18  2007 /dev/null\n'
    
        The stdout argument is not allowed as it is used internally.
        To capture standard error in the result, use stderr=STDOUT.
    
        >>> check_output(["/bin/sh", "-c",
        ...               "ls -l non_existent_file ; exit 0"],
        ...              stderr=STDOUT)
        b'ls: non_existent_file: No such file or directory\n'
    
        There is an additional optional argument, "input", allowing you to
        pass a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it too will be used internally.  Example:
    
        >>> check_output(["sed", "-e", "s/foo/bar/"],
        ...              input=b"when in the course of fooman events\n")
        b'when in the course of barman events\n'
    
        By default, all communication is in bytes, and therefore any "input"
        should be bytes, and the return value will be bytes.  If in text mode,
        any "input" should be a string, and the return value will be a string
        decoded according to locale encoding, or by "encoding" if set. Text mode
        is triggered by setting any of text, encoding, errors or universal_newlines.
        """
        if 'stdout' in kwargs:
            raise ValueError('stdout argument not allowed, it will be overridden.')
    
        if 'input' in kwargs and kwargs['input'] is None:
            # Explicitly passing input=None was previously equivalent to passing an
            # empty string. That is maintained here for backwards compatibility.
            if kwargs.get('universal_newlines') or kwargs.get('text'):
                empty = ''
            else:
                empty = b''
            kwargs['input'] = empty
    
>       return run(*popenargs, stdout=PIPE, timeout=timeout, check=True,
                   **kwargs).stdout

/usr/lib/python3.8/subprocess.py:415: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = False, timeout = 60, check = True
popenargs = (['riscv64-unknown-elf-gcc', './TP04/tests/students/test_and-all_in_mem.s', 'TP04/libprint.s', '-o', './TP04/tests/students/test_and.riscv'],)
kwargs = {'stderr': -2, 'stdout': -1}
process = <subprocess.Popen object at 0x7fab868c04f0>
stdout = b"./TP04/tests/students/test_and-all_in_mem.s: Assembler messages:\n./TP04/tests/students/test_and-all_in_mem.s:20: Er...mem.s:86: Error: illegal operands `mv'\n./TP04/tests/students/test_and-all_in_mem.s:94: Error: illegal operands `li'\n"
stderr = None, retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout is given, and the process takes too long, a TimeoutExpired
        exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['riscv64-unknown-elf-gcc', './TP04/tests/students/test_and-all_in_mem.s', 'TP04/libprint.s', '-o', './TP04/tests/students/test_and.riscv']' returned non-zero exit status 1.

/usr/lib/python3.8/subprocess.py:516: CalledProcessError

During handling of the above exception, another exception occurred:

self = <test_codegen.TestCodeGen object at 0x7fab868c0c70>
filename = './TP04/tests/students/test_and.c'

    @pytest.mark.parametrize('filename', ALL_IN_MEM_FILES)
    def test_alloc_mem(self, filename):
        expect = self.get_expect(filename)
>       actual = self.all_in_mem(filename, expect)

test_codegen.py:242: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
test_codegen.py:100: in all_in_mem
    return self.compile_and_simulate(file, info, reg_alloc='all_in_mem')
test_codegen.py:216: in compile_and_simulate
    return self.link_and_run(output_name, exec_name, info)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_codegen.TestCodeGen object at 0x7fab868c0c70>
output_name = './TP04/tests/students/test_and-all_in_mem.s'
exec_name = './TP04/tests/students/test_and.riscv'
info = testinfo(exitcode=0, execcode=0, output='0\n', linkargs=[], skip_test_expected=False)

    def link_and_run(self, output_name, exec_name, info):
        self.remove(exec_name)
        cmd = [
            ASM, output_name, 'TP04/libprint.s',
            '-o', exec_name
        ] + info.linkargs
        print(info)
        print("Assembling and linking " + output_name + ": " + ' '.join(cmd))
        try:
            subprocess.check_output(cmd, timeout=60, stderr=subprocess.STDOUT)
        except subprocess.CalledProcessError as e:
            print("Assembling failed:\n")
            print(e.output.decode())
            print("Assembler code below:\n")
            cat(output_name)
>           pytest.fail()
E           Failed

test_codegen.py:175: Failed
----------------------------- Captured stdout call -----------------------------
Compiling ...
/usr/bin/python3 ./MiniCC.py --reg-alloc=all_in_mem --output=./TP04/tests/students/test_and-all_in_mem.s ./TP04/tests/students/test_and.c
Exited with status: 0
true
false

Compiling ... OK
testinfo(exitcode=0, execcode=0, output='0\n', linkargs=[], skip_test_expected=False)
Assembling and linking ./TP04/tests/students/test_and-all_in_mem.s: riscv64-unknown-elf-gcc ./TP04/tests/students/test_and-all_in_mem.s TP04/libprint.s -o ./TP04/tests/students/test_and.riscv
Assembling failed:

./TP04/tests/students/test_and-all_in_mem.s: Assembler messages:
./TP04/tests/students/test_and-all_in_mem.s:20: Error: illegal operands `la'
./TP04/tests/students/test_and-all_in_mem.s:26: Error: illegal operands `li'
./TP04/tests/students/test_and-all_in_mem.s:38: Error: illegal operands `li'
./TP04/tests/students/test_and-all_in_mem.s:41: Error: illegal operands `li'
./TP04/tests/students/test_and-all_in_mem.s:45: Error: illegal operands `li'
./TP04/tests/students/test_and-all_in_mem.s:48: Error: illegal operands `mv'
./TP04/tests/students/test_and-all_in_mem.s:52: Error: illegal operands `li'
./TP04/tests/students/test_and-all_in_mem.s:55: Error: illegal operands `mv'
./TP04/tests/students/test_and-all_in_mem.s:59: Error: illegal operands `and'
./TP04/tests/students/test_and-all_in_mem.s:62: Error: illegal operands `li'
./TP04/tests/students/test_and-all_in_mem.s:65: Error: illegal operands `beq'
./TP04/tests/students/test_and-all_in_mem.s:69: Error: illegal operands `li'
./TP04/tests/students/test_and-all_in_mem.s:72: Error: illegal operands `mv'
./TP04/tests/students/test_and-all_in_mem.s:83: Error: illegal operands `li'
./TP04/tests/students/test_and-all_in_mem.s:86: Error: illegal operands `mv'
./TP04/tests/students/test_and-all_in_mem.s:94: Error: illegal operands `li'

Assembler code below:

##Automatically generated RISCV code, MIF08 & CAP
## all-in-memory allocation


##prelude

        .text
        .globl main
main:
        addi sp, sp, -80
        sd ra, 0(sp)
        sd fp, 8(sp)
        addi fp, sp, 80
        j lbl_main_3_main
        

##Generated Code
lbl_div_by_zero_0_main:
        # la a0, lbl_div_by_zero_0_main_msg
        la
        # end la a0, lbl_div_by_zero_0_main_msg
        # call println_string
        call
        # end call println_string
        # li a0, 1
        li
        # end li a0, 1
        # call exit
        call
        # end call exit
        j lbl_div_by_zero_0_main_msg
lbl_div_by_zero_0_main_msg:
        # .string "Division by 0"
        .string
        # end .string "Division by 0"
        j lbl_end_3_main
lbl_main_3_main:
        # li temp_0, 0
        li
        # end li temp_0, 0
        # li temp_1, 0
        li
        # end li temp_1, 0
        # (stat (assignment n = (expr (atom true))) ;)
        # li temp_2, 1
        li
        # end li temp_2, 1
        # mv temp_1, temp_2
        mv
        # end mv temp_1, temp_2
        # (stat (assignment m = (expr (atom false))) ;)
        # li temp_3, 0
        li
        # end li temp_3, 0
        # mv temp_0, temp_3
        mv
        # end mv temp_0, temp_3
        # (stat (if_stat if ( (expr (expr (atom n)) && (expr (atom m))) ) (stat_block { (block (stat (print_stat println_int ( (expr (atom 1)) ) ;))) }) else (stat_block { (block (stat (print_stat println_int ( (expr (atom 0)) ) ;))) })))
        # and temp_4, temp_1, temp_0
        and
        # end and temp_4, temp_1, temp_0
        # li temp_5, 0
        li
        # end li temp_5, 0
        # beq temp_4, temp_5, lbl_else_1_main
        beq
        # end beq temp_4, temp_5, lbl_else_1_main
        # (stat (print_stat println_int ( (expr (atom 1)) ) ;))
        # li temp_6, 1
        li
        # end li temp_6, 1
        # mv a0, temp_6
        mv
        # end mv a0, temp_6
        # call println_int
        call
        # end call println_int
        # j lbl_end_if_2_main
        j
        # end j lbl_end_if_2_main
lbl_else_1_main:
        # (stat (print_stat println_int ( (expr (atom 0)) ) ;))
        # li temp_7, 0
        li
        # end li temp_7, 0
        # mv a0, temp_7
        mv
        # end mv a0, temp_7
        # call println_int
        call
        # end call println_int
lbl_end_if_2_main:
        # Return at end of function:
        # li a0, 0
        li
        # end li a0, 0
        j lbl_end_3_main


##postlude

lbl_end_3_main:
        ld ra, 0(sp)
        ld fp, 8(sp)
        addi sp, sp, 80
        ret
        
_________ TestCodeGen.test_alloc_mem[./TP04/tests/students/test_div.c] _________

self = <test_codegen.TestCodeGen object at 0x7fab865e5c10>
output_name = './TP04/tests/students/test_div-all_in_mem.s'
exec_name = './TP04/tests/students/test_div.riscv'
info = testinfo(exitcode=0, execcode=0, output='2\n', linkargs=[], skip_test_expected=False)

    def link_and_run(self, output_name, exec_name, info):
        self.remove(exec_name)
        cmd = [
            ASM, output_name, 'TP04/libprint.s',
            '-o', exec_name
        ] + info.linkargs
        print(info)
        print("Assembling and linking " + output_name + ": " + ' '.join(cmd))
        try:
>           subprocess.check_output(cmd, timeout=60, stderr=subprocess.STDOUT)

test_codegen.py:169: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

timeout = 60
popenargs = (['riscv64-unknown-elf-gcc', './TP04/tests/students/test_div-all_in_mem.s', 'TP04/libprint.s', '-o', './TP04/tests/students/test_div.riscv'],)
kwargs = {'stderr': -2}

    def check_output(*popenargs, timeout=None, **kwargs):
        r"""Run command with arguments and return its output.
    
        If the exit code was non-zero it raises a CalledProcessError.  The
        CalledProcessError object will have the return code in the returncode
        attribute and output in the output attribute.
    
        The arguments are the same as for the Popen constructor.  Example:
    
        >>> check_output(["ls", "-l", "/dev/null"])
        b'crw-rw-rw- 1 root root 1, 3 Oct 18  2007 /dev/null\n'
    
        The stdout argument is not allowed as it is used internally.
        To capture standard error in the result, use stderr=STDOUT.
    
        >>> check_output(["/bin/sh", "-c",
        ...               "ls -l non_existent_file ; exit 0"],
        ...              stderr=STDOUT)
        b'ls: non_existent_file: No such file or directory\n'
    
        There is an additional optional argument, "input", allowing you to
        pass a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it too will be used internally.  Example:
    
        >>> check_output(["sed", "-e", "s/foo/bar/"],
        ...              input=b"when in the course of fooman events\n")
        b'when in the course of barman events\n'
    
        By default, all communication is in bytes, and therefore any "input"
        should be bytes, and the return value will be bytes.  If in text mode,
        any "input" should be a string, and the return value will be a string
        decoded according to locale encoding, or by "encoding" if set. Text mode
        is triggered by setting any of text, encoding, errors or universal_newlines.
        """
        if 'stdout' in kwargs:
            raise ValueError('stdout argument not allowed, it will be overridden.')
    
        if 'input' in kwargs and kwargs['input'] is None:
            # Explicitly passing input=None was previously equivalent to passing an
            # empty string. That is maintained here for backwards compatibility.
            if kwargs.get('universal_newlines') or kwargs.get('text'):
                empty = ''
            else:
                empty = b''
            kwargs['input'] = empty
    
>       return run(*popenargs, stdout=PIPE, timeout=timeout, check=True,
                   **kwargs).stdout

/usr/lib/python3.8/subprocess.py:415: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = False, timeout = 60, check = True
popenargs = (['riscv64-unknown-elf-gcc', './TP04/tests/students/test_div-all_in_mem.s', 'TP04/libprint.s', '-o', './TP04/tests/students/test_div.riscv'],)
kwargs = {'stderr': -2, 'stdout': -1}
process = <subprocess.Popen object at 0x7fab865e5c70>
stdout = b"./TP04/tests/students/test_div-all_in_mem.s: Assembler messages:\n./TP04/tests/students/test_div-all_in_mem.s:20: Er...mem.s:48: Error: illegal operands `mv'\n./TP04/tests/students/test_div-all_in_mem.s:55: Error: illegal operands `li'\n"
stderr = None, retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout is given, and the process takes too long, a TimeoutExpired
        exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['riscv64-unknown-elf-gcc', './TP04/tests/students/test_div-all_in_mem.s', 'TP04/libprint.s', '-o', './TP04/tests/students/test_div.riscv']' returned non-zero exit status 1.

/usr/lib/python3.8/subprocess.py:516: CalledProcessError

During handling of the above exception, another exception occurred:

self = <test_codegen.TestCodeGen object at 0x7fab865e5c10>
filename = './TP04/tests/students/test_div.c'

    @pytest.mark.parametrize('filename', ALL_IN_MEM_FILES)
    def test_alloc_mem(self, filename):
        expect = self.get_expect(filename)
>       actual = self.all_in_mem(filename, expect)

test_codegen.py:242: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
test_codegen.py:100: in all_in_mem
    return self.compile_and_simulate(file, info, reg_alloc='all_in_mem')
test_codegen.py:216: in compile_and_simulate
    return self.link_and_run(output_name, exec_name, info)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_codegen.TestCodeGen object at 0x7fab865e5c10>
output_name = './TP04/tests/students/test_div-all_in_mem.s'
exec_name = './TP04/tests/students/test_div.riscv'
info = testinfo(exitcode=0, execcode=0, output='2\n', linkargs=[], skip_test_expected=False)

    def link_and_run(self, output_name, exec_name, info):
        self.remove(exec_name)
        cmd = [
            ASM, output_name, 'TP04/libprint.s',
            '-o', exec_name
        ] + info.linkargs
        print(info)
        print("Assembling and linking " + output_name + ": " + ' '.join(cmd))
        try:
            subprocess.check_output(cmd, timeout=60, stderr=subprocess.STDOUT)
        except subprocess.CalledProcessError as e:
            print("Assembling failed:\n")
            print(e.output.decode())
            print("Assembler code below:\n")
            cat(output_name)
>           pytest.fail()
E           Failed

test_codegen.py:175: Failed
----------------------------- Captured stdout call -----------------------------
Compiling ...
/usr/bin/python3 ./MiniCC.py --reg-alloc=all_in_mem --output=./TP04/tests/students/test_div-all_in_mem.s ./TP04/tests/students/test_div.c
Exited with status: 0

Compiling ... OK
testinfo(exitcode=0, execcode=0, output='2\n', linkargs=[], skip_test_expected=False)
Assembling and linking ./TP04/tests/students/test_div-all_in_mem.s: riscv64-unknown-elf-gcc ./TP04/tests/students/test_div-all_in_mem.s TP04/libprint.s -o ./TP04/tests/students/test_div.riscv
Assembling failed:

./TP04/tests/students/test_div-all_in_mem.s: Assembler messages:
./TP04/tests/students/test_div-all_in_mem.s:20: Error: illegal operands `la'
./TP04/tests/students/test_div-all_in_mem.s:26: Error: illegal operands `li'
./TP04/tests/students/test_div-all_in_mem.s:39: Error: illegal operands `li'
./TP04/tests/students/test_div-all_in_mem.s:42: Error: illegal operands `li'
./TP04/tests/students/test_div-all_in_mem.s:45: Error: illegal operands `div'
./TP04/tests/students/test_div-all_in_mem.s:48: Error: illegal operands `mv'
./TP04/tests/students/test_div-all_in_mem.s:55: Error: illegal operands `li'

Assembler code below:

##Automatically generated RISCV code, MIF08 & CAP
## all-in-memory allocation


##prelude

        .text
        .globl main
main:
        addi sp, sp, -48
        sd ra, 0(sp)
        sd fp, 8(sp)
        addi fp, sp, 48
        j lbl_main_1_main
        

##Generated Code
lbl_div_by_zero_0_main:
        # la a0, lbl_div_by_zero_0_main_msg
        la
        # end la a0, lbl_div_by_zero_0_main_msg
        # call println_string
        call
        # end call println_string
        # li a0, 1
        li
        # end li a0, 1
        # call exit
        call
        # end call exit
        j lbl_div_by_zero_0_main_msg
lbl_div_by_zero_0_main_msg:
        # .string "Division by 0"
        .string
        # end .string "Division by 0"
        j lbl_end_1_main
lbl_main_1_main:
        # (stat (print_stat println_int ( (expr (expr (atom 4)) / (expr (atom 2))) ) ;))
        # li temp_0, 4
        li
        # end li temp_0, 4
        # li temp_1, 2
        li
        # end li temp_1, 2
        # div temp_2, temp_0, temp_1
        div
        # end div temp_2, temp_0, temp_1
        # mv a0, temp_2
        mv
        # end mv a0, temp_2
        # call println_int
        call
        # end call println_int
        # Return at end of function:
        # li a0, 0
        li
        # end li a0, 0
        j lbl_end_1_main


##postlude

lbl_end_1_main:
        ld ra, 0(sp)
        ld fp, 8(sp)
        addi sp, sp, 48
        ret
        
______ TestCodeGen.test_alloc_mem[./TP04/tests/students/test_div_zero.c] _______

self = <test_codegen.TestCodeGen object at 0x7fab867ba460>
output_name = './TP04/tests/students/test_div_zero-all_in_mem.s'
exec_name = './TP04/tests/students/test_div_zero.riscv'
info = testinfo(exitcode=0, execcode=1, output='Division by 0\n', linkargs=[], skip_test_expected=True)

    def link_and_run(self, output_name, exec_name, info):
        self.remove(exec_name)
        cmd = [
            ASM, output_name, 'TP04/libprint.s',
            '-o', exec_name
        ] + info.linkargs
        print(info)
        print("Assembling and linking " + output_name + ": " + ' '.join(cmd))
        try:
>           subprocess.check_output(cmd, timeout=60, stderr=subprocess.STDOUT)

test_codegen.py:169: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

timeout = 60
popenargs = (['riscv64-unknown-elf-gcc', './TP04/tests/students/test_div_zero-all_in_mem.s', 'TP04/libprint.s', '-o', './TP04/tests/students/test_div_zero.riscv'],)
kwargs = {'stderr': -2}

    def check_output(*popenargs, timeout=None, **kwargs):
        r"""Run command with arguments and return its output.
    
        If the exit code was non-zero it raises a CalledProcessError.  The
        CalledProcessError object will have the return code in the returncode
        attribute and output in the output attribute.
    
        The arguments are the same as for the Popen constructor.  Example:
    
        >>> check_output(["ls", "-l", "/dev/null"])
        b'crw-rw-rw- 1 root root 1, 3 Oct 18  2007 /dev/null\n'
    
        The stdout argument is not allowed as it is used internally.
        To capture standard error in the result, use stderr=STDOUT.
    
        >>> check_output(["/bin/sh", "-c",
        ...               "ls -l non_existent_file ; exit 0"],
        ...              stderr=STDOUT)
        b'ls: non_existent_file: No such file or directory\n'
    
        There is an additional optional argument, "input", allowing you to
        pass a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it too will be used internally.  Example:
    
        >>> check_output(["sed", "-e", "s/foo/bar/"],
        ...              input=b"when in the course of fooman events\n")
        b'when in the course of barman events\n'
    
        By default, all communication is in bytes, and therefore any "input"
        should be bytes, and the return value will be bytes.  If in text mode,
        any "input" should be a string, and the return value will be a string
        decoded according to locale encoding, or by "encoding" if set. Text mode
        is triggered by setting any of text, encoding, errors or universal_newlines.
        """
        if 'stdout' in kwargs:
            raise ValueError('stdout argument not allowed, it will be overridden.')
    
        if 'input' in kwargs and kwargs['input'] is None:
            # Explicitly passing input=None was previously equivalent to passing an
            # empty string. That is maintained here for backwards compatibility.
            if kwargs.get('universal_newlines') or kwargs.get('text'):
                empty = ''
            else:
                empty = b''
            kwargs['input'] = empty
    
>       return run(*popenargs, stdout=PIPE, timeout=timeout, check=True,
                   **kwargs).stdout

/usr/lib/python3.8/subprocess.py:415: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = False, timeout = 60, check = True
popenargs = (['riscv64-unknown-elf-gcc', './TP04/tests/students/test_div_zero-all_in_mem.s', 'TP04/libprint.s', '-o', './TP04/tests/students/test_div_zero.riscv'],)
kwargs = {'stderr': -2, 'stdout': -1}
process = <subprocess.Popen object at 0x7fab867ba280>
stdout = b"./TP04/tests/students/test_div_zero-all_in_mem.s: Assembler messages:\n./TP04/tests/students/test_div_zero-all_in_me...:51: Error: illegal operands `mv'\n./TP04/tests/students/test_div_zero-all_in_mem.s:58: Error: illegal operands `li'\n"
stderr = None, retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout is given, and the process takes too long, a TimeoutExpired
        exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['riscv64-unknown-elf-gcc', './TP04/tests/students/test_div_zero-all_in_mem.s', 'TP04/libprint.s', '-o', './TP04/tests/students/test_div_zero.riscv']' returned non-zero exit status 1.

/usr/lib/python3.8/subprocess.py:516: CalledProcessError

During handling of the above exception, another exception occurred:

self = <test_codegen.TestCodeGen object at 0x7fab867ba460>
filename = './TP04/tests/students/test_div_zero.c'

    @pytest.mark.parametrize('filename', ALL_IN_MEM_FILES)
    def test_alloc_mem(self, filename):
        expect = self.get_expect(filename)
>       actual = self.all_in_mem(filename, expect)

test_codegen.py:242: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
test_codegen.py:100: in all_in_mem
    return self.compile_and_simulate(file, info, reg_alloc='all_in_mem')
test_codegen.py:216: in compile_and_simulate
    return self.link_and_run(output_name, exec_name, info)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_codegen.TestCodeGen object at 0x7fab867ba460>
output_name = './TP04/tests/students/test_div_zero-all_in_mem.s'
exec_name = './TP04/tests/students/test_div_zero.riscv'
info = testinfo(exitcode=0, execcode=1, output='Division by 0\n', linkargs=[], skip_test_expected=True)

    def link_and_run(self, output_name, exec_name, info):
        self.remove(exec_name)
        cmd = [
            ASM, output_name, 'TP04/libprint.s',
            '-o', exec_name
        ] + info.linkargs
        print(info)
        print("Assembling and linking " + output_name + ": " + ' '.join(cmd))
        try:
            subprocess.check_output(cmd, timeout=60, stderr=subprocess.STDOUT)
        except subprocess.CalledProcessError as e:
            print("Assembling failed:\n")
            print(e.output.decode())
            print("Assembler code below:\n")
            cat(output_name)
>           pytest.fail()
E           Failed

test_codegen.py:175: Failed
----------------------------- Captured stdout call -----------------------------
Compiling ...
/usr/bin/python3 ./MiniCC.py --reg-alloc=all_in_mem --output=./TP04/tests/students/test_div_zero-all_in_mem.s ./TP04/tests/students/test_div_zero.c
Exited with status: 0

Compiling ... OK
testinfo(exitcode=0, execcode=1, output='Division by 0\n', linkargs=[], skip_test_expected=True)
Assembling and linking ./TP04/tests/students/test_div_zero-all_in_mem.s: riscv64-unknown-elf-gcc ./TP04/tests/students/test_div_zero-all_in_mem.s TP04/libprint.s -o ./TP04/tests/students/test_div_zero.riscv
Assembling failed:

./TP04/tests/students/test_div_zero-all_in_mem.s: Assembler messages:
./TP04/tests/students/test_div_zero-all_in_mem.s:20: Error: illegal operands `la'
./TP04/tests/students/test_div_zero-all_in_mem.s:26: Error: illegal operands `li'
./TP04/tests/students/test_div_zero-all_in_mem.s:39: Error: illegal operands `li'
./TP04/tests/students/test_div_zero-all_in_mem.s:42: Error: illegal operands `li'
./TP04/tests/students/test_div_zero-all_in_mem.s:48: Error: illegal operands `div'
./TP04/tests/students/test_div_zero-all_in_mem.s:51: Error: illegal operands `mv'
./TP04/tests/students/test_div_zero-all_in_mem.s:58: Error: illegal operands `li'

Assembler code below:

##Automatically generated RISCV code, MIF08 & CAP
## all-in-memory allocation


##prelude

        .text
        .globl main
main:
        addi sp, sp, -48
        sd ra, 0(sp)
        sd fp, 8(sp)
        addi fp, sp, 48
        j lbl_main_1_main
        

##Generated Code
lbl_div_by_zero_0_main:
        # la a0, lbl_div_by_zero_0_main_msg
        la
        # end la a0, lbl_div_by_zero_0_main_msg
        # call println_string
        call
        # end call println_string
        # li a0, 1
        li
        # end li a0, 1
        # call exit
        call
        # end call exit
        j lbl_div_by_zero_0_main_msg
lbl_div_by_zero_0_main_msg:
        # .string "Division by 0"
        .string
        # end .string "Division by 0"
        j lbl_end_1_main
lbl_main_1_main:
        # (stat (print_stat println_int ( (expr (expr (atom 1)) / (expr (atom 0))) ) ;))
        # li temp_0, 1
        li
        # end li temp_0, 1
        # li temp_1, 0
        li
        # end li temp_1, 0
        # j lbl_div_by_zero_0_main
        j
        # end j lbl_div_by_zero_0_main
        # div temp_2, temp_0, temp_1
        div
        # end div temp_2, temp_0, temp_1
        # mv a0, temp_2
        mv
        # end mv a0, temp_2
        # call println_int
        call
        # end call println_int
        # Return at end of function:
        # li a0, 0
        li
        # end li a0, 0
        j lbl_end_1_main


##postlude

lbl_end_1_main:
        ld ra, 0(sp)
        ld fp, 8(sp)
        addi sp, sp, 48
        ret
        
______ TestCodeGen.test_alloc_mem[./TP04/tests/students/test_equality.c] _______

self = <test_codegen.TestCodeGen object at 0x7fab869b9b20>
output_name = './TP04/tests/students/test_equality-all_in_mem.s'
exec_name = './TP04/tests/students/test_equality.riscv'
info = testinfo(exitcode=0, execcode=0, output='1\n', linkargs=[], skip_test_expected=False)

    def link_and_run(self, output_name, exec_name, info):
        self.remove(exec_name)
        cmd = [
            ASM, output_name, 'TP04/libprint.s',
            '-o', exec_name
        ] + info.linkargs
        print(info)
        print("Assembling and linking " + output_name + ": " + ' '.join(cmd))
        try:
>           subprocess.check_output(cmd, timeout=60, stderr=subprocess.STDOUT)

test_codegen.py:169: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

timeout = 60
popenargs = (['riscv64-unknown-elf-gcc', './TP04/tests/students/test_equality-all_in_mem.s', 'TP04/libprint.s', '-o', './TP04/tests/students/test_equality.riscv'],)
kwargs = {'stderr': -2}

    def check_output(*popenargs, timeout=None, **kwargs):
        r"""Run command with arguments and return its output.
    
        If the exit code was non-zero it raises a CalledProcessError.  The
        CalledProcessError object will have the return code in the returncode
        attribute and output in the output attribute.
    
        The arguments are the same as for the Popen constructor.  Example:
    
        >>> check_output(["ls", "-l", "/dev/null"])
        b'crw-rw-rw- 1 root root 1, 3 Oct 18  2007 /dev/null\n'
    
        The stdout argument is not allowed as it is used internally.
        To capture standard error in the result, use stderr=STDOUT.
    
        >>> check_output(["/bin/sh", "-c",
        ...               "ls -l non_existent_file ; exit 0"],
        ...              stderr=STDOUT)
        b'ls: non_existent_file: No such file or directory\n'
    
        There is an additional optional argument, "input", allowing you to
        pass a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it too will be used internally.  Example:
    
        >>> check_output(["sed", "-e", "s/foo/bar/"],
        ...              input=b"when in the course of fooman events\n")
        b'when in the course of barman events\n'
    
        By default, all communication is in bytes, and therefore any "input"
        should be bytes, and the return value will be bytes.  If in text mode,
        any "input" should be a string, and the return value will be a string
        decoded according to locale encoding, or by "encoding" if set. Text mode
        is triggered by setting any of text, encoding, errors or universal_newlines.
        """
        if 'stdout' in kwargs:
            raise ValueError('stdout argument not allowed, it will be overridden.')
    
        if 'input' in kwargs and kwargs['input'] is None:
            # Explicitly passing input=None was previously equivalent to passing an
            # empty string. That is maintained here for backwards compatibility.
            if kwargs.get('universal_newlines') or kwargs.get('text'):
                empty = ''
            else:
                empty = b''
            kwargs['input'] = empty
    
>       return run(*popenargs, stdout=PIPE, timeout=timeout, check=True,
                   **kwargs).stdout

/usr/lib/python3.8/subprocess.py:415: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = False, timeout = 60, check = True
popenargs = (['riscv64-unknown-elf-gcc', './TP04/tests/students/test_equality-all_in_mem.s', 'TP04/libprint.s', '-o', './TP04/tests/students/test_equality.riscv'],)
kwargs = {'stderr': -2, 'stdout': -1}
process = <subprocess.Popen object at 0x7fab869b97c0>
stdout = b"./TP04/tests/students/test_equality-all_in_mem.s: Assembler messages:\n./TP04/tests/students/test_equality-all_in_me...:79: Error: illegal operands `mv'\n./TP04/tests/students/test_equality-all_in_mem.s:87: Error: illegal operands `li'\n"
stderr = None, retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout is given, and the process takes too long, a TimeoutExpired
        exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['riscv64-unknown-elf-gcc', './TP04/tests/students/test_equality-all_in_mem.s', 'TP04/libprint.s', '-o', './TP04/tests/students/test_equality.riscv']' returned non-zero exit status 1.

/usr/lib/python3.8/subprocess.py:516: CalledProcessError

During handling of the above exception, another exception occurred:

self = <test_codegen.TestCodeGen object at 0x7fab869b9b20>
filename = './TP04/tests/students/test_equality.c'

    @pytest.mark.parametrize('filename', ALL_IN_MEM_FILES)
    def test_alloc_mem(self, filename):
        expect = self.get_expect(filename)
>       actual = self.all_in_mem(filename, expect)

test_codegen.py:242: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
test_codegen.py:100: in all_in_mem
    return self.compile_and_simulate(file, info, reg_alloc='all_in_mem')
test_codegen.py:216: in compile_and_simulate
    return self.link_and_run(output_name, exec_name, info)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_codegen.TestCodeGen object at 0x7fab869b9b20>
output_name = './TP04/tests/students/test_equality-all_in_mem.s'
exec_name = './TP04/tests/students/test_equality.riscv'
info = testinfo(exitcode=0, execcode=0, output='1\n', linkargs=[], skip_test_expected=False)

    def link_and_run(self, output_name, exec_name, info):
        self.remove(exec_name)
        cmd = [
            ASM, output_name, 'TP04/libprint.s',
            '-o', exec_name
        ] + info.linkargs
        print(info)
        print("Assembling and linking " + output_name + ": " + ' '.join(cmd))
        try:
            subprocess.check_output(cmd, timeout=60, stderr=subprocess.STDOUT)
        except subprocess.CalledProcessError as e:
            print("Assembling failed:\n")
            print(e.output.decode())
            print("Assembler code below:\n")
            cat(output_name)
>           pytest.fail()
E           Failed

test_codegen.py:175: Failed
----------------------------- Captured stdout call -----------------------------
Compiling ...
/usr/bin/python3 ./MiniCC.py --reg-alloc=all_in_mem --output=./TP04/tests/students/test_equality-all_in_mem.s ./TP04/tests/students/test_equality.c
Exited with status: 0

Compiling ... OK
testinfo(exitcode=0, execcode=0, output='1\n', linkargs=[], skip_test_expected=False)
Assembling and linking ./TP04/tests/students/test_equality-all_in_mem.s: riscv64-unknown-elf-gcc ./TP04/tests/students/test_equality-all_in_mem.s TP04/libprint.s -o ./TP04/tests/students/test_equality.riscv
Assembling failed:

./TP04/tests/students/test_equality-all_in_mem.s: Assembler messages:
./TP04/tests/students/test_equality-all_in_mem.s:20: Error: illegal operands `la'
./TP04/tests/students/test_equality-all_in_mem.s:26: Error: illegal operands `li'
./TP04/tests/students/test_equality-all_in_mem.s:39: Error: illegal operands `li'
./TP04/tests/students/test_equality-all_in_mem.s:42: Error: illegal operands `li'
./TP04/tests/students/test_equality-all_in_mem.s:45: Error: illegal operands `li'
./TP04/tests/students/test_equality-all_in_mem.s:48: Error: illegal operands `bne'
./TP04/tests/students/test_equality-all_in_mem.s:51: Error: illegal operands `li'
./TP04/tests/students/test_equality-all_in_mem.s:55: Error: illegal operands `li'
./TP04/tests/students/test_equality-all_in_mem.s:58: Error: illegal operands `beq'
./TP04/tests/students/test_equality-all_in_mem.s:62: Error: illegal operands `li'
./TP04/tests/students/test_equality-all_in_mem.s:65: Error: illegal operands `mv'
./TP04/tests/students/test_equality-all_in_mem.s:76: Error: illegal operands `li'
./TP04/tests/students/test_equality-all_in_mem.s:79: Error: illegal operands `mv'
./TP04/tests/students/test_equality-all_in_mem.s:87: Error: illegal operands `li'

Assembler code below:

##Automatically generated RISCV code, MIF08 & CAP
## all-in-memory allocation


##prelude

        .text
        .globl main
main:
        addi sp, sp, -64
        sd ra, 0(sp)
        sd fp, 8(sp)
        addi fp, sp, 64
        j lbl_main_4_main
        

##Generated Code
lbl_div_by_zero_0_main:
        # la a0, lbl_div_by_zero_0_main_msg
        la
        # end la a0, lbl_div_by_zero_0_main_msg
        # call println_string
        call
        # end call println_string
        # li a0, 1
        li
        # end li a0, 1
        # call exit
        call
        # end call exit
        j lbl_div_by_zero_0_main_msg
lbl_div_by_zero_0_main_msg:
        # .string "Division by 0"
        .string
        # end .string "Division by 0"
        j lbl_end_4_main
lbl_main_4_main:
        # (stat (if_stat if ( (expr (expr (atom 4)) == (expr (atom 4))) ) (stat_block { (block (stat (print_stat println_int ( (expr (atom 1)) ) ;))) }) else (stat_block { (block (stat (print_stat println_int ( (expr (atom 0)) ) ;))) })))
        # li temp_1, 4
        li
        # end li temp_1, 4
        # li temp_2, 4
        li
        # end li temp_2, 4
        # li temp_0, 0
        li
        # end li temp_0, 0
        # bne temp_1, temp_2, lbl_endrel_3_main
        bne
        # end bne temp_1, temp_2, lbl_endrel_3_main
        # li temp_0, 1
        li
        # end li temp_0, 1
lbl_endrel_3_main:
        # li temp_3, 0
        li
        # end li temp_3, 0
        # beq temp_0, temp_3, lbl_else_1_main
        beq
        # end beq temp_0, temp_3, lbl_else_1_main
        # (stat (print_stat println_int ( (expr (atom 1)) ) ;))
        # li temp_4, 1
        li
        # end li temp_4, 1
        # mv a0, temp_4
        mv
        # end mv a0, temp_4
        # call println_int
        call
        # end call println_int
        # j lbl_end_if_2_main
        j
        # end j lbl_end_if_2_main
lbl_else_1_main:
        # (stat (print_stat println_int ( (expr (atom 0)) ) ;))
        # li temp_5, 0
        li
        # end li temp_5, 0
        # mv a0, temp_5
        mv
        # end mv a0, temp_5
        # call println_int
        call
        # end call println_int
lbl_end_if_2_main:
        # Return at end of function:
        # li a0, 0
        li
        # end li a0, 0
        j lbl_end_4_main


##postlude

lbl_end_4_main:
        ld ra, 0(sp)
        ld fp, 8(sp)
        addi sp, sp, 64
        ret
        
________ TestCodeGen.test_alloc_mem[./TP04/tests/students/test_minus.c] ________

self = <test_codegen.TestCodeGen object at 0x7fab867cb580>
output_name = './TP04/tests/students/test_minus-all_in_mem.s'
exec_name = './TP04/tests/students/test_minus.riscv'
info = testinfo(exitcode=0, execcode=0, output='5\n', linkargs=[], skip_test_expected=False)

    def link_and_run(self, output_name, exec_name, info):
        self.remove(exec_name)
        cmd = [
            ASM, output_name, 'TP04/libprint.s',
            '-o', exec_name
        ] + info.linkargs
        print(info)
        print("Assembling and linking " + output_name + ": " + ' '.join(cmd))
        try:
>           subprocess.check_output(cmd, timeout=60, stderr=subprocess.STDOUT)

test_codegen.py:169: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

timeout = 60
popenargs = (['riscv64-unknown-elf-gcc', './TP04/tests/students/test_minus-all_in_mem.s', 'TP04/libprint.s', '-o', './TP04/tests/students/test_minus.riscv'],)
kwargs = {'stderr': -2}

    def check_output(*popenargs, timeout=None, **kwargs):
        r"""Run command with arguments and return its output.
    
        If the exit code was non-zero it raises a CalledProcessError.  The
        CalledProcessError object will have the return code in the returncode
        attribute and output in the output attribute.
    
        The arguments are the same as for the Popen constructor.  Example:
    
        >>> check_output(["ls", "-l", "/dev/null"])
        b'crw-rw-rw- 1 root root 1, 3 Oct 18  2007 /dev/null\n'
    
        The stdout argument is not allowed as it is used internally.
        To capture standard error in the result, use stderr=STDOUT.
    
        >>> check_output(["/bin/sh", "-c",
        ...               "ls -l non_existent_file ; exit 0"],
        ...              stderr=STDOUT)
        b'ls: non_existent_file: No such file or directory\n'
    
        There is an additional optional argument, "input", allowing you to
        pass a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it too will be used internally.  Example:
    
        >>> check_output(["sed", "-e", "s/foo/bar/"],
        ...              input=b"when in the course of fooman events\n")
        b'when in the course of barman events\n'
    
        By default, all communication is in bytes, and therefore any "input"
        should be bytes, and the return value will be bytes.  If in text mode,
        any "input" should be a string, and the return value will be a string
        decoded according to locale encoding, or by "encoding" if set. Text mode
        is triggered by setting any of text, encoding, errors or universal_newlines.
        """
        if 'stdout' in kwargs:
            raise ValueError('stdout argument not allowed, it will be overridden.')
    
        if 'input' in kwargs and kwargs['input'] is None:
            # Explicitly passing input=None was previously equivalent to passing an
            # empty string. That is maintained here for backwards compatibility.
            if kwargs.get('universal_newlines') or kwargs.get('text'):
                empty = ''
            else:
                empty = b''
            kwargs['input'] = empty
    
>       return run(*popenargs, stdout=PIPE, timeout=timeout, check=True,
                   **kwargs).stdout

/usr/lib/python3.8/subprocess.py:415: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = False, timeout = 60, check = True
popenargs = (['riscv64-unknown-elf-gcc', './TP04/tests/students/test_minus-all_in_mem.s', 'TP04/libprint.s', '-o', './TP04/tests/students/test_minus.riscv'],)
kwargs = {'stderr': -2, 'stdout': -1}
process = <subprocess.Popen object at 0x7fab867cbfa0>
stdout = b"./TP04/tests/students/test_minus-all_in_mem.s: Assembler messages:\n./TP04/tests/students/test_minus-all_in_mem.s:20...m.s:48: Error: illegal operands `mv'\n./TP04/tests/students/test_minus-all_in_mem.s:55: Error: illegal operands `li'\n"
stderr = None, retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout is given, and the process takes too long, a TimeoutExpired
        exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['riscv64-unknown-elf-gcc', './TP04/tests/students/test_minus-all_in_mem.s', 'TP04/libprint.s', '-o', './TP04/tests/students/test_minus.riscv']' returned non-zero exit status 1.

/usr/lib/python3.8/subprocess.py:516: CalledProcessError

During handling of the above exception, another exception occurred:

self = <test_codegen.TestCodeGen object at 0x7fab867cb580>
filename = './TP04/tests/students/test_minus.c'

    @pytest.mark.parametrize('filename', ALL_IN_MEM_FILES)
    def test_alloc_mem(self, filename):
        expect = self.get_expect(filename)
>       actual = self.all_in_mem(filename, expect)

test_codegen.py:242: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
test_codegen.py:100: in all_in_mem
    return self.compile_and_simulate(file, info, reg_alloc='all_in_mem')
test_codegen.py:216: in compile_and_simulate
    return self.link_and_run(output_name, exec_name, info)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_codegen.TestCodeGen object at 0x7fab867cb580>
output_name = './TP04/tests/students/test_minus-all_in_mem.s'
exec_name = './TP04/tests/students/test_minus.riscv'
info = testinfo(exitcode=0, execcode=0, output='5\n', linkargs=[], skip_test_expected=False)

    def link_and_run(self, output_name, exec_name, info):
        self.remove(exec_name)
        cmd = [
            ASM, output_name, 'TP04/libprint.s',
            '-o', exec_name
        ] + info.linkargs
        print(info)
        print("Assembling and linking " + output_name + ": " + ' '.join(cmd))
        try:
            subprocess.check_output(cmd, timeout=60, stderr=subprocess.STDOUT)
        except subprocess.CalledProcessError as e:
            print("Assembling failed:\n")
            print(e.output.decode())
            print("Assembler code below:\n")
            cat(output_name)
>           pytest.fail()
E           Failed

test_codegen.py:175: Failed
----------------------------- Captured stdout call -----------------------------
Compiling ...
/usr/bin/python3 ./MiniCC.py --reg-alloc=all_in_mem --output=./TP04/tests/students/test_minus-all_in_mem.s ./TP04/tests/students/test_minus.c
Exited with status: 0

Compiling ... OK
testinfo(exitcode=0, execcode=0, output='5\n', linkargs=[], skip_test_expected=False)
Assembling and linking ./TP04/tests/students/test_minus-all_in_mem.s: riscv64-unknown-elf-gcc ./TP04/tests/students/test_minus-all_in_mem.s TP04/libprint.s -o ./TP04/tests/students/test_minus.riscv
Assembling failed:

./TP04/tests/students/test_minus-all_in_mem.s: Assembler messages:
./TP04/tests/students/test_minus-all_in_mem.s:20: Error: illegal operands `la'
./TP04/tests/students/test_minus-all_in_mem.s:26: Error: illegal operands `li'
./TP04/tests/students/test_minus-all_in_mem.s:39: Error: illegal operands `li'
./TP04/tests/students/test_minus-all_in_mem.s:42: Error: illegal operands `li'
./TP04/tests/students/test_minus-all_in_mem.s:45: Error: illegal operands `sub'
./TP04/tests/students/test_minus-all_in_mem.s:48: Error: illegal operands `mv'
./TP04/tests/students/test_minus-all_in_mem.s:55: Error: illegal operands `li'

Assembler code below:

##Automatically generated RISCV code, MIF08 & CAP
## all-in-memory allocation


##prelude

        .text
        .globl main
main:
        addi sp, sp, -48
        sd ra, 0(sp)
        sd fp, 8(sp)
        addi fp, sp, 48
        j lbl_main_1_main
        

##Generated Code
lbl_div_by_zero_0_main:
        # la a0, lbl_div_by_zero_0_main_msg
        la
        # end la a0, lbl_div_by_zero_0_main_msg
        # call println_string
        call
        # end call println_string
        # li a0, 1
        li
        # end li a0, 1
        # call exit
        call
        # end call exit
        j lbl_div_by_zero_0_main_msg
lbl_div_by_zero_0_main_msg:
        # .string "Division by 0"
        .string
        # end .string "Division by 0"
        j lbl_end_1_main
lbl_main_1_main:
        # (stat (print_stat println_int ( (expr (expr (atom 10)) - (expr (atom 5))) ) ;))
        # li temp_0, 10
        li
        # end li temp_0, 10
        # li temp_1, 5
        li
        # end li temp_1, 5
        # sub temp_2, temp_0, temp_1
        sub
        # end sub temp_2, temp_0, temp_1
        # mv a0, temp_2
        mv
        # end mv a0, temp_2
        # call println_int
        call
        # end call println_int
        # Return at end of function:
        # li a0, 0
        li
        # end li a0, 0
        j lbl_end_1_main


##postlude

lbl_end_1_main:
        ld ra, 0(sp)
        ld fp, 8(sp)
        addi sp, sp, 48
        ret
        
________ TestCodeGen.test_alloc_mem[./TP04/tests/students/test_mult.c] _________

self = <test_codegen.TestCodeGen object at 0x7fab869b3730>
output_name = './TP04/tests/students/test_mult-all_in_mem.s'
exec_name = './TP04/tests/students/test_mult.riscv'
info = testinfo(exitcode=0, execcode=0, output='8\n', linkargs=[], skip_test_expected=False)

    def link_and_run(self, output_name, exec_name, info):
        self.remove(exec_name)
        cmd = [
            ASM, output_name, 'TP04/libprint.s',
            '-o', exec_name
        ] + info.linkargs
        print(info)
        print("Assembling and linking " + output_name + ": " + ' '.join(cmd))
        try:
>           subprocess.check_output(cmd, timeout=60, stderr=subprocess.STDOUT)

test_codegen.py:169: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

timeout = 60
popenargs = (['riscv64-unknown-elf-gcc', './TP04/tests/students/test_mult-all_in_mem.s', 'TP04/libprint.s', '-o', './TP04/tests/students/test_mult.riscv'],)
kwargs = {'stderr': -2}

    def check_output(*popenargs, timeout=None, **kwargs):
        r"""Run command with arguments and return its output.
    
        If the exit code was non-zero it raises a CalledProcessError.  The
        CalledProcessError object will have the return code in the returncode
        attribute and output in the output attribute.
    
        The arguments are the same as for the Popen constructor.  Example:
    
        >>> check_output(["ls", "-l", "/dev/null"])
        b'crw-rw-rw- 1 root root 1, 3 Oct 18  2007 /dev/null\n'
    
        The stdout argument is not allowed as it is used internally.
        To capture standard error in the result, use stderr=STDOUT.
    
        >>> check_output(["/bin/sh", "-c",
        ...               "ls -l non_existent_file ; exit 0"],
        ...              stderr=STDOUT)
        b'ls: non_existent_file: No such file or directory\n'
    
        There is an additional optional argument, "input", allowing you to
        pass a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it too will be used internally.  Example:
    
        >>> check_output(["sed", "-e", "s/foo/bar/"],
        ...              input=b"when in the course of fooman events\n")
        b'when in the course of barman events\n'
    
        By default, all communication is in bytes, and therefore any "input"
        should be bytes, and the return value will be bytes.  If in text mode,
        any "input" should be a string, and the return value will be a string
        decoded according to locale encoding, or by "encoding" if set. Text mode
        is triggered by setting any of text, encoding, errors or universal_newlines.
        """
        if 'stdout' in kwargs:
            raise ValueError('stdout argument not allowed, it will be overridden.')
    
        if 'input' in kwargs and kwargs['input'] is None:
            # Explicitly passing input=None was previously equivalent to passing an
            # empty string. That is maintained here for backwards compatibility.
            if kwargs.get('universal_newlines') or kwargs.get('text'):
                empty = ''
            else:
                empty = b''
            kwargs['input'] = empty
    
>       return run(*popenargs, stdout=PIPE, timeout=timeout, check=True,
                   **kwargs).stdout

/usr/lib/python3.8/subprocess.py:415: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = False, timeout = 60, check = True
popenargs = (['riscv64-unknown-elf-gcc', './TP04/tests/students/test_mult-all_in_mem.s', 'TP04/libprint.s', '-o', './TP04/tests/students/test_mult.riscv'],)
kwargs = {'stderr': -2, 'stdout': -1}
process = <subprocess.Popen object at 0x7fab869b3a30>
stdout = b"./TP04/tests/students/test_mult-all_in_mem.s: Assembler messages:\n./TP04/tests/students/test_mult-all_in_mem.s:20: ...em.s:68: Error: illegal operands `mv'\n./TP04/tests/students/test_mult-all_in_mem.s:75: Error: illegal operands `li'\n"
stderr = None, retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout is given, and the process takes too long, a TimeoutExpired
        exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['riscv64-unknown-elf-gcc', './TP04/tests/students/test_mult-all_in_mem.s', 'TP04/libprint.s', '-o', './TP04/tests/students/test_mult.riscv']' returned non-zero exit status 1.

/usr/lib/python3.8/subprocess.py:516: CalledProcessError

During handling of the above exception, another exception occurred:

self = <test_codegen.TestCodeGen object at 0x7fab869b3730>
filename = './TP04/tests/students/test_mult.c'

    @pytest.mark.parametrize('filename', ALL_IN_MEM_FILES)
    def test_alloc_mem(self, filename):
        expect = self.get_expect(filename)
>       actual = self.all_in_mem(filename, expect)

test_codegen.py:242: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
test_codegen.py:100: in all_in_mem
    return self.compile_and_simulate(file, info, reg_alloc='all_in_mem')
test_codegen.py:216: in compile_and_simulate
    return self.link_and_run(output_name, exec_name, info)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_codegen.TestCodeGen object at 0x7fab869b3730>
output_name = './TP04/tests/students/test_mult-all_in_mem.s'
exec_name = './TP04/tests/students/test_mult.riscv'
info = testinfo(exitcode=0, execcode=0, output='8\n', linkargs=[], skip_test_expected=False)

    def link_and_run(self, output_name, exec_name, info):
        self.remove(exec_name)
        cmd = [
            ASM, output_name, 'TP04/libprint.s',
            '-o', exec_name
        ] + info.linkargs
        print(info)
        print("Assembling and linking " + output_name + ": " + ' '.join(cmd))
        try:
            subprocess.check_output(cmd, timeout=60, stderr=subprocess.STDOUT)
        except subprocess.CalledProcessError as e:
            print("Assembling failed:\n")
            print(e.output.decode())
            print("Assembler code below:\n")
            cat(output_name)
>           pytest.fail()
E           Failed

test_codegen.py:175: Failed
----------------------------- Captured stdout call -----------------------------
Compiling ...
/usr/bin/python3 ./MiniCC.py --reg-alloc=all_in_mem --output=./TP04/tests/students/test_mult-all_in_mem.s ./TP04/tests/students/test_mult.c
Exited with status: 0

Compiling ... OK
testinfo(exitcode=0, execcode=0, output='8\n', linkargs=[], skip_test_expected=False)
Assembling and linking ./TP04/tests/students/test_mult-all_in_mem.s: riscv64-unknown-elf-gcc ./TP04/tests/students/test_mult-all_in_mem.s TP04/libprint.s -o ./TP04/tests/students/test_mult.riscv
Assembling failed:

./TP04/tests/students/test_mult-all_in_mem.s: Assembler messages:
./TP04/tests/students/test_mult-all_in_mem.s:20: Error: illegal operands `la'
./TP04/tests/students/test_mult-all_in_mem.s:26: Error: illegal operands `li'
./TP04/tests/students/test_mult-all_in_mem.s:38: Error: illegal operands `li'
./TP04/tests/students/test_mult-all_in_mem.s:41: Error: illegal operands `li'
./TP04/tests/students/test_mult-all_in_mem.s:45: Error: illegal operands `li'
./TP04/tests/students/test_mult-all_in_mem.s:48: Error: illegal operands `mv'
./TP04/tests/students/test_mult-all_in_mem.s:52: Error: illegal operands `li'
./TP04/tests/students/test_mult-all_in_mem.s:55: Error: illegal operands `mv'
./TP04/tests/students/test_mult-all_in_mem.s:59: Error: illegal operands `li'
./TP04/tests/students/test_mult-all_in_mem.s:62: Error: illegal operands `li'
./TP04/tests/students/test_mult-all_in_mem.s:65: Error: illegal operands `mul'
./TP04/tests/students/test_mult-all_in_mem.s:68: Error: illegal operands `mv'
./TP04/tests/students/test_mult-all_in_mem.s:75: Error: illegal operands `li'

Assembler code below:

##Automatically generated RISCV code, MIF08 & CAP
## all-in-memory allocation


##prelude

        .text
        .globl main
main:
        addi sp, sp, -80
        sd ra, 0(sp)
        sd fp, 8(sp)
        addi fp, sp, 80
        j lbl_main_1_main
        

##Generated Code
lbl_div_by_zero_0_main:
        # la a0, lbl_div_by_zero_0_main_msg
        la
        # end la a0, lbl_div_by_zero_0_main_msg
        # call println_string
        call
        # end call println_string
        # li a0, 1
        li
        # end li a0, 1
        # call exit
        call
        # end call exit
        j lbl_div_by_zero_0_main_msg
lbl_div_by_zero_0_main_msg:
        # .string "Division by 0"
        .string
        # end .string "Division by 0"
        j lbl_end_1_main
lbl_main_1_main:
        # li temp_0, 0
        li
        # end li temp_0, 0
        # li temp_1, 0
        li
        # end li temp_1, 0
        # (stat (assignment n = (expr (atom 2))) ;)
        # li temp_2, 2
        li
        # end li temp_2, 2
        # mv temp_1, temp_2
        mv
        # end mv temp_1, temp_2
        # (stat (assignment m = (expr (atom 4))) ;)
        # li temp_3, 4
        li
        # end li temp_3, 4
        # mv temp_0, temp_3
        mv
        # end mv temp_0, temp_3
        # (stat (print_stat println_int ( (expr (expr (atom 2)) * (expr (atom 4))) ) ;))
        # li temp_4, 2
        li
        # end li temp_4, 2
        # li temp_5, 4
        li
        # end li temp_5, 4
        # mul temp_6, temp_4, temp_5
        mul
        # end mul temp_6, temp_4, temp_5
        # mv a0, temp_6
        mv
        # end mv a0, temp_6
        # call println_int
        call
        # end call println_int
        # Return at end of function:
        # li a0, 0
        li
        # end li a0, 0
        j lbl_end_1_main


##postlude

lbl_end_1_main:
        ld ra, 0(sp)
        ld fp, 8(sp)
        addi sp, sp, 80
        ret
        
_________ TestCodeGen.test_alloc_mem[./TP04/tests/students/test_not.c] _________

self = <test_codegen.TestCodeGen object at 0x7fab86988e80>
output_name = './TP04/tests/students/test_not-all_in_mem.s'
exec_name = './TP04/tests/students/test_not.riscv'
info = testinfo(exitcode=0, execcode=0, output='1\n', linkargs=[], skip_test_expected=False)

    def link_and_run(self, output_name, exec_name, info):
        self.remove(exec_name)
        cmd = [
            ASM, output_name, 'TP04/libprint.s',
            '-o', exec_name
        ] + info.linkargs
        print(info)
        print("Assembling and linking " + output_name + ": " + ' '.join(cmd))
        try:
>           subprocess.check_output(cmd, timeout=60, stderr=subprocess.STDOUT)

test_codegen.py:169: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

timeout = 60
popenargs = (['riscv64-unknown-elf-gcc', './TP04/tests/students/test_not-all_in_mem.s', 'TP04/libprint.s', '-o', './TP04/tests/students/test_not.riscv'],)
kwargs = {'stderr': -2}

    def check_output(*popenargs, timeout=None, **kwargs):
        r"""Run command with arguments and return its output.
    
        If the exit code was non-zero it raises a CalledProcessError.  The
        CalledProcessError object will have the return code in the returncode
        attribute and output in the output attribute.
    
        The arguments are the same as for the Popen constructor.  Example:
    
        >>> check_output(["ls", "-l", "/dev/null"])
        b'crw-rw-rw- 1 root root 1, 3 Oct 18  2007 /dev/null\n'
    
        The stdout argument is not allowed as it is used internally.
        To capture standard error in the result, use stderr=STDOUT.
    
        >>> check_output(["/bin/sh", "-c",
        ...               "ls -l non_existent_file ; exit 0"],
        ...              stderr=STDOUT)
        b'ls: non_existent_file: No such file or directory\n'
    
        There is an additional optional argument, "input", allowing you to
        pass a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it too will be used internally.  Example:
    
        >>> check_output(["sed", "-e", "s/foo/bar/"],
        ...              input=b"when in the course of fooman events\n")
        b'when in the course of barman events\n'
    
        By default, all communication is in bytes, and therefore any "input"
        should be bytes, and the return value will be bytes.  If in text mode,
        any "input" should be a string, and the return value will be a string
        decoded according to locale encoding, or by "encoding" if set. Text mode
        is triggered by setting any of text, encoding, errors or universal_newlines.
        """
        if 'stdout' in kwargs:
            raise ValueError('stdout argument not allowed, it will be overridden.')
    
        if 'input' in kwargs and kwargs['input'] is None:
            # Explicitly passing input=None was previously equivalent to passing an
            # empty string. That is maintained here for backwards compatibility.
            if kwargs.get('universal_newlines') or kwargs.get('text'):
                empty = ''
            else:
                empty = b''
            kwargs['input'] = empty
    
>       return run(*popenargs, stdout=PIPE, timeout=timeout, check=True,
                   **kwargs).stdout

/usr/lib/python3.8/subprocess.py:415: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = False, timeout = 60, check = True
popenargs = (['riscv64-unknown-elf-gcc', './TP04/tests/students/test_not-all_in_mem.s', 'TP04/libprint.s', '-o', './TP04/tests/students/test_not.riscv'],)
kwargs = {'stderr': -2, 'stdout': -1}
process = <subprocess.Popen object at 0x7fab869bbd30>
stdout = b"./TP04/tests/students/test_not-all_in_mem.s: Assembler messages:\n./TP04/tests/students/test_not-all_in_mem.s:20: Er...mem.s:76: Error: illegal operands `mv'\n./TP04/tests/students/test_not-all_in_mem.s:84: Error: illegal operands `li'\n"
stderr = None, retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout is given, and the process takes too long, a TimeoutExpired
        exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['riscv64-unknown-elf-gcc', './TP04/tests/students/test_not-all_in_mem.s', 'TP04/libprint.s', '-o', './TP04/tests/students/test_not.riscv']' returned non-zero exit status 1.

/usr/lib/python3.8/subprocess.py:516: CalledProcessError

During handling of the above exception, another exception occurred:

self = <test_codegen.TestCodeGen object at 0x7fab86988e80>
filename = './TP04/tests/students/test_not.c'

    @pytest.mark.parametrize('filename', ALL_IN_MEM_FILES)
    def test_alloc_mem(self, filename):
        expect = self.get_expect(filename)
>       actual = self.all_in_mem(filename, expect)

test_codegen.py:242: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
test_codegen.py:100: in all_in_mem
    return self.compile_and_simulate(file, info, reg_alloc='all_in_mem')
test_codegen.py:216: in compile_and_simulate
    return self.link_and_run(output_name, exec_name, info)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_codegen.TestCodeGen object at 0x7fab86988e80>
output_name = './TP04/tests/students/test_not-all_in_mem.s'
exec_name = './TP04/tests/students/test_not.riscv'
info = testinfo(exitcode=0, execcode=0, output='1\n', linkargs=[], skip_test_expected=False)

    def link_and_run(self, output_name, exec_name, info):
        self.remove(exec_name)
        cmd = [
            ASM, output_name, 'TP04/libprint.s',
            '-o', exec_name
        ] + info.linkargs
        print(info)
        print("Assembling and linking " + output_name + ": " + ' '.join(cmd))
        try:
            subprocess.check_output(cmd, timeout=60, stderr=subprocess.STDOUT)
        except subprocess.CalledProcessError as e:
            print("Assembling failed:\n")
            print(e.output.decode())
            print("Assembler code below:\n")
            cat(output_name)
>           pytest.fail()
E           Failed

test_codegen.py:175: Failed
----------------------------- Captured stdout call -----------------------------
Compiling ...
/usr/bin/python3 ./MiniCC.py --reg-alloc=all_in_mem --output=./TP04/tests/students/test_not-all_in_mem.s ./TP04/tests/students/test_not.c
Exited with status: 0
false

Compiling ... OK
testinfo(exitcode=0, execcode=0, output='1\n', linkargs=[], skip_test_expected=False)
Assembling and linking ./TP04/tests/students/test_not-all_in_mem.s: riscv64-unknown-elf-gcc ./TP04/tests/students/test_not-all_in_mem.s TP04/libprint.s -o ./TP04/tests/students/test_not.riscv
Assembling failed:

./TP04/tests/students/test_not-all_in_mem.s: Assembler messages:
./TP04/tests/students/test_not-all_in_mem.s:20: Error: illegal operands `la'
./TP04/tests/students/test_not-all_in_mem.s:26: Error: illegal operands `li'
./TP04/tests/students/test_not-all_in_mem.s:38: Error: illegal operands `li'
./TP04/tests/students/test_not-all_in_mem.s:42: Error: illegal operands `li'
./TP04/tests/students/test_not-all_in_mem.s:45: Error: illegal operands `mv'
./TP04/tests/students/test_not-all_in_mem.s:49: Error: illegal operands `not'
./TP04/tests/students/test_not-all_in_mem.s:52: Error: illegal operands `li'
./TP04/tests/students/test_not-all_in_mem.s:55: Error: illegal operands `beq'
./TP04/tests/students/test_not-all_in_mem.s:59: Error: illegal operands `li'
./TP04/tests/students/test_not-all_in_mem.s:62: Error: illegal operands `mv'
./TP04/tests/students/test_not-all_in_mem.s:73: Error: illegal operands `li'
./TP04/tests/students/test_not-all_in_mem.s:76: Error: illegal operands `mv'
./TP04/tests/students/test_not-all_in_mem.s:84: Error: illegal operands `li'

Assembler code below:

##Automatically generated RISCV code, MIF08 & CAP
## all-in-memory allocation


##prelude

        .text
        .globl main
main:
        addi sp, sp, -64
        sd ra, 0(sp)
        sd fp, 8(sp)
        addi fp, sp, 64
        j lbl_main_3_main
        

##Generated Code
lbl_div_by_zero_0_main:
        # la a0, lbl_div_by_zero_0_main_msg
        la
        # end la a0, lbl_div_by_zero_0_main_msg
        # call println_string
        call
        # end call println_string
        # li a0, 1
        li
        # end li a0, 1
        # call exit
        call
        # end call exit
        j lbl_div_by_zero_0_main_msg
lbl_div_by_zero_0_main_msg:
        # .string "Division by 0"
        .string
        # end .string "Division by 0"
        j lbl_end_3_main
lbl_main_3_main:
        # li temp_0, 0
        li
        # end li temp_0, 0
        # (stat (assignment b = (expr (atom false))) ;)
        # li temp_1, 0
        li
        # end li temp_1, 0
        # mv temp_0, temp_1
        mv
        # end mv temp_0, temp_1
        # (stat (if_stat if ( (expr ! (expr (atom b))) ) (stat_block { (block (stat (print_stat println_int ( (expr (atom 1)) ) ;))) }) else (stat_block { (block (stat (print_stat println_int ( (expr (atom 0)) ) ;))) })))
        # not temp_2, temp_0
        not
        # end not temp_2, temp_0
        # li temp_3, 0
        li
        # end li temp_3, 0
        # beq temp_2, temp_3, lbl_else_1_main
        beq
        # end beq temp_2, temp_3, lbl_else_1_main
        # (stat (print_stat println_int ( (expr (atom 1)) ) ;))
        # li temp_4, 1
        li
        # end li temp_4, 1
        # mv a0, temp_4
        mv
        # end mv a0, temp_4
        # call println_int
        call
        # end call println_int
        # j lbl_end_if_2_main
        j
        # end j lbl_end_if_2_main
lbl_else_1_main:
        # (stat (print_stat println_int ( (expr (atom 0)) ) ;))
        # li temp_5, 0
        li
        # end li temp_5, 0
        # mv a0, temp_5
        mv
        # end mv a0, temp_5
        # call println_int
        call
        # end call println_int
lbl_end_if_2_main:
        # Return at end of function:
        # li a0, 0
        li
        # end li a0, 0
        j lbl_end_3_main


##postlude

lbl_end_3_main:
        ld ra, 0(sp)
        ld fp, 8(sp)
        addi sp, sp, 64
        ret
        
_________ TestCodeGen.test_alloc_mem[./TP04/tests/students/test_or.c] __________

self = <test_codegen.TestCodeGen object at 0x7fab866b52e0>
output_name = './TP04/tests/students/test_or-all_in_mem.s'
exec_name = './TP04/tests/students/test_or.riscv'
info = testinfo(exitcode=0, execcode=0, output='1\n', linkargs=[], skip_test_expected=False)

    def link_and_run(self, output_name, exec_name, info):
        self.remove(exec_name)
        cmd = [
            ASM, output_name, 'TP04/libprint.s',
            '-o', exec_name
        ] + info.linkargs
        print(info)
        print("Assembling and linking " + output_name + ": " + ' '.join(cmd))
        try:
>           subprocess.check_output(cmd, timeout=60, stderr=subprocess.STDOUT)

test_codegen.py:169: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

timeout = 60
popenargs = (['riscv64-unknown-elf-gcc', './TP04/tests/students/test_or-all_in_mem.s', 'TP04/libprint.s', '-o', './TP04/tests/students/test_or.riscv'],)
kwargs = {'stderr': -2}

    def check_output(*popenargs, timeout=None, **kwargs):
        r"""Run command with arguments and return its output.
    
        If the exit code was non-zero it raises a CalledProcessError.  The
        CalledProcessError object will have the return code in the returncode
        attribute and output in the output attribute.
    
        The arguments are the same as for the Popen constructor.  Example:
    
        >>> check_output(["ls", "-l", "/dev/null"])
        b'crw-rw-rw- 1 root root 1, 3 Oct 18  2007 /dev/null\n'
    
        The stdout argument is not allowed as it is used internally.
        To capture standard error in the result, use stderr=STDOUT.
    
        >>> check_output(["/bin/sh", "-c",
        ...               "ls -l non_existent_file ; exit 0"],
        ...              stderr=STDOUT)
        b'ls: non_existent_file: No such file or directory\n'
    
        There is an additional optional argument, "input", allowing you to
        pass a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it too will be used internally.  Example:
    
        >>> check_output(["sed", "-e", "s/foo/bar/"],
        ...              input=b"when in the course of fooman events\n")
        b'when in the course of barman events\n'
    
        By default, all communication is in bytes, and therefore any "input"
        should be bytes, and the return value will be bytes.  If in text mode,
        any "input" should be a string, and the return value will be a string
        decoded according to locale encoding, or by "encoding" if set. Text mode
        is triggered by setting any of text, encoding, errors or universal_newlines.
        """
        if 'stdout' in kwargs:
            raise ValueError('stdout argument not allowed, it will be overridden.')
    
        if 'input' in kwargs and kwargs['input'] is None:
            # Explicitly passing input=None was previously equivalent to passing an
            # empty string. That is maintained here for backwards compatibility.
            if kwargs.get('universal_newlines') or kwargs.get('text'):
                empty = ''
            else:
                empty = b''
            kwargs['input'] = empty
    
>       return run(*popenargs, stdout=PIPE, timeout=timeout, check=True,
                   **kwargs).stdout

/usr/lib/python3.8/subprocess.py:415: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = False, timeout = 60, check = True
popenargs = (['riscv64-unknown-elf-gcc', './TP04/tests/students/test_or-all_in_mem.s', 'TP04/libprint.s', '-o', './TP04/tests/students/test_or.riscv'],)
kwargs = {'stderr': -2, 'stdout': -1}
process = <subprocess.Popen object at 0x7fab866b5af0>
stdout = b"./TP04/tests/students/test_or-all_in_mem.s: Assembler messages:\n./TP04/tests/students/test_or-all_in_mem.s:20: Erro..._mem.s:86: Error: illegal operands `mv'\n./TP04/tests/students/test_or-all_in_mem.s:94: Error: illegal operands `li'\n"
stderr = None, retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout is given, and the process takes too long, a TimeoutExpired
        exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['riscv64-unknown-elf-gcc', './TP04/tests/students/test_or-all_in_mem.s', 'TP04/libprint.s', '-o', './TP04/tests/students/test_or.riscv']' returned non-zero exit status 1.

/usr/lib/python3.8/subprocess.py:516: CalledProcessError

During handling of the above exception, another exception occurred:

self = <test_codegen.TestCodeGen object at 0x7fab866b52e0>
filename = './TP04/tests/students/test_or.c'

    @pytest.mark.parametrize('filename', ALL_IN_MEM_FILES)
    def test_alloc_mem(self, filename):
        expect = self.get_expect(filename)
>       actual = self.all_in_mem(filename, expect)

test_codegen.py:242: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
test_codegen.py:100: in all_in_mem
    return self.compile_and_simulate(file, info, reg_alloc='all_in_mem')
test_codegen.py:216: in compile_and_simulate
    return self.link_and_run(output_name, exec_name, info)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_codegen.TestCodeGen object at 0x7fab866b52e0>
output_name = './TP04/tests/students/test_or-all_in_mem.s'
exec_name = './TP04/tests/students/test_or.riscv'
info = testinfo(exitcode=0, execcode=0, output='1\n', linkargs=[], skip_test_expected=False)

    def link_and_run(self, output_name, exec_name, info):
        self.remove(exec_name)
        cmd = [
            ASM, output_name, 'TP04/libprint.s',
            '-o', exec_name
        ] + info.linkargs
        print(info)
        print("Assembling and linking " + output_name + ": " + ' '.join(cmd))
        try:
            subprocess.check_output(cmd, timeout=60, stderr=subprocess.STDOUT)
        except subprocess.CalledProcessError as e:
            print("Assembling failed:\n")
            print(e.output.decode())
            print("Assembler code below:\n")
            cat(output_name)
>           pytest.fail()
E           Failed

test_codegen.py:175: Failed
----------------------------- Captured stdout call -----------------------------
Compiling ...
/usr/bin/python3 ./MiniCC.py --reg-alloc=all_in_mem --output=./TP04/tests/students/test_or-all_in_mem.s ./TP04/tests/students/test_or.c
Exited with status: 0
true
false

Compiling ... OK
testinfo(exitcode=0, execcode=0, output='1\n', linkargs=[], skip_test_expected=False)
Assembling and linking ./TP04/tests/students/test_or-all_in_mem.s: riscv64-unknown-elf-gcc ./TP04/tests/students/test_or-all_in_mem.s TP04/libprint.s -o ./TP04/tests/students/test_or.riscv
Assembling failed:

./TP04/tests/students/test_or-all_in_mem.s: Assembler messages:
./TP04/tests/students/test_or-all_in_mem.s:20: Error: illegal operands `la'
./TP04/tests/students/test_or-all_in_mem.s:26: Error: illegal operands `li'
./TP04/tests/students/test_or-all_in_mem.s:38: Error: illegal operands `li'
./TP04/tests/students/test_or-all_in_mem.s:41: Error: illegal operands `li'
./TP04/tests/students/test_or-all_in_mem.s:45: Error: illegal operands `li'
./TP04/tests/students/test_or-all_in_mem.s:48: Error: illegal operands `mv'
./TP04/tests/students/test_or-all_in_mem.s:52: Error: illegal operands `li'
./TP04/tests/students/test_or-all_in_mem.s:55: Error: illegal operands `mv'
./TP04/tests/students/test_or-all_in_mem.s:59: Error: illegal operands `or'
./TP04/tests/students/test_or-all_in_mem.s:62: Error: illegal operands `li'
./TP04/tests/students/test_or-all_in_mem.s:65: Error: illegal operands `beq'
./TP04/tests/students/test_or-all_in_mem.s:69: Error: illegal operands `li'
./TP04/tests/students/test_or-all_in_mem.s:72: Error: illegal operands `mv'
./TP04/tests/students/test_or-all_in_mem.s:83: Error: illegal operands `li'
./TP04/tests/students/test_or-all_in_mem.s:86: Error: illegal operands `mv'
./TP04/tests/students/test_or-all_in_mem.s:94: Error: illegal operands `li'

Assembler code below:

##Automatically generated RISCV code, MIF08 & CAP
## all-in-memory allocation


##prelude

        .text
        .globl main
main:
        addi sp, sp, -80
        sd ra, 0(sp)
        sd fp, 8(sp)
        addi fp, sp, 80
        j lbl_main_3_main
        

##Generated Code
lbl_div_by_zero_0_main:
        # la a0, lbl_div_by_zero_0_main_msg
        la
        # end la a0, lbl_div_by_zero_0_main_msg
        # call println_string
        call
        # end call println_string
        # li a0, 1
        li
        # end li a0, 1
        # call exit
        call
        # end call exit
        j lbl_div_by_zero_0_main_msg
lbl_div_by_zero_0_main_msg:
        # .string "Division by 0"
        .string
        # end .string "Division by 0"
        j lbl_end_3_main
lbl_main_3_main:
        # li temp_0, 0
        li
        # end li temp_0, 0
        # li temp_1, 0
        li
        # end li temp_1, 0
        # (stat (assignment n = (expr (atom true))) ;)
        # li temp_2, 1
        li
        # end li temp_2, 1
        # mv temp_1, temp_2
        mv
        # end mv temp_1, temp_2
        # (stat (assignment m = (expr (atom false))) ;)
        # li temp_3, 0
        li
        # end li temp_3, 0
        # mv temp_0, temp_3
        mv
        # end mv temp_0, temp_3
        # (stat (if_stat if ( (expr (expr (atom n)) || (expr (atom m))) ) (stat_block { (block (stat (print_stat println_int ( (expr (atom 1)) ) ;))) }) else (stat_block { (block (stat (print_stat println_int ( (expr (atom 0)) ) ;))) })))
        # or temp_4, temp_1, temp_0
        or
        # end or temp_4, temp_1, temp_0
        # li temp_5, 0
        li
        # end li temp_5, 0
        # beq temp_4, temp_5, lbl_else_1_main
        beq
        # end beq temp_4, temp_5, lbl_else_1_main
        # (stat (print_stat println_int ( (expr (atom 1)) ) ;))
        # li temp_6, 1
        li
        # end li temp_6, 1
        # mv a0, temp_6
        mv
        # end mv a0, temp_6
        # call println_int
        call
        # end call println_int
        # j lbl_end_if_2_main
        j
        # end j lbl_end_if_2_main
lbl_else_1_main:
        # (stat (print_stat println_int ( (expr (atom 0)) ) ;))
        # li temp_7, 0
        li
        # end li temp_7, 0
        # mv a0, temp_7
        mv
        # end mv a0, temp_7
        # call println_int
        call
        # end call println_int
lbl_end_if_2_main:
        # Return at end of function:
        # li a0, 0
        li
        # end li a0, 0
        j lbl_end_3_main


##postlude

lbl_end_3_main:
        ld ra, 0(sp)
        ld fp, 8(sp)
        addi sp, sp, 80
        ret
        
_____ TestCodeGen.test_alloc_mem[./TP04/tests/students/test_unary_minus.c] _____

self = <test_codegen.TestCodeGen object at 0x7fab867cbdc0>
output_name = './TP04/tests/students/test_unary_minus-all_in_mem.s'
exec_name = './TP04/tests/students/test_unary_minus.riscv'
info = testinfo(exitcode=0, execcode=0, output='-5\n', linkargs=[], skip_test_expected=False)

    def link_and_run(self, output_name, exec_name, info):
        self.remove(exec_name)
        cmd = [
            ASM, output_name, 'TP04/libprint.s',
            '-o', exec_name
        ] + info.linkargs
        print(info)
        print("Assembling and linking " + output_name + ": " + ' '.join(cmd))
        try:
>           subprocess.check_output(cmd, timeout=60, stderr=subprocess.STDOUT)

test_codegen.py:169: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

timeout = 60
popenargs = (['riscv64-unknown-elf-gcc', './TP04/tests/students/test_unary_minus-all_in_mem.s', 'TP04/libprint.s', '-o', './TP04/tests/students/test_unary_minus.riscv'],)
kwargs = {'stderr': -2}

    def check_output(*popenargs, timeout=None, **kwargs):
        r"""Run command with arguments and return its output.
    
        If the exit code was non-zero it raises a CalledProcessError.  The
        CalledProcessError object will have the return code in the returncode
        attribute and output in the output attribute.
    
        The arguments are the same as for the Popen constructor.  Example:
    
        >>> check_output(["ls", "-l", "/dev/null"])
        b'crw-rw-rw- 1 root root 1, 3 Oct 18  2007 /dev/null\n'
    
        The stdout argument is not allowed as it is used internally.
        To capture standard error in the result, use stderr=STDOUT.
    
        >>> check_output(["/bin/sh", "-c",
        ...               "ls -l non_existent_file ; exit 0"],
        ...              stderr=STDOUT)
        b'ls: non_existent_file: No such file or directory\n'
    
        There is an additional optional argument, "input", allowing you to
        pass a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it too will be used internally.  Example:
    
        >>> check_output(["sed", "-e", "s/foo/bar/"],
        ...              input=b"when in the course of fooman events\n")
        b'when in the course of barman events\n'
    
        By default, all communication is in bytes, and therefore any "input"
        should be bytes, and the return value will be bytes.  If in text mode,
        any "input" should be a string, and the return value will be a string
        decoded according to locale encoding, or by "encoding" if set. Text mode
        is triggered by setting any of text, encoding, errors or universal_newlines.
        """
        if 'stdout' in kwargs:
            raise ValueError('stdout argument not allowed, it will be overridden.')
    
        if 'input' in kwargs and kwargs['input'] is None:
            # Explicitly passing input=None was previously equivalent to passing an
            # empty string. That is maintained here for backwards compatibility.
            if kwargs.get('universal_newlines') or kwargs.get('text'):
                empty = ''
            else:
                empty = b''
            kwargs['input'] = empty
    
>       return run(*popenargs, stdout=PIPE, timeout=timeout, check=True,
                   **kwargs).stdout

/usr/lib/python3.8/subprocess.py:415: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = False, timeout = 60, check = True
popenargs = (['riscv64-unknown-elf-gcc', './TP04/tests/students/test_unary_minus-all_in_mem.s', 'TP04/libprint.s', '-o', './TP04/tests/students/test_unary_minus.riscv'],)
kwargs = {'stderr': -2, 'stdout': -1}
process = <subprocess.Popen object at 0x7fab867cb940>
stdout = b"./TP04/tests/students/test_unary_minus-all_in_mem.s: Assembler messages:\n./TP04/tests/students/test_unary_minus-all...: Error: illegal operands `mv'\n./TP04/tests/students/test_unary_minus-all_in_mem.s:55: Error: illegal operands `li'\n"
stderr = None, retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout is given, and the process takes too long, a TimeoutExpired
        exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['riscv64-unknown-elf-gcc', './TP04/tests/students/test_unary_minus-all_in_mem.s', 'TP04/libprint.s', '-o', './TP04/tests/students/test_unary_minus.riscv']' returned non-zero exit status 1.

/usr/lib/python3.8/subprocess.py:516: CalledProcessError

During handling of the above exception, another exception occurred:

self = <test_codegen.TestCodeGen object at 0x7fab867cbdc0>
filename = './TP04/tests/students/test_unary_minus.c'

    @pytest.mark.parametrize('filename', ALL_IN_MEM_FILES)
    def test_alloc_mem(self, filename):
        expect = self.get_expect(filename)
>       actual = self.all_in_mem(filename, expect)

test_codegen.py:242: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
test_codegen.py:100: in all_in_mem
    return self.compile_and_simulate(file, info, reg_alloc='all_in_mem')
test_codegen.py:216: in compile_and_simulate
    return self.link_and_run(output_name, exec_name, info)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_codegen.TestCodeGen object at 0x7fab867cbdc0>
output_name = './TP04/tests/students/test_unary_minus-all_in_mem.s'
exec_name = './TP04/tests/students/test_unary_minus.riscv'
info = testinfo(exitcode=0, execcode=0, output='-5\n', linkargs=[], skip_test_expected=False)

    def link_and_run(self, output_name, exec_name, info):
        self.remove(exec_name)
        cmd = [
            ASM, output_name, 'TP04/libprint.s',
            '-o', exec_name
        ] + info.linkargs
        print(info)
        print("Assembling and linking " + output_name + ": " + ' '.join(cmd))
        try:
            subprocess.check_output(cmd, timeout=60, stderr=subprocess.STDOUT)
        except subprocess.CalledProcessError as e:
            print("Assembling failed:\n")
            print(e.output.decode())
            print("Assembler code below:\n")
            cat(output_name)
>           pytest.fail()
E           Failed

test_codegen.py:175: Failed
----------------------------- Captured stdout call -----------------------------
Compiling ...
/usr/bin/python3 ./MiniCC.py --reg-alloc=all_in_mem --output=./TP04/tests/students/test_unary_minus-all_in_mem.s ./TP04/tests/students/test_unary_minus.c
Exited with status: 0

Compiling ... OK
testinfo(exitcode=0, execcode=0, output='-5\n', linkargs=[], skip_test_expected=False)
Assembling and linking ./TP04/tests/students/test_unary_minus-all_in_mem.s: riscv64-unknown-elf-gcc ./TP04/tests/students/test_unary_minus-all_in_mem.s TP04/libprint.s -o ./TP04/tests/students/test_unary_minus.riscv
Assembling failed:

./TP04/tests/students/test_unary_minus-all_in_mem.s: Assembler messages:
./TP04/tests/students/test_unary_minus-all_in_mem.s:20: Error: illegal operands `la'
./TP04/tests/students/test_unary_minus-all_in_mem.s:26: Error: illegal operands `li'
./TP04/tests/students/test_unary_minus-all_in_mem.s:39: Error: illegal operands `li'
./TP04/tests/students/test_unary_minus-all_in_mem.s:42: Error: illegal operands `li'
./TP04/tests/students/test_unary_minus-all_in_mem.s:45: Error: illegal operands `sub'
./TP04/tests/students/test_unary_minus-all_in_mem.s:48: Error: illegal operands `mv'
./TP04/tests/students/test_unary_minus-all_in_mem.s:55: Error: illegal operands `li'

Assembler code below:

##Automatically generated RISCV code, MIF08 & CAP
## all-in-memory allocation


##prelude

        .text
        .globl main
main:
        addi sp, sp, -48
        sd ra, 0(sp)
        sd fp, 8(sp)
        addi fp, sp, 48
        j lbl_main_1_main
        

##Generated Code
lbl_div_by_zero_0_main:
        # la a0, lbl_div_by_zero_0_main_msg
        la
        # end la a0, lbl_div_by_zero_0_main_msg
        # call println_string
        call
        # end call println_string
        # li a0, 1
        li
        # end li a0, 1
        # call exit
        call
        # end call exit
        j lbl_div_by_zero_0_main_msg
lbl_div_by_zero_0_main_msg:
        # .string "Division by 0"
        .string
        # end .string "Division by 0"
        j lbl_end_1_main
lbl_main_1_main:
        # (stat (print_stat println_int ( (expr - (expr (atom 5))) ) ;))
        # li temp_1, 5
        li
        # end li temp_1, 5
        # li temp_2, 0
        li
        # end li temp_2, 0
        # sub temp_0, temp_2, temp_1
        sub
        # end sub temp_0, temp_2, temp_1
        # mv a0, temp_0
        mv
        # end mv a0, temp_0
        # call println_int
        call
        # end call println_int
        # Return at end of function:
        # li a0, 0
        li
        # end li a0, 0
        j lbl_end_1_main


##postlude

lbl_end_1_main:
        ld ra, 0(sp)
        ld fp, 8(sp)
        addi sp, sp, 48
        ret
        
______ TestCodeGen.test_alloc_mem[./TP05/tests/provided/dataflow/df00.c] _______

self = <test_codegen.TestCodeGen object at 0x7fab8682f640>
output_name = './TP05/tests/provided/dataflow/df00-all_in_mem.s'
exec_name = './TP05/tests/provided/dataflow/df00.riscv'
info = testinfo(exitcode=0, execcode=0, output='6\n', linkargs=[], skip_test_expected=False)

    def link_and_run(self, output_name, exec_name, info):
        self.remove(exec_name)
        cmd = [
            ASM, output_name, 'TP04/libprint.s',
            '-o', exec_name
        ] + info.linkargs
        print(info)
        print("Assembling and linking " + output_name + ": " + ' '.join(cmd))
        try:
>           subprocess.check_output(cmd, timeout=60, stderr=subprocess.STDOUT)

test_codegen.py:169: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

timeout = 60
popenargs = (['riscv64-unknown-elf-gcc', './TP05/tests/provided/dataflow/df00-all_in_mem.s', 'TP04/libprint.s', '-o', './TP05/tests/provided/dataflow/df00.riscv'],)
kwargs = {'stderr': -2}

    def check_output(*popenargs, timeout=None, **kwargs):
        r"""Run command with arguments and return its output.
    
        If the exit code was non-zero it raises a CalledProcessError.  The
        CalledProcessError object will have the return code in the returncode
        attribute and output in the output attribute.
    
        The arguments are the same as for the Popen constructor.  Example:
    
        >>> check_output(["ls", "-l", "/dev/null"])
        b'crw-rw-rw- 1 root root 1, 3 Oct 18  2007 /dev/null\n'
    
        The stdout argument is not allowed as it is used internally.
        To capture standard error in the result, use stderr=STDOUT.
    
        >>> check_output(["/bin/sh", "-c",
        ...               "ls -l non_existent_file ; exit 0"],
        ...              stderr=STDOUT)
        b'ls: non_existent_file: No such file or directory\n'
    
        There is an additional optional argument, "input", allowing you to
        pass a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it too will be used internally.  Example:
    
        >>> check_output(["sed", "-e", "s/foo/bar/"],
        ...              input=b"when in the course of fooman events\n")
        b'when in the course of barman events\n'
    
        By default, all communication is in bytes, and therefore any "input"
        should be bytes, and the return value will be bytes.  If in text mode,
        any "input" should be a string, and the return value will be a string
        decoded according to locale encoding, or by "encoding" if set. Text mode
        is triggered by setting any of text, encoding, errors or universal_newlines.
        """
        if 'stdout' in kwargs:
            raise ValueError('stdout argument not allowed, it will be overridden.')
    
        if 'input' in kwargs and kwargs['input'] is None:
            # Explicitly passing input=None was previously equivalent to passing an
            # empty string. That is maintained here for backwards compatibility.
            if kwargs.get('universal_newlines') or kwargs.get('text'):
                empty = ''
            else:
                empty = b''
            kwargs['input'] = empty
    
>       return run(*popenargs, stdout=PIPE, timeout=timeout, check=True,
                   **kwargs).stdout

/usr/lib/python3.8/subprocess.py:415: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = False, timeout = 60, check = True
popenargs = (['riscv64-unknown-elf-gcc', './TP05/tests/provided/dataflow/df00-all_in_mem.s', 'TP04/libprint.s', '-o', './TP05/tests/provided/dataflow/df00.riscv'],)
kwargs = {'stderr': -2, 'stdout': -1}
process = <subprocess.Popen object at 0x7fab8682f1f0>
stdout = b"./TP05/tests/provided/dataflow/df00-all_in_mem.s: Assembler messages:\n./TP05/tests/provided/dataflow/df00-all_in_me...:52: Error: illegal operands `mv'\n./TP05/tests/provided/dataflow/df00-all_in_mem.s:59: Error: illegal operands `li'\n"
stderr = None, retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout is given, and the process takes too long, a TimeoutExpired
        exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['riscv64-unknown-elf-gcc', './TP05/tests/provided/dataflow/df00-all_in_mem.s', 'TP04/libprint.s', '-o', './TP05/tests/provided/dataflow/df00.riscv']' returned non-zero exit status 1.

/usr/lib/python3.8/subprocess.py:516: CalledProcessError

During handling of the above exception, another exception occurred:

self = <test_codegen.TestCodeGen object at 0x7fab8682f640>
filename = './TP05/tests/provided/dataflow/df00.c'

    @pytest.mark.parametrize('filename', ALL_IN_MEM_FILES)
    def test_alloc_mem(self, filename):
        expect = self.get_expect(filename)
>       actual = self.all_in_mem(filename, expect)

test_codegen.py:242: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
test_codegen.py:100: in all_in_mem
    return self.compile_and_simulate(file, info, reg_alloc='all_in_mem')
test_codegen.py:216: in compile_and_simulate
    return self.link_and_run(output_name, exec_name, info)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_codegen.TestCodeGen object at 0x7fab8682f640>
output_name = './TP05/tests/provided/dataflow/df00-all_in_mem.s'
exec_name = './TP05/tests/provided/dataflow/df00.riscv'
info = testinfo(exitcode=0, execcode=0, output='6\n', linkargs=[], skip_test_expected=False)

    def link_and_run(self, output_name, exec_name, info):
        self.remove(exec_name)
        cmd = [
            ASM, output_name, 'TP04/libprint.s',
            '-o', exec_name
        ] + info.linkargs
        print(info)
        print("Assembling and linking " + output_name + ": " + ' '.join(cmd))
        try:
            subprocess.check_output(cmd, timeout=60, stderr=subprocess.STDOUT)
        except subprocess.CalledProcessError as e:
            print("Assembling failed:\n")
            print(e.output.decode())
            print("Assembler code below:\n")
            cat(output_name)
>           pytest.fail()
E           Failed

test_codegen.py:175: Failed
----------------------------- Captured stdout call -----------------------------
Compiling ...
/usr/bin/python3 ./MiniCC.py --reg-alloc=all_in_mem --output=./TP05/tests/provided/dataflow/df00-all_in_mem.s ./TP05/tests/provided/dataflow/df00.c
Exited with status: 0

Compiling ... OK
testinfo(exitcode=0, execcode=0, output='6\n', linkargs=[], skip_test_expected=False)
Assembling and linking ./TP05/tests/provided/dataflow/df00-all_in_mem.s: riscv64-unknown-elf-gcc ./TP05/tests/provided/dataflow/df00-all_in_mem.s TP04/libprint.s -o ./TP05/tests/provided/dataflow/df00.riscv
Assembling failed:

./TP05/tests/provided/dataflow/df00-all_in_mem.s: Assembler messages:
./TP05/tests/provided/dataflow/df00-all_in_mem.s:20: Error: illegal operands `la'
./TP05/tests/provided/dataflow/df00-all_in_mem.s:26: Error: illegal operands `li'
./TP05/tests/provided/dataflow/df00-all_in_mem.s:38: Error: illegal operands `li'
./TP05/tests/provided/dataflow/df00-all_in_mem.s:41: Error: illegal operands `li'
./TP05/tests/provided/dataflow/df00-all_in_mem.s:45: Error: illegal operands `li'
./TP05/tests/provided/dataflow/df00-all_in_mem.s:48: Error: illegal operands `mv'
./TP05/tests/provided/dataflow/df00-all_in_mem.s:52: Error: illegal operands `mv'
./TP05/tests/provided/dataflow/df00-all_in_mem.s:59: Error: illegal operands `li'

Assembler code below:

##Automatically generated RISCV code, MIF08 & CAP
## all-in-memory allocation


##prelude

        .text
        .globl main
main:
        addi sp, sp, -48
        sd ra, 0(sp)
        sd fp, 8(sp)
        addi fp, sp, 48
        j lbl_main_1_main
        

##Generated Code
lbl_div_by_zero_0_main:
        # la a0, lbl_div_by_zero_0_main_msg
        la
        # end la a0, lbl_div_by_zero_0_main_msg
        # call println_string
        call
        # end call println_string
        # li a0, 1
        li
        # end li a0, 1
        # call exit
        call
        # end call exit
        j lbl_div_by_zero_0_main_msg
lbl_div_by_zero_0_main_msg:
        # .string "Division by 0"
        .string
        # end .string "Division by 0"
        j lbl_end_1_main
lbl_main_1_main:
        # li temp_0, 0
        li
        # end li temp_0, 0
        # li temp_1, 0
        li
        # end li temp_1, 0
        # (stat (assignment n = (expr (atom 6))) ;)
        # li temp_2, 6
        li
        # end li temp_2, 6
        # mv temp_1, temp_2
        mv
        # end mv temp_1, temp_2
        # (stat (print_stat println_int ( (expr (atom n)) ) ;))
        # mv a0, temp_1
        mv
        # end mv a0, temp_1
        # call println_int
        call
        # end call println_int
        # Return at end of function:
        # li a0, 0
        li
        # end li a0, 0
        j lbl_end_1_main


##postlude

lbl_end_1_main:
        ld ra, 0(sp)
        ld fp, 8(sp)
        addi sp, sp, 48
        ret
        
______ TestCodeGen.test_alloc_mem[./TP05/tests/provided/dataflow/df01.c] _______

self = <test_codegen.TestCodeGen object at 0x7fab869bbc10>
output_name = './TP05/tests/provided/dataflow/df01-all_in_mem.s'
exec_name = './TP05/tests/provided/dataflow/df01.riscv'
info = testinfo(exitcode=0, execcode=0, output='18\n', linkargs=[], skip_test_expected=False)

    def link_and_run(self, output_name, exec_name, info):
        self.remove(exec_name)
        cmd = [
            ASM, output_name, 'TP04/libprint.s',
            '-o', exec_name
        ] + info.linkargs
        print(info)
        print("Assembling and linking " + output_name + ": " + ' '.join(cmd))
        try:
>           subprocess.check_output(cmd, timeout=60, stderr=subprocess.STDOUT)

test_codegen.py:169: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

timeout = 60
popenargs = (['riscv64-unknown-elf-gcc', './TP05/tests/provided/dataflow/df01-all_in_mem.s', 'TP04/libprint.s', '-o', './TP05/tests/provided/dataflow/df01.riscv'],)
kwargs = {'stderr': -2}

    def check_output(*popenargs, timeout=None, **kwargs):
        r"""Run command with arguments and return its output.
    
        If the exit code was non-zero it raises a CalledProcessError.  The
        CalledProcessError object will have the return code in the returncode
        attribute and output in the output attribute.
    
        The arguments are the same as for the Popen constructor.  Example:
    
        >>> check_output(["ls", "-l", "/dev/null"])
        b'crw-rw-rw- 1 root root 1, 3 Oct 18  2007 /dev/null\n'
    
        The stdout argument is not allowed as it is used internally.
        To capture standard error in the result, use stderr=STDOUT.
    
        >>> check_output(["/bin/sh", "-c",
        ...               "ls -l non_existent_file ; exit 0"],
        ...              stderr=STDOUT)
        b'ls: non_existent_file: No such file or directory\n'
    
        There is an additional optional argument, "input", allowing you to
        pass a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it too will be used internally.  Example:
    
        >>> check_output(["sed", "-e", "s/foo/bar/"],
        ...              input=b"when in the course of fooman events\n")
        b'when in the course of barman events\n'
    
        By default, all communication is in bytes, and therefore any "input"
        should be bytes, and the return value will be bytes.  If in text mode,
        any "input" should be a string, and the return value will be a string
        decoded according to locale encoding, or by "encoding" if set. Text mode
        is triggered by setting any of text, encoding, errors or universal_newlines.
        """
        if 'stdout' in kwargs:
            raise ValueError('stdout argument not allowed, it will be overridden.')
    
        if 'input' in kwargs and kwargs['input'] is None:
            # Explicitly passing input=None was previously equivalent to passing an
            # empty string. That is maintained here for backwards compatibility.
            if kwargs.get('universal_newlines') or kwargs.get('text'):
                empty = ''
            else:
                empty = b''
            kwargs['input'] = empty
    
>       return run(*popenargs, stdout=PIPE, timeout=timeout, check=True,
                   **kwargs).stdout

/usr/lib/python3.8/subprocess.py:415: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = False, timeout = 60, check = True
popenargs = (['riscv64-unknown-elf-gcc', './TP05/tests/provided/dataflow/df01-all_in_mem.s', 'TP04/libprint.s', '-o', './TP05/tests/provided/dataflow/df01.riscv'],)
kwargs = {'stderr': -2, 'stdout': -1}
process = <subprocess.Popen object at 0x7fab869bb4c0>
stdout = b"./TP05/tests/provided/dataflow/df01-all_in_mem.s: Assembler messages:\n./TP05/tests/provided/dataflow/df01-all_in_me...:69: Error: illegal operands `mv'\n./TP05/tests/provided/dataflow/df01-all_in_mem.s:76: Error: illegal operands `li'\n"
stderr = None, retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout is given, and the process takes too long, a TimeoutExpired
        exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['riscv64-unknown-elf-gcc', './TP05/tests/provided/dataflow/df01-all_in_mem.s', 'TP04/libprint.s', '-o', './TP05/tests/provided/dataflow/df01.riscv']' returned non-zero exit status 1.

/usr/lib/python3.8/subprocess.py:516: CalledProcessError

During handling of the above exception, another exception occurred:

self = <test_codegen.TestCodeGen object at 0x7fab869bbc10>
filename = './TP05/tests/provided/dataflow/df01.c'

    @pytest.mark.parametrize('filename', ALL_IN_MEM_FILES)
    def test_alloc_mem(self, filename):
        expect = self.get_expect(filename)
>       actual = self.all_in_mem(filename, expect)

test_codegen.py:242: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
test_codegen.py:100: in all_in_mem
    return self.compile_and_simulate(file, info, reg_alloc='all_in_mem')
test_codegen.py:216: in compile_and_simulate
    return self.link_and_run(output_name, exec_name, info)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_codegen.TestCodeGen object at 0x7fab869bbc10>
output_name = './TP05/tests/provided/dataflow/df01-all_in_mem.s'
exec_name = './TP05/tests/provided/dataflow/df01.riscv'
info = testinfo(exitcode=0, execcode=0, output='18\n', linkargs=[], skip_test_expected=False)

    def link_and_run(self, output_name, exec_name, info):
        self.remove(exec_name)
        cmd = [
            ASM, output_name, 'TP04/libprint.s',
            '-o', exec_name
        ] + info.linkargs
        print(info)
        print("Assembling and linking " + output_name + ": " + ' '.join(cmd))
        try:
            subprocess.check_output(cmd, timeout=60, stderr=subprocess.STDOUT)
        except subprocess.CalledProcessError as e:
            print("Assembling failed:\n")
            print(e.output.decode())
            print("Assembler code below:\n")
            cat(output_name)
>           pytest.fail()
E           Failed

test_codegen.py:175: Failed
----------------------------- Captured stdout call -----------------------------
Compiling ...
/usr/bin/python3 ./MiniCC.py --reg-alloc=all_in_mem --output=./TP05/tests/provided/dataflow/df01-all_in_mem.s ./TP05/tests/provided/dataflow/df01.c
Exited with status: 0

Compiling ... OK
testinfo(exitcode=0, execcode=0, output='18\n', linkargs=[], skip_test_expected=False)
Assembling and linking ./TP05/tests/provided/dataflow/df01-all_in_mem.s: riscv64-unknown-elf-gcc ./TP05/tests/provided/dataflow/df01-all_in_mem.s TP04/libprint.s -o ./TP05/tests/provided/dataflow/df01.riscv
Assembling failed:

./TP05/tests/provided/dataflow/df01-all_in_mem.s: Assembler messages:
./TP05/tests/provided/dataflow/df01-all_in_mem.s:20: Error: illegal operands `la'
./TP05/tests/provided/dataflow/df01-all_in_mem.s:26: Error: illegal operands `li'
./TP05/tests/provided/dataflow/df01-all_in_mem.s:38: Error: illegal operands `li'
./TP05/tests/provided/dataflow/df01-all_in_mem.s:41: Error: illegal operands `li'
./TP05/tests/provided/dataflow/df01-all_in_mem.s:44: Error: illegal operands `li'
./TP05/tests/provided/dataflow/df01-all_in_mem.s:48: Error: illegal operands `li'
./TP05/tests/provided/dataflow/df01-all_in_mem.s:51: Error: illegal operands `mv'
./TP05/tests/provided/dataflow/df01-all_in_mem.s:55: Error: illegal operands `li'
./TP05/tests/provided/dataflow/df01-all_in_mem.s:58: Error: illegal operands `mv'
./TP05/tests/provided/dataflow/df01-all_in_mem.s:62: Error: illegal operands `add'
./TP05/tests/provided/dataflow/df01-all_in_mem.s:65: Error: illegal operands `mv'
./TP05/tests/provided/dataflow/df01-all_in_mem.s:69: Error: illegal operands `mv'
./TP05/tests/provided/dataflow/df01-all_in_mem.s:76: Error: illegal operands `li'

Assembler code below:

##Automatically generated RISCV code, MIF08 & CAP
## all-in-memory allocation


##prelude

        .text
        .globl main
main:
        addi sp, sp, -64
        sd ra, 0(sp)
        sd fp, 8(sp)
        addi fp, sp, 64
        j lbl_main_1_main
        

##Generated Code
lbl_div_by_zero_0_main:
        # la a0, lbl_div_by_zero_0_main_msg
        la
        # end la a0, lbl_div_by_zero_0_main_msg
        # call println_string
        call
        # end call println_string
        # li a0, 1
        li
        # end li a0, 1
        # call exit
        call
        # end call exit
        j lbl_div_by_zero_0_main_msg
lbl_div_by_zero_0_main_msg:
        # .string "Division by 0"
        .string
        # end .string "Division by 0"
        j lbl_end_1_main
lbl_main_1_main:
        # li temp_0, 0
        li
        # end li temp_0, 0
        # li temp_1, 0
        li
        # end li temp_1, 0
        # li temp_2, 0
        li
        # end li temp_2, 0
        # (stat (assignment n = (expr (atom 6))) ;)
        # li temp_3, 6
        li
        # end li temp_3, 6
        # mv temp_2, temp_3
        mv
        # end mv temp_2, temp_3
        # (stat (assignment u = (expr (atom 12))) ;)
        # li temp_4, 12
        li
        # end li temp_4, 12
        # mv temp_1, temp_4
        mv
        # end mv temp_1, temp_4
        # (stat (assignment v = (expr (expr (atom n)) + (expr (atom u)))) ;)
        # add temp_5, temp_2, temp_1
        add
        # end add temp_5, temp_2, temp_1
        # mv temp_0, temp_5
        mv
        # end mv temp_0, temp_5
        # (stat (print_stat println_int ( (expr (atom v)) ) ;))
        # mv a0, temp_0
        mv
        # end mv a0, temp_0
        # call println_int
        call
        # end call println_int
        # Return at end of function:
        # li a0, 0
        li
        # end li a0, 0
        j lbl_end_1_main


##postlude

lbl_end_1_main:
        ld ra, 0(sp)
        ld fp, 8(sp)
        addi sp, sp, 64
        ret
        
______ TestCodeGen.test_alloc_mem[./TP05/tests/provided/dataflow/df02.c] _______

self = <test_codegen.TestCodeGen object at 0x7fab868a8e50>
output_name = './TP05/tests/provided/dataflow/df02-all_in_mem.s'
exec_name = './TP05/tests/provided/dataflow/df02.riscv'
info = testinfo(exitcode=0, execcode=0, output='1\n', linkargs=[], skip_test_expected=False)

    def link_and_run(self, output_name, exec_name, info):
        self.remove(exec_name)
        cmd = [
            ASM, output_name, 'TP04/libprint.s',
            '-o', exec_name
        ] + info.linkargs
        print(info)
        print("Assembling and linking " + output_name + ": " + ' '.join(cmd))
        try:
>           subprocess.check_output(cmd, timeout=60, stderr=subprocess.STDOUT)

test_codegen.py:169: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

timeout = 60
popenargs = (['riscv64-unknown-elf-gcc', './TP05/tests/provided/dataflow/df02-all_in_mem.s', 'TP04/libprint.s', '-o', './TP05/tests/provided/dataflow/df02.riscv'],)
kwargs = {'stderr': -2}

    def check_output(*popenargs, timeout=None, **kwargs):
        r"""Run command with arguments and return its output.
    
        If the exit code was non-zero it raises a CalledProcessError.  The
        CalledProcessError object will have the return code in the returncode
        attribute and output in the output attribute.
    
        The arguments are the same as for the Popen constructor.  Example:
    
        >>> check_output(["ls", "-l", "/dev/null"])
        b'crw-rw-rw- 1 root root 1, 3 Oct 18  2007 /dev/null\n'
    
        The stdout argument is not allowed as it is used internally.
        To capture standard error in the result, use stderr=STDOUT.
    
        >>> check_output(["/bin/sh", "-c",
        ...               "ls -l non_existent_file ; exit 0"],
        ...              stderr=STDOUT)
        b'ls: non_existent_file: No such file or directory\n'
    
        There is an additional optional argument, "input", allowing you to
        pass a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it too will be used internally.  Example:
    
        >>> check_output(["sed", "-e", "s/foo/bar/"],
        ...              input=b"when in the course of fooman events\n")
        b'when in the course of barman events\n'
    
        By default, all communication is in bytes, and therefore any "input"
        should be bytes, and the return value will be bytes.  If in text mode,
        any "input" should be a string, and the return value will be a string
        decoded according to locale encoding, or by "encoding" if set. Text mode
        is triggered by setting any of text, encoding, errors or universal_newlines.
        """
        if 'stdout' in kwargs:
            raise ValueError('stdout argument not allowed, it will be overridden.')
    
        if 'input' in kwargs and kwargs['input'] is None:
            # Explicitly passing input=None was previously equivalent to passing an
            # empty string. That is maintained here for backwards compatibility.
            if kwargs.get('universal_newlines') or kwargs.get('text'):
                empty = ''
            else:
                empty = b''
            kwargs['input'] = empty
    
>       return run(*popenargs, stdout=PIPE, timeout=timeout, check=True,
                   **kwargs).stdout

/usr/lib/python3.8/subprocess.py:415: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = False, timeout = 60, check = True
popenargs = (['riscv64-unknown-elf-gcc', './TP05/tests/provided/dataflow/df02-all_in_mem.s', 'TP04/libprint.s', '-o', './TP05/tests/provided/dataflow/df02.riscv'],)
kwargs = {'stderr': -2, 'stdout': -1}
process = <subprocess.Popen object at 0x7fab868a81c0>
stdout = b"./TP05/tests/provided/dataflow/df02-all_in_mem.s: Assembler messages:\n./TP05/tests/provided/dataflow/df02-all_in_me...:88: Error: illegal operands `mv'\n./TP05/tests/provided/dataflow/df02-all_in_mem.s:95: Error: illegal operands `li'\n"
stderr = None, retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout is given, and the process takes too long, a TimeoutExpired
        exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['riscv64-unknown-elf-gcc', './TP05/tests/provided/dataflow/df02-all_in_mem.s', 'TP04/libprint.s', '-o', './TP05/tests/provided/dataflow/df02.riscv']' returned non-zero exit status 1.

/usr/lib/python3.8/subprocess.py:516: CalledProcessError

During handling of the above exception, another exception occurred:

self = <test_codegen.TestCodeGen object at 0x7fab868a8e50>
filename = './TP05/tests/provided/dataflow/df02.c'

    @pytest.mark.parametrize('filename', ALL_IN_MEM_FILES)
    def test_alloc_mem(self, filename):
        expect = self.get_expect(filename)
>       actual = self.all_in_mem(filename, expect)

test_codegen.py:242: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
test_codegen.py:100: in all_in_mem
    return self.compile_and_simulate(file, info, reg_alloc='all_in_mem')
test_codegen.py:216: in compile_and_simulate
    return self.link_and_run(output_name, exec_name, info)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_codegen.TestCodeGen object at 0x7fab868a8e50>
output_name = './TP05/tests/provided/dataflow/df02-all_in_mem.s'
exec_name = './TP05/tests/provided/dataflow/df02.riscv'
info = testinfo(exitcode=0, execcode=0, output='1\n', linkargs=[], skip_test_expected=False)

    def link_and_run(self, output_name, exec_name, info):
        self.remove(exec_name)
        cmd = [
            ASM, output_name, 'TP04/libprint.s',
            '-o', exec_name
        ] + info.linkargs
        print(info)
        print("Assembling and linking " + output_name + ": " + ' '.join(cmd))
        try:
            subprocess.check_output(cmd, timeout=60, stderr=subprocess.STDOUT)
        except subprocess.CalledProcessError as e:
            print("Assembling failed:\n")
            print(e.output.decode())
            print("Assembler code below:\n")
            cat(output_name)
>           pytest.fail()
E           Failed

test_codegen.py:175: Failed
----------------------------- Captured stdout call -----------------------------
Compiling ...
/usr/bin/python3 ./MiniCC.py --reg-alloc=all_in_mem --output=./TP05/tests/provided/dataflow/df02-all_in_mem.s ./TP05/tests/provided/dataflow/df02.c
Exited with status: 0

Compiling ... OK
testinfo(exitcode=0, execcode=0, output='1\n', linkargs=[], skip_test_expected=False)
Assembling and linking ./TP05/tests/provided/dataflow/df02-all_in_mem.s: riscv64-unknown-elf-gcc ./TP05/tests/provided/dataflow/df02-all_in_mem.s TP04/libprint.s -o ./TP05/tests/provided/dataflow/df02.riscv
Assembling failed:

./TP05/tests/provided/dataflow/df02-all_in_mem.s: Assembler messages:
./TP05/tests/provided/dataflow/df02-all_in_mem.s:20: Error: illegal operands `la'
./TP05/tests/provided/dataflow/df02-all_in_mem.s:26: Error: illegal operands `li'
./TP05/tests/provided/dataflow/df02-all_in_mem.s:38: Error: illegal operands `li'
./TP05/tests/provided/dataflow/df02-all_in_mem.s:41: Error: illegal operands `li'
./TP05/tests/provided/dataflow/df02-all_in_mem.s:44: Error: illegal operands `li'
./TP05/tests/provided/dataflow/df02-all_in_mem.s:48: Error: illegal operands `li'
./TP05/tests/provided/dataflow/df02-all_in_mem.s:51: Error: illegal operands `mv'
./TP05/tests/provided/dataflow/df02-all_in_mem.s:55: Error: illegal operands `li'
./TP05/tests/provided/dataflow/df02-all_in_mem.s:58: Error: illegal operands `li'
./TP05/tests/provided/dataflow/df02-all_in_mem.s:61: Error: illegal operands `ble'
./TP05/tests/provided/dataflow/df02-all_in_mem.s:64: Error: illegal operands `li'
./TP05/tests/provided/dataflow/df02-all_in_mem.s:68: Error: illegal operands `mv'
./TP05/tests/provided/dataflow/df02-all_in_mem.s:72: Error: illegal operands `li'
./TP05/tests/provided/dataflow/df02-all_in_mem.s:75: Error: illegal operands `li'
./TP05/tests/provided/dataflow/df02-all_in_mem.s:78: Error: illegal operands `bge'
./TP05/tests/provided/dataflow/df02-all_in_mem.s:81: Error: illegal operands `li'
./TP05/tests/provided/dataflow/df02-all_in_mem.s:85: Error: illegal operands `and'
./TP05/tests/provided/dataflow/df02-all_in_mem.s:88: Error: illegal operands `mv'
./TP05/tests/provided/dataflow/df02-all_in_mem.s:95: Error: illegal operands `li'

Assembler code below:

##Automatically generated RISCV code, MIF08 & CAP
## all-in-memory allocation


##prelude

        .text
        .globl main
main:
        addi sp, sp, -96
        sd ra, 0(sp)
        sd fp, 8(sp)
        addi fp, sp, 96
        j lbl_main_3_main
        

##Generated Code
lbl_div_by_zero_0_main:
        # la a0, lbl_div_by_zero_0_main_msg
        la
        # end la a0, lbl_div_by_zero_0_main_msg
        # call println_string
        call
        # end call println_string
        # li a0, 1
        li
        # end li a0, 1
        # call exit
        call
        # end call exit
        j lbl_div_by_zero_0_main_msg
lbl_div_by_zero_0_main_msg:
        # .string "Division by 0"
        .string
        # end .string "Division by 0"
        j lbl_end_3_main
lbl_main_3_main:
        # li temp_0, 0
        li
        # end li temp_0, 0
        # li temp_1, 0
        li
        # end li temp_1, 0
        # li temp_2, 0
        li
        # end li temp_2, 0
        # (stat (assignment n = (expr (atom 6))) ;)
        # li temp_3, 6
        li
        # end li temp_3, 6
        # mv temp_1, temp_3
        mv
        # end mv temp_1, temp_3
        # (stat (assignment u = (expr (expr (atom 12)) > (expr (atom n)))) ;)
        # li temp_5, 12
        li
        # end li temp_5, 12
        # li temp_4, 0
        li
        # end li temp_4, 0
        # ble temp_5, temp_1, lbl_endrel_1_main
        ble
        # end ble temp_5, temp_1, lbl_endrel_1_main
        # li temp_4, 1
        li
        # end li temp_4, 1
lbl_endrel_1_main:
        # mv temp_2, temp_4
        mv
        # end mv temp_2, temp_4
        # (stat (print_stat println_int ( (expr (expr (expr (atom 1)) < (expr (atom n))) && (expr (atom u))) ) ;))
        # li temp_7, 1
        li
        # end li temp_7, 1
        # li temp_6, 0
        li
        # end li temp_6, 0
        # bge temp_7, temp_1, lbl_endrel_2_main
        bge
        # end bge temp_7, temp_1, lbl_endrel_2_main
        # li temp_6, 1
        li
        # end li temp_6, 1
lbl_endrel_2_main:
        # and temp_8, temp_6, temp_2
        and
        # end and temp_8, temp_6, temp_2
        # mv a0, temp_8
        mv
        # end mv a0, temp_8
        # call println_int
        call
        # end call println_int
        # Return at end of function:
        # li a0, 0
        li
        # end li a0, 0
        j lbl_end_3_main


##postlude

lbl_end_3_main:
        ld ra, 0(sp)
        ld fp, 8(sp)
        addi sp, sp, 96
        ret
        
______ TestCodeGen.test_alloc_mem[./TP05/tests/provided/dataflow/df03.c] _______

self = <test_codegen.TestCodeGen object at 0x7fab866ec8e0>
output_name = './TP05/tests/provided/dataflow/df03-all_in_mem.s'
exec_name = './TP05/tests/provided/dataflow/df03.riscv'
info = testinfo(exitcode=0, execcode=0, output='15\n', linkargs=[], skip_test_expected=False)

    def link_and_run(self, output_name, exec_name, info):
        self.remove(exec_name)
        cmd = [
            ASM, output_name, 'TP04/libprint.s',
            '-o', exec_name
        ] + info.linkargs
        print(info)
        print("Assembling and linking " + output_name + ": " + ' '.join(cmd))
        try:
>           subprocess.check_output(cmd, timeout=60, stderr=subprocess.STDOUT)

test_codegen.py:169: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

timeout = 60
popenargs = (['riscv64-unknown-elf-gcc', './TP05/tests/provided/dataflow/df03-all_in_mem.s', 'TP04/libprint.s', '-o', './TP05/tests/provided/dataflow/df03.riscv'],)
kwargs = {'stderr': -2}

    def check_output(*popenargs, timeout=None, **kwargs):
        r"""Run command with arguments and return its output.
    
        If the exit code was non-zero it raises a CalledProcessError.  The
        CalledProcessError object will have the return code in the returncode
        attribute and output in the output attribute.
    
        The arguments are the same as for the Popen constructor.  Example:
    
        >>> check_output(["ls", "-l", "/dev/null"])
        b'crw-rw-rw- 1 root root 1, 3 Oct 18  2007 /dev/null\n'
    
        The stdout argument is not allowed as it is used internally.
        To capture standard error in the result, use stderr=STDOUT.
    
        >>> check_output(["/bin/sh", "-c",
        ...               "ls -l non_existent_file ; exit 0"],
        ...              stderr=STDOUT)
        b'ls: non_existent_file: No such file or directory\n'
    
        There is an additional optional argument, "input", allowing you to
        pass a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it too will be used internally.  Example:
    
        >>> check_output(["sed", "-e", "s/foo/bar/"],
        ...              input=b"when in the course of fooman events\n")
        b'when in the course of barman events\n'
    
        By default, all communication is in bytes, and therefore any "input"
        should be bytes, and the return value will be bytes.  If in text mode,
        any "input" should be a string, and the return value will be a string
        decoded according to locale encoding, or by "encoding" if set. Text mode
        is triggered by setting any of text, encoding, errors or universal_newlines.
        """
        if 'stdout' in kwargs:
            raise ValueError('stdout argument not allowed, it will be overridden.')
    
        if 'input' in kwargs and kwargs['input'] is None:
            # Explicitly passing input=None was previously equivalent to passing an
            # empty string. That is maintained here for backwards compatibility.
            if kwargs.get('universal_newlines') or kwargs.get('text'):
                empty = ''
            else:
                empty = b''
            kwargs['input'] = empty
    
>       return run(*popenargs, stdout=PIPE, timeout=timeout, check=True,
                   **kwargs).stdout

/usr/lib/python3.8/subprocess.py:415: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = False, timeout = 60, check = True
popenargs = (['riscv64-unknown-elf-gcc', './TP05/tests/provided/dataflow/df03-all_in_mem.s', 'TP04/libprint.s', '-o', './TP05/tests/provided/dataflow/df03.riscv'],)
kwargs = {'stderr': -2, 'stdout': -1}
process = <subprocess.Popen object at 0x7fab866d93a0>
stdout = b"./TP05/tests/provided/dataflow/df03-all_in_mem.s: Assembler messages:\n./TP05/tests/provided/dataflow/df03-all_in_me...04: Error: illegal operands `mv'\n./TP05/tests/provided/dataflow/df03-all_in_mem.s:111: Error: illegal operands `li'\n"
stderr = None, retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout is given, and the process takes too long, a TimeoutExpired
        exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['riscv64-unknown-elf-gcc', './TP05/tests/provided/dataflow/df03-all_in_mem.s', 'TP04/libprint.s', '-o', './TP05/tests/provided/dataflow/df03.riscv']' returned non-zero exit status 1.

/usr/lib/python3.8/subprocess.py:516: CalledProcessError

During handling of the above exception, another exception occurred:

self = <test_codegen.TestCodeGen object at 0x7fab866ec8e0>
filename = './TP05/tests/provided/dataflow/df03.c'

    @pytest.mark.parametrize('filename', ALL_IN_MEM_FILES)
    def test_alloc_mem(self, filename):
        expect = self.get_expect(filename)
>       actual = self.all_in_mem(filename, expect)

test_codegen.py:242: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
test_codegen.py:100: in all_in_mem
    return self.compile_and_simulate(file, info, reg_alloc='all_in_mem')
test_codegen.py:216: in compile_and_simulate
    return self.link_and_run(output_name, exec_name, info)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_codegen.TestCodeGen object at 0x7fab866ec8e0>
output_name = './TP05/tests/provided/dataflow/df03-all_in_mem.s'
exec_name = './TP05/tests/provided/dataflow/df03.riscv'
info = testinfo(exitcode=0, execcode=0, output='15\n', linkargs=[], skip_test_expected=False)

    def link_and_run(self, output_name, exec_name, info):
        self.remove(exec_name)
        cmd = [
            ASM, output_name, 'TP04/libprint.s',
            '-o', exec_name
        ] + info.linkargs
        print(info)
        print("Assembling and linking " + output_name + ": " + ' '.join(cmd))
        try:
            subprocess.check_output(cmd, timeout=60, stderr=subprocess.STDOUT)
        except subprocess.CalledProcessError as e:
            print("Assembling failed:\n")
            print(e.output.decode())
            print("Assembler code below:\n")
            cat(output_name)
>           pytest.fail()
E           Failed

test_codegen.py:175: Failed
----------------------------- Captured stdout call -----------------------------
Compiling ...
/usr/bin/python3 ./MiniCC.py --reg-alloc=all_in_mem --output=./TP05/tests/provided/dataflow/df03-all_in_mem.s ./TP05/tests/provided/dataflow/df03.c
Exited with status: 0

Compiling ... OK
testinfo(exitcode=0, execcode=0, output='15\n', linkargs=[], skip_test_expected=False)
Assembling and linking ./TP05/tests/provided/dataflow/df03-all_in_mem.s: riscv64-unknown-elf-gcc ./TP05/tests/provided/dataflow/df03-all_in_mem.s TP04/libprint.s -o ./TP05/tests/provided/dataflow/df03.riscv
Assembling failed:

./TP05/tests/provided/dataflow/df03-all_in_mem.s: Assembler messages:
./TP05/tests/provided/dataflow/df03-all_in_mem.s:20: Error: illegal operands `la'
./TP05/tests/provided/dataflow/df03-all_in_mem.s:26: Error: illegal operands `li'
./TP05/tests/provided/dataflow/df03-all_in_mem.s:38: Error: illegal operands `li'
./TP05/tests/provided/dataflow/df03-all_in_mem.s:41: Error: illegal operands `li'
./TP05/tests/provided/dataflow/df03-all_in_mem.s:44: Error: illegal operands `li'
./TP05/tests/provided/dataflow/df03-all_in_mem.s:48: Error: illegal operands `li'
./TP05/tests/provided/dataflow/df03-all_in_mem.s:51: Error: illegal operands `mv'
./TP05/tests/provided/dataflow/df03-all_in_mem.s:55: Error: illegal operands `li'
./TP05/tests/provided/dataflow/df03-all_in_mem.s:58: Error: illegal operands `mv'
./TP05/tests/provided/dataflow/df03-all_in_mem.s:63: Error: illegal operands `li'
./TP05/tests/provided/dataflow/df03-all_in_mem.s:66: Error: illegal operands `li'
./TP05/tests/provided/dataflow/df03-all_in_mem.s:69: Error: illegal operands `ble'
./TP05/tests/provided/dataflow/df03-all_in_mem.s:72: Error: illegal operands `li'
./TP05/tests/provided/dataflow/df03-all_in_mem.s:76: Error: illegal operands `li'
./TP05/tests/provided/dataflow/df03-all_in_mem.s:79: Error: illegal operands `beq'
./TP05/tests/provided/dataflow/df03-all_in_mem.s:83: Error: illegal operands `li'
./TP05/tests/provided/dataflow/df03-all_in_mem.s:86: Error: illegal operands `sub'
./TP05/tests/provided/dataflow/df03-all_in_mem.s:89: Error: illegal operands `mv'
./TP05/tests/provided/dataflow/df03-all_in_mem.s:93: Error: illegal operands `add'
./TP05/tests/provided/dataflow/df03-all_in_mem.s:96: Error: illegal operands `mv'
./TP05/tests/provided/dataflow/df03-all_in_mem.s:104: Error: illegal operands `mv'
./TP05/tests/provided/dataflow/df03-all_in_mem.s:111: Error: illegal operands `li'

Assembler code below:

##Automatically generated RISCV code, MIF08 & CAP
## all-in-memory allocation


##prelude

        .text
        .globl main
main:
        addi sp, sp, -112
        sd ra, 0(sp)
        sd fp, 8(sp)
        addi fp, sp, 112
        j lbl_main_4_main
        

##Generated Code
lbl_div_by_zero_0_main:
        # la a0, lbl_div_by_zero_0_main_msg
        la
        # end la a0, lbl_div_by_zero_0_main_msg
        # call println_string
        call
        # end call println_string
        # li a0, 1
        li
        # end li a0, 1
        # call exit
        call
        # end call exit
        j lbl_div_by_zero_0_main_msg
lbl_div_by_zero_0_main_msg:
        # .string "Division by 0"
        .string
        # end .string "Division by 0"
        j lbl_end_4_main
lbl_main_4_main:
        # li temp_0, 0
        li
        # end li temp_0, 0
        # li temp_1, 0
        li
        # end li temp_1, 0
        # li temp_2, 0
        li
        # end li temp_2, 0
        # (stat (assignment n = (expr (atom 6))) ;)
        # li temp_3, 6
        li
        # end li temp_3, 6
        # mv temp_2, temp_3
        mv
        # end mv temp_2, temp_3
        # (stat (assignment u = (expr (atom 0))) ;)
        # li temp_4, 0
        li
        # end li temp_4, 0
        # mv temp_1, temp_4
        mv
        # end mv temp_1, temp_4
        # (stat (while_stat while ( (expr (expr (atom n)) > (expr (atom 1))) ) (stat_block { (block (stat (assignment n = (expr (expr (atom n)) - (expr (atom 1)))) ;) (stat (assignment u = (expr (expr (atom u)) + (expr (atom n)))) ;)) })))
lbl_test_1_main:
        # li temp_6, 1
        li
        # end li temp_6, 1
        # li temp_5, 0
        li
        # end li temp_5, 0
        # ble temp_2, temp_6, lbl_endrel_3_main
        ble
        # end ble temp_2, temp_6, lbl_endrel_3_main
        # li temp_5, 1
        li
        # end li temp_5, 1
lbl_endrel_3_main:
        # li temp_7, 0
        li
        # end li temp_7, 0
        # beq temp_5, temp_7, lbl_endwhile_2_main
        beq
        # end beq temp_5, temp_7, lbl_endwhile_2_main
        # (stat (assignment n = (expr (expr (atom n)) - (expr (atom 1)))) ;)
        # li temp_8, 1
        li
        # end li temp_8, 1
        # sub temp_9, temp_2, temp_8
        sub
        # end sub temp_9, temp_2, temp_8
        # mv temp_2, temp_9
        mv
        # end mv temp_2, temp_9
        # (stat (assignment u = (expr (expr (atom u)) + (expr (atom n)))) ;)
        # add temp_10, temp_1, temp_2
        add
        # end add temp_10, temp_1, temp_2
        # mv temp_1, temp_10
        mv
        # end mv temp_1, temp_10
        # j lbl_test_1_main
        j
        # end j lbl_test_1_main
lbl_endwhile_2_main:
        # (stat (print_stat println_int ( (expr (atom u)) ) ;))
        # mv a0, temp_1
        mv
        # end mv a0, temp_1
        # call println_int
        call
        # end call println_int
        # Return at end of function:
        # li a0, 0
        li
        # end li a0, 0
        j lbl_end_4_main


##postlude

lbl_end_4_main:
        ld ra, 0(sp)
        ld fp, 8(sp)
        addi sp, sp, 112
        ret
        
______ TestCodeGen.test_alloc_mem[./TP05/tests/provided/dataflow/df04.c] _______

self = <test_codegen.TestCodeGen object at 0x7fab869e0940>
output_name = './TP05/tests/provided/dataflow/df04-all_in_mem.s'
exec_name = './TP05/tests/provided/dataflow/df04.riscv'
info = testinfo(exitcode=0, execcode=0, output='', linkargs=[], skip_test_expected=False)

    def link_and_run(self, output_name, exec_name, info):
        self.remove(exec_name)
        cmd = [
            ASM, output_name, 'TP04/libprint.s',
            '-o', exec_name
        ] + info.linkargs
        print(info)
        print("Assembling and linking " + output_name + ": " + ' '.join(cmd))
        try:
>           subprocess.check_output(cmd, timeout=60, stderr=subprocess.STDOUT)

test_codegen.py:169: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

timeout = 60
popenargs = (['riscv64-unknown-elf-gcc', './TP05/tests/provided/dataflow/df04-all_in_mem.s', 'TP04/libprint.s', '-o', './TP05/tests/provided/dataflow/df04.riscv'],)
kwargs = {'stderr': -2}

    def check_output(*popenargs, timeout=None, **kwargs):
        r"""Run command with arguments and return its output.
    
        If the exit code was non-zero it raises a CalledProcessError.  The
        CalledProcessError object will have the return code in the returncode
        attribute and output in the output attribute.
    
        The arguments are the same as for the Popen constructor.  Example:
    
        >>> check_output(["ls", "-l", "/dev/null"])
        b'crw-rw-rw- 1 root root 1, 3 Oct 18  2007 /dev/null\n'
    
        The stdout argument is not allowed as it is used internally.
        To capture standard error in the result, use stderr=STDOUT.
    
        >>> check_output(["/bin/sh", "-c",
        ...               "ls -l non_existent_file ; exit 0"],
        ...              stderr=STDOUT)
        b'ls: non_existent_file: No such file or directory\n'
    
        There is an additional optional argument, "input", allowing you to
        pass a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it too will be used internally.  Example:
    
        >>> check_output(["sed", "-e", "s/foo/bar/"],
        ...              input=b"when in the course of fooman events\n")
        b'when in the course of barman events\n'
    
        By default, all communication is in bytes, and therefore any "input"
        should be bytes, and the return value will be bytes.  If in text mode,
        any "input" should be a string, and the return value will be a string
        decoded according to locale encoding, or by "encoding" if set. Text mode
        is triggered by setting any of text, encoding, errors or universal_newlines.
        """
        if 'stdout' in kwargs:
            raise ValueError('stdout argument not allowed, it will be overridden.')
    
        if 'input' in kwargs and kwargs['input'] is None:
            # Explicitly passing input=None was previously equivalent to passing an
            # empty string. That is maintained here for backwards compatibility.
            if kwargs.get('universal_newlines') or kwargs.get('text'):
                empty = ''
            else:
                empty = b''
            kwargs['input'] = empty
    
>       return run(*popenargs, stdout=PIPE, timeout=timeout, check=True,
                   **kwargs).stdout

/usr/lib/python3.8/subprocess.py:415: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = False, timeout = 60, check = True
popenargs = (['riscv64-unknown-elf-gcc', './TP05/tests/provided/dataflow/df04-all_in_mem.s', 'TP04/libprint.s', '-o', './TP05/tests/provided/dataflow/df04.riscv'],)
kwargs = {'stderr': -2, 'stdout': -1}
process = <subprocess.Popen object at 0x7fab86adca00>
stdout = b"./TP05/tests/provided/dataflow/df04-all_in_mem.s: Assembler messages:\n./TP05/tests/provided/dataflow/df04-all_in_me...:84: Error: illegal operands `mv'\n./TP05/tests/provided/dataflow/df04-all_in_mem.s:89: Error: illegal operands `li'\n"
stderr = None, retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout is given, and the process takes too long, a TimeoutExpired
        exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['riscv64-unknown-elf-gcc', './TP05/tests/provided/dataflow/df04-all_in_mem.s', 'TP04/libprint.s', '-o', './TP05/tests/provided/dataflow/df04.riscv']' returned non-zero exit status 1.

/usr/lib/python3.8/subprocess.py:516: CalledProcessError

During handling of the above exception, another exception occurred:

self = <test_codegen.TestCodeGen object at 0x7fab869e0940>
filename = './TP05/tests/provided/dataflow/df04.c'

    @pytest.mark.parametrize('filename', ALL_IN_MEM_FILES)
    def test_alloc_mem(self, filename):
        expect = self.get_expect(filename)
>       actual = self.all_in_mem(filename, expect)

test_codegen.py:242: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
test_codegen.py:100: in all_in_mem
    return self.compile_and_simulate(file, info, reg_alloc='all_in_mem')
test_codegen.py:216: in compile_and_simulate
    return self.link_and_run(output_name, exec_name, info)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_codegen.TestCodeGen object at 0x7fab869e0940>
output_name = './TP05/tests/provided/dataflow/df04-all_in_mem.s'
exec_name = './TP05/tests/provided/dataflow/df04.riscv'
info = testinfo(exitcode=0, execcode=0, output='', linkargs=[], skip_test_expected=False)

    def link_and_run(self, output_name, exec_name, info):
        self.remove(exec_name)
        cmd = [
            ASM, output_name, 'TP04/libprint.s',
            '-o', exec_name
        ] + info.linkargs
        print(info)
        print("Assembling and linking " + output_name + ": " + ' '.join(cmd))
        try:
            subprocess.check_output(cmd, timeout=60, stderr=subprocess.STDOUT)
        except subprocess.CalledProcessError as e:
            print("Assembling failed:\n")
            print(e.output.decode())
            print("Assembler code below:\n")
            cat(output_name)
>           pytest.fail()
E           Failed

test_codegen.py:175: Failed
----------------------------- Captured stdout call -----------------------------
Compiling ...
/usr/bin/python3 ./MiniCC.py --reg-alloc=all_in_mem --output=./TP05/tests/provided/dataflow/df04-all_in_mem.s ./TP05/tests/provided/dataflow/df04.c
Exited with status: 0

Compiling ... OK
testinfo(exitcode=0, execcode=0, output='', linkargs=[], skip_test_expected=False)
Assembling and linking ./TP05/tests/provided/dataflow/df04-all_in_mem.s: riscv64-unknown-elf-gcc ./TP05/tests/provided/dataflow/df04-all_in_mem.s TP04/libprint.s -o ./TP05/tests/provided/dataflow/df04.riscv
Assembling failed:

./TP05/tests/provided/dataflow/df04-all_in_mem.s: Assembler messages:
./TP05/tests/provided/dataflow/df04-all_in_mem.s:20: Error: illegal operands `la'
./TP05/tests/provided/dataflow/df04-all_in_mem.s:26: Error: illegal operands `li'
./TP05/tests/provided/dataflow/df04-all_in_mem.s:38: Error: illegal operands `li'
./TP05/tests/provided/dataflow/df04-all_in_mem.s:41: Error: illegal operands `li'
./TP05/tests/provided/dataflow/df04-all_in_mem.s:45: Error: illegal operands `li'
./TP05/tests/provided/dataflow/df04-all_in_mem.s:48: Error: illegal operands `mv'
./TP05/tests/provided/dataflow/df04-all_in_mem.s:52: Error: illegal operands `li'
./TP05/tests/provided/dataflow/df04-all_in_mem.s:55: Error: illegal operands `li'
./TP05/tests/provided/dataflow/df04-all_in_mem.s:58: Error: illegal operands `bge'
./TP05/tests/provided/dataflow/df04-all_in_mem.s:61: Error: illegal operands `li'
./TP05/tests/provided/dataflow/df04-all_in_mem.s:65: Error: illegal operands `li'
./TP05/tests/provided/dataflow/df04-all_in_mem.s:68: Error: illegal operands `beq'
./TP05/tests/provided/dataflow/df04-all_in_mem.s:71: Error: illegal operands `li'
./TP05/tests/provided/dataflow/df04-all_in_mem.s:74: Error: illegal operands `mv'
./TP05/tests/provided/dataflow/df04-all_in_mem.s:81: Error: illegal operands `li'
./TP05/tests/provided/dataflow/df04-all_in_mem.s:84: Error: illegal operands `mv'
./TP05/tests/provided/dataflow/df04-all_in_mem.s:89: Error: illegal operands `li'

Assembler code below:

##Automatically generated RISCV code, MIF08 & CAP
## all-in-memory allocation


##prelude

        .text
        .globl main
main:
        addi sp, sp, -80
        sd ra, 0(sp)
        sd fp, 8(sp)
        addi fp, sp, 80
        j lbl_main_4_main
        

##Generated Code
lbl_div_by_zero_0_main:
        # la a0, lbl_div_by_zero_0_main_msg
        la
        # end la a0, lbl_div_by_zero_0_main_msg
        # call println_string
        call
        # end call println_string
        # li a0, 1
        li
        # end li a0, 1
        # call exit
        call
        # end call exit
        j lbl_div_by_zero_0_main_msg
lbl_div_by_zero_0_main_msg:
        # .string "Division by 0"
        .string
        # end .string "Division by 0"
        j lbl_end_4_main
lbl_main_4_main:
        # li temp_0, 0
        li
        # end li temp_0, 0
        # li temp_1, 0
        li
        # end li temp_1, 0
        # (stat (assignment x = (expr (atom 2))) ;)
        # li temp_2, 2
        li
        # end li temp_2, 2
        # mv temp_1, temp_2
        mv
        # end mv temp_1, temp_2
        # (stat (if_stat if ( (expr (expr (atom x)) < (expr (atom 4))) ) (stat_block (stat (assignment x = (expr (atom 4))) ;)) else (stat_block (stat (assignment x = (expr (atom 5))) ;))))
        # li temp_4, 4
        li
        # end li temp_4, 4
        # li temp_3, 0
        li
        # end li temp_3, 0
        # bge temp_1, temp_4, lbl_endrel_3_main
        bge
        # end bge temp_1, temp_4, lbl_endrel_3_main
        # li temp_3, 1
        li
        # end li temp_3, 1
lbl_endrel_3_main:
        # li temp_5, 0
        li
        # end li temp_5, 0
        # beq temp_3, temp_5, lbl_else_1_main
        beq
        # end beq temp_3, temp_5, lbl_else_1_main
        # li temp_6, 4
        li
        # end li temp_6, 4
        # mv temp_1, temp_6
        mv
        # end mv temp_1, temp_6
        # j lbl_end_if_2_main
        j
        # end j lbl_end_if_2_main
lbl_else_1_main:
        # li temp_7, 5
        li
        # end li temp_7, 5
        # mv temp_1, temp_7
        mv
        # end mv temp_1, temp_7
lbl_end_if_2_main:
        # Return at end of function:
        # li a0, 0
        li
        # end li a0, 0
        j lbl_end_4_main


##postlude

lbl_end_4_main:
        ld ra, 0(sp)
        ld fp, 8(sp)
        addi sp, sp, 80
        ret
        
______ TestCodeGen.test_alloc_mem[./TP05/tests/provided/dataflow/df05.c] _______

self = <test_codegen.TestCodeGen object at 0x7fab86798940>
output_name = './TP05/tests/provided/dataflow/df05-all_in_mem.s'
exec_name = './TP05/tests/provided/dataflow/df05.riscv'
info = testinfo(exitcode=0, execcode=0, output='', linkargs=[], skip_test_expected=False)

    def link_and_run(self, output_name, exec_name, info):
        self.remove(exec_name)
        cmd = [
            ASM, output_name, 'TP04/libprint.s',
            '-o', exec_name
        ] + info.linkargs
        print(info)
        print("Assembling and linking " + output_name + ": " + ' '.join(cmd))
        try:
>           subprocess.check_output(cmd, timeout=60, stderr=subprocess.STDOUT)

test_codegen.py:169: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

timeout = 60
popenargs = (['riscv64-unknown-elf-gcc', './TP05/tests/provided/dataflow/df05-all_in_mem.s', 'TP04/libprint.s', '-o', './TP05/tests/provided/dataflow/df05.riscv'],)
kwargs = {'stderr': -2}

    def check_output(*popenargs, timeout=None, **kwargs):
        r"""Run command with arguments and return its output.
    
        If the exit code was non-zero it raises a CalledProcessError.  The
        CalledProcessError object will have the return code in the returncode
        attribute and output in the output attribute.
    
        The arguments are the same as for the Popen constructor.  Example:
    
        >>> check_output(["ls", "-l", "/dev/null"])
        b'crw-rw-rw- 1 root root 1, 3 Oct 18  2007 /dev/null\n'
    
        The stdout argument is not allowed as it is used internally.
        To capture standard error in the result, use stderr=STDOUT.
    
        >>> check_output(["/bin/sh", "-c",
        ...               "ls -l non_existent_file ; exit 0"],
        ...              stderr=STDOUT)
        b'ls: non_existent_file: No such file or directory\n'
    
        There is an additional optional argument, "input", allowing you to
        pass a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it too will be used internally.  Example:
    
        >>> check_output(["sed", "-e", "s/foo/bar/"],
        ...              input=b"when in the course of fooman events\n")
        b'when in the course of barman events\n'
    
        By default, all communication is in bytes, and therefore any "input"
        should be bytes, and the return value will be bytes.  If in text mode,
        any "input" should be a string, and the return value will be a string
        decoded according to locale encoding, or by "encoding" if set. Text mode
        is triggered by setting any of text, encoding, errors or universal_newlines.
        """
        if 'stdout' in kwargs:
            raise ValueError('stdout argument not allowed, it will be overridden.')
    
        if 'input' in kwargs and kwargs['input'] is None:
            # Explicitly passing input=None was previously equivalent to passing an
            # empty string. That is maintained here for backwards compatibility.
            if kwargs.get('universal_newlines') or kwargs.get('text'):
                empty = ''
            else:
                empty = b''
            kwargs['input'] = empty
    
>       return run(*popenargs, stdout=PIPE, timeout=timeout, check=True,
                   **kwargs).stdout

/usr/lib/python3.8/subprocess.py:415: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = None, capture_output = False, timeout = 60, check = True
popenargs = (['riscv64-unknown-elf-gcc', './TP05/tests/provided/dataflow/df05-all_in_mem.s', 'TP04/libprint.s', '-o', './TP05/tests/provided/dataflow/df05.riscv'],)
kwargs = {'stderr': -2, 'stdout': -1}
process = <subprocess.Popen object at 0x7fab86798670>
stdout = b"./TP05/tests/provided/dataflow/df05-all_in_mem.s: Assembler messages:\n./TP05/tests/provided/dataflow/df05-all_in_me...:76: Error: illegal operands `mv'\n./TP05/tests/provided/dataflow/df05-all_in_mem.s:84: Error: illegal operands `li'\n"
stderr = None, retcode = 1

    def run(*popenargs,
            input=None, capture_output=False, timeout=None, check=False, **kwargs):
        """Run command with arguments and return a CompletedProcess instance.
    
        The returned instance will have attributes args, returncode, stdout and
        stderr. By default, stdout and stderr are not captured, and those attributes
        will be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.
    
        If check is True and the exit code was non-zero, it raises a
        CalledProcessError. The CalledProcessError object will have the return code
        in the returncode attribute, and output & stderr attributes if those streams
        were captured.
    
        If timeout is given, and the process takes too long, a TimeoutExpired
        exception will be raised.
    
        There is an optional argument "input", allowing you to
        pass bytes or a string to the subprocess's stdin.  If you use this argument
        you may not also use the Popen constructor's "stdin" argument, as
        it will be used internally.
    
        By default, all communication is in bytes, and therefore any "input" should
        be bytes, and the stdout and stderr will be bytes. If in text mode, any
        "input" should be a string, and stdout and stderr will be strings decoded
        according to locale encoding, or by "encoding" if set. Text mode is
        triggered by setting any of text, encoding, errors or universal_newlines.
    
        The other arguments are the same as for the Popen constructor.
        """
        if input is not None:
            if kwargs.get('stdin') is not None:
                raise ValueError('stdin and input arguments may not both be used.')
            kwargs['stdin'] = PIPE
    
        if capture_output:
            if kwargs.get('stdout') is not None or kwargs.get('stderr') is not None:
                raise ValueError('stdout and stderr arguments may not be used '
                                 'with capture_output.')
            kwargs['stdout'] = PIPE
            kwargs['stderr'] = PIPE
    
        with Popen(*popenargs, **kwargs) as process:
            try:
                stdout, stderr = process.communicate(input, timeout=timeout)
            except TimeoutExpired as exc:
                process.kill()
                if _mswindows:
                    # Windows accumulates the output in a single blocking
                    # read() call run on child threads, with the timeout
                    # being done in a join() on those threads.  communicate()
                    # _after_ kill() is required to collect that and add it
                    # to the exception.
                    exc.stdout, exc.stderr = process.communicate()
                else:
                    # POSIX _communicate already populated the output so
                    # far into the TimeoutExpired exception.
                    process.wait()
                raise
            except:  # Including KeyboardInterrupt, communicate handled that.
                process.kill()
                # We don't call process.wait() as .__exit__ does that for us.
                raise
            retcode = process.poll()
            if check and retcode:
>               raise CalledProcessError(retcode, process.args,
                                         output=stdout, stderr=stderr)
E               subprocess.CalledProcessError: Command '['riscv64-unknown-elf-gcc', './TP05/tests/provided/dataflow/df05-all_in_mem.s', 'TP04/libprint.s', '-o', './TP05/tests/provided/dataflow/df05.riscv']' returned non-zero exit status 1.

/usr/lib/python3.8/subprocess.py:516: CalledProcessError

During handling of the above exception, another exception occurred:

self = <test_codegen.TestCodeGen object at 0x7fab86798940>
filename = './TP05/tests/provided/dataflow/df05.c'

    @pytest.mark.parametrize('filename', ALL_IN_MEM_FILES)
    def test_alloc_mem(self, filename):
        expect = self.get_expect(filename)
>       actual = self.all_in_mem(filename, expect)

test_codegen.py:242: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
test_codegen.py:100: in all_in_mem
    return self.compile_and_simulate(file, info, reg_alloc='all_in_mem')
test_codegen.py:216: in compile_and_simulate
    return self.link_and_run(output_name, exec_name, info)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <test_codegen.TestCodeGen object at 0x7fab86798940>
output_name = './TP05/tests/provided/dataflow/df05-all_in_mem.s'
exec_name = './TP05/tests/provided/dataflow/df05.riscv'
info = testinfo(exitcode=0, execcode=0, output='', linkargs=[], skip_test_expected=False)

    def link_and_run(self, output_name, exec_name, info):
        self.remove(exec_name)
        cmd = [
            ASM, output_name, 'TP04/libprint.s',
            '-o', exec_name
        ] + info.linkargs
        print(info)
        print("Assembling and linking " + output_name + ": " + ' '.join(cmd))
        try:
            subprocess.check_output(cmd, timeout=60, stderr=subprocess.STDOUT)
        except subprocess.CalledProcessError as e:
            print("Assembling failed:\n")
            print(e.output.decode())
            print("Assembler code below:\n")
            cat(output_name)
>           pytest.fail()
E           Failed

test_codegen.py:175: Failed
----------------------------- Captured stdout call -----------------------------
Compiling ...
/usr/bin/python3 ./MiniCC.py --reg-alloc=all_in_mem --output=./TP05/tests/provided/dataflow/df05-all_in_mem.s ./TP05/tests/provided/dataflow/df05.c
Exited with status: 0

Compiling ... OK
testinfo(exitcode=0, execcode=0, output='', linkargs=[], skip_test_expected=False)
Assembling and linking ./TP05/tests/provided/dataflow/df05-all_in_mem.s: riscv64-unknown-elf-gcc ./TP05/tests/provided/dataflow/df05-all_in_mem.s TP04/libprint.s -o ./TP05/tests/provided/dataflow/df05.riscv
Assembling failed:

./TP05/tests/provided/dataflow/df05-all_in_mem.s: Assembler messages:
./TP05/tests/provided/dataflow/df05-all_in_mem.s:20: Error: illegal operands `la'
./TP05/tests/provided/dataflow/df05-all_in_mem.s:26: Error: illegal operands `li'
./TP05/tests/provided/dataflow/df05-all_in_mem.s:38: Error: illegal operands `li'
./TP05/tests/provided/dataflow/df05-all_in_mem.s:42: Error: illegal operands `li'
./TP05/tests/provided/dataflow/df05-all_in_mem.s:45: Error: illegal operands `mv'
./TP05/tests/provided/dataflow/df05-all_in_mem.s:50: Error: illegal operands `li'
./TP05/tests/provided/dataflow/df05-all_in_mem.s:53: Error: illegal operands `li'
./TP05/tests/provided/dataflow/df05-all_in_mem.s:56: Error: illegal operands `bge'
./TP05/tests/provided/dataflow/df05-all_in_mem.s:59: Error: illegal operands `li'
./TP05/tests/provided/dataflow/df05-all_in_mem.s:63: Error: illegal operands `li'
./TP05/tests/provided/dataflow/df05-all_in_mem.s:66: Error: illegal operands `beq'
./TP05/tests/provided/dataflow/df05-all_in_mem.s:70: Error: illegal operands `li'
./TP05/tests/provided/dataflow/df05-all_in_mem.s:73: Error: illegal operands `add'
./TP05/tests/provided/dataflow/df05-all_in_mem.s:76: Error: illegal operands `mv'
./TP05/tests/provided/dataflow/df05-all_in_mem.s:84: Error: illegal operands `li'

Assembler code below:

##Automatically generated RISCV code, MIF08 & CAP
## all-in-memory allocation


##prelude

        .text
        .globl main
main:
        addi sp, sp, -80
        sd ra, 0(sp)
        sd fp, 8(sp)
        addi fp, sp, 80
        j lbl_main_4_main
        

##Generated Code
lbl_div_by_zero_0_main:
        # la a0, lbl_div_by_zero_0_main_msg
        la
        # end la a0, lbl_div_by_zero_0_main_msg
        # call println_string
        call
        # end call println_string
        # li a0, 1
        li
        # end li a0, 1
        # call exit
        call
        # end call exit
        j lbl_div_by_zero_0_main_msg
lbl_div_by_zero_0_main_msg:
        # .string "Division by 0"
        .string
        # end .string "Division by 0"
        j lbl_end_4_main
lbl_main_4_main:
        # li temp_0, 0
        li
        # end li temp_0, 0
        # (stat (assignment x = (expr (atom 0))) ;)
        # li temp_1, 0
        li
        # end li temp_1, 0
        # mv temp_0, temp_1
        mv
        # end mv temp_0, temp_1
        # (stat (while_stat while ( (expr (expr (atom x)) < (expr (atom 4))) ) (stat_block { (block (stat (assignment x = (expr (expr (atom x)) + (expr (atom 1)))) ;)) })))
lbl_test_1_main:
        # li temp_3, 4
        li
        # end li temp_3, 4
        # li temp_2, 0
        li
        # end li temp_2, 0
        # bge temp_0, temp_3, lbl_endrel_3_main
        bge
        # end bge temp_0, temp_3, lbl_endrel_3_main
        # li temp_2, 1
        li
        # end li temp_2, 1
lbl_endrel_3_main:
        # li temp_4, 0
        li
        # end li temp_4, 0
        # beq temp_2, temp_4, lbl_endwhile_2_main
        beq
        # end beq temp_2, temp_4, lbl_endwhile_2_main
        # (stat (assignment x = (expr (expr (atom x)) + (expr (atom 1)))) ;)
        # li temp_5, 1
        li
        # end li temp_5, 1
        # add temp_6, temp_0, temp_5
        add
        # end add temp_6, temp_0, temp_5
        # mv temp_0, temp_6
        mv
        # end mv temp_0, temp_6
        # j lbl_test_1_main
        j
        # end j lbl_test_1_main
lbl_endwhile_2_main:
        # Return at end of function:
        # li a0, 0
        li
        # end li a0, 0
        j lbl_end_4_main


##postlude

lbl_end_4_main:
        ld ra, 0(sp)
        ld fp, 8(sp)
        addi sp, sp, 80
        ret
        

---------- coverage: platform linux, python 3.8.10-final-0 -----------
Name                            Stmts   Miss  Cover
---------------------------------------------------
Errors.py                           8      0   100%
MiniCC.py                         143     53    63%
MiniCInterpreter.py                48     48     0%
MiniCLexer.py                     184      1    99%
MiniCParser.py                   1407    279    80%
MiniCVisitor.py                    74     29    61%
TP03/MiniCTypingVisitor.py        138     24    83%
TP04/APIRiscV.py                  134     43    68%
TP04/Instruction3A.py             106     30    72%
TP04/MiniCCodeGen3AVisitor.py     184     12    93%
TP04/Operands.py                  133     24    82%
TP04/SimpleAllocations.py          54      5    91%
TP05/CFG.py                       195     44    77%
TP05/LibGraphes.py                235    195    17%
TP05/LivenessDataFlow.py           54     42    22%
TP05/LivenessSSA.py                52     38    27%
TP05/SSA.py                       114     89    22%
TP05/SmartAllocation.py            82     65    21%
test_codegen.py                   151     25    83%
test_expect_pragma.py             100     26    74%
test_interpreter.py                33     33     0%
---------------------------------------------------
TOTAL                            3629   1105    70%
Coverage HTML written to dir htmlcov

=========================== short test summary info ============================
SKIPPED [5] test_codegen.py:224: Skipping test because it contains SKIP TEST EXPECTED
SKIPPED [1] test_codegen.py:141: Too big for the naive allocator
====== 32 failed, 58 passed, 6 skipped, 6 deselected in 82.25s (0:01:22) =======
